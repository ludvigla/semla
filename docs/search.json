[{"path":"https://ludvigla.github.io/semla/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 semla authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":[]},{"path":[]},{"path":"https://ludvigla.github.io/semla/TODO.html","id":"external-data","dir":"","previous_headings":"TODO","what":"External data","title":"semla","text":": external data resource mouse brain data. Contains spaceranger output files prepared Seurat object. files can accessed system.file(\"extdata/mousebrain\", \"path_to_file\", package = \"semla\") : external data resource mouse colon data. Contains spaceranger output files prepared Seurat object. files can accessed system.file(\"extdata/mousecolon\", \"path_to_file\", package = \"semla\")","code":""},{"path":"https://ludvigla.github.io/semla/TODO.html","id":"data-loading","dir":"","previous_headings":"TODO","what":"Data loading","title":"semla","text":"LoadAndMergeMatrices : load merge gene expression matrices LoadSpatialCoordinates : load merge spatial coordinates ReadVisiumData : wrapper LoadAndMergeMatrices LoadSpatialCoordinates load data Seurat object. Dropped compatibility “1k” “2k” arrays. function similar InputFromTable. LoadImages : load H&E images Seurat object","code":""},{"path":"https://ludvigla.github.io/semla/TODO.html","id":"subset-and-merge","dir":"","previous_headings":"TODO","what":"Subset and Merge","title":"semla","text":"SubsetSTData : subsetting Seurat objects created semla MergeSTData : merging Seurat objects created semla","code":""},{"path":"https://ludvigla.github.io/semla/TODO.html","id":"on-load","dir":"","previous_headings":"TODO","what":"On load","title":"semla","text":".onAttach : load message loading R package","code":""},{"path":"https://ludvigla.github.io/semla/TODO.html","id":"external-data-1","dir":"","previous_headings":"TODO","what":"External data","title":"semla","text":"Visium mouse brain dataset : mouse brain test data Visium mouse colon dataset : mouse colon test data","code":""},{"path":"https://ludvigla.github.io/semla/TODO.html","id":"transformations","dir":"","previous_headings":"TODO","what":"Transformations","title":"semla","text":"CoordMirror : mirror coordinates predefined center CoordTransform : apply rotations translations coordinates around predefined center ImageTranslate : apply translations image ImageTransform : apply rotation translation image CoordAndImageTransform : wrapper ImageTransform CoordTransform apply transformations paired image coordinates. Can rotations, translations mirroring","code":""},{"path":"https://ludvigla.github.io/semla/TODO.html","id":"image-processing","dir":"","previous_headings":"TODO","what":"Image processing","title":"semla","text":"MaskImages uses simple method identify tissue section mask background implemented magick RigidTransformImages takes tibble transformations applies transformations H&E images together spot coordinates.","code":""},{"path":"https://ludvigla.github.io/semla/TODO.html","id":"tissue-viewer","dir":"","previous_headings":"TODO","what":"Tissue viewer","title":"semla","text":"make OSD viewer tile sourse draw spots top tile source lasso selection tool manual annotation paper JS annotate spots save selection make tile function TileImage compatible OSD send data OSD viewer R read R selection?","code":""},{"path":"https://ludvigla.github.io/semla/TODO.html","id":"tissue-aligner","dir":"","previous_headings":"TODO","what":"Tissue aligner","title":"semla","text":"make paper JS tool image tranformations communicate transformations R apply transformations images R object CoordAndImageTransform add side bar image selection","code":""},{"path":"https://ludvigla.github.io/semla/TODO.html","id":"digital-unrolling","dir":"","previous_headings":"TODO","what":"Digital unrolling","title":"semla","text":"CutSpatialNetwork : Open shiny/react application can used “digital unrolling”","code":""},{"path":"https://ludvigla.github.io/semla/TODO.html","id":"visualization-tools","dir":"","previous_headings":"TODO","what":"Visualization tools","title":"semla","text":"FeatureOverlay : function now removed instead use MapFeatures now takes argument image_use inject images plot. DimOverlay : function now removed instead use MapFeatures now takes argument image_use inject images plot. MapFeatures : similar ST.FeaturePlot ST.DimPlot works numeric features gene expression, PCs, QC metrics etc. MapLabels : similar ST.FeaturePlot works categorical features clusters, conditions etc. FactorGeneLoadingPlot : sure needed singlet R package available ImagePlot : plots H&E images stored Seurat object MapFeaturesSummary : create spatial maps MapFeatures add summary plot next MapLabelsSummary : create spatial maps MapLabels add summary plot next AnglePlot : draw set arrows top selected region spots. Mean used helper selecting angle intervals RadialDistance","code":""},{"path":"https://ludvigla.github.io/semla/TODO.html","id":"matrix-factorization","dir":"","previous_headings":"TODO","what":"Matrix factorization","title":"semla","text":"RunNMF : longer needed singlet R package available SeededNMF : seed matrix factorization priori information fro single-cell data","code":""},{"path":"https://ludvigla.github.io/semla/TODO.html","id":"spatial-autocorelation","dir":"","previous_headings":"TODO","what":"Spatial autocorelation","title":"semla","text":"migrate GetSpatNet STUtility migrate CorSpatialGenes STUtility rename CorSpatialFeatures. general function takes type feature input, just genes. example dimensionality reduction results instead.","code":""},{"path":"https://ludvigla.github.io/semla/TODO.html","id":"spatial-methods","dir":"","previous_headings":"TODO","what":"Spatial methods","title":"semla","text":"migrate RegionNeighbours STUtility RadialDistance : calculates radial distances borders region interest DisconnectRegions : separates spatially disconnected regions NeighbourhoodEnrichmentTest : Pairwise testing cluster co-occurance. Start checking nearest neighbors. Later, add possibility measuring distance(?). LabelAssortativityTest : Inspired Newman’s Assortativity. Check whether selection spots follow dispersed clustered spatial pattern. [] Add CentralityScore method?","code":""},{"path":"https://ludvigla.github.io/semla/TODO.html","id":"staffli","dir":"","previous_headings":"TODO","what":"Staffli","title":"semla","text":"migrate modify STUtility S4 class object Staffli","code":""},{"path":"https://ludvigla.github.io/semla/TODO.html","id":"semla-website","dir":"","previous_headings":"TODO","what":"semla website","title":"semla","text":"getting started visualization spatial methods","code":""},{"path":"https://ludvigla.github.io/semla/articles/STUtility2.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Get started","text":"STUtility2 currently available development version GitHub: Load library","code":"remotes::install_github(\"ludvigla/STUtility2\") library(STUtility2) packageVersion(\"STUtility2\")"},{"path":"https://ludvigla.github.io/semla/articles/STUtility2.html","id":"authors","dir":"Articles","previous_headings":"","what":"Authors","title":"Get started","text":"package written Ludvig Larsson Lovisa Franzén part Spatial Research lab SciLifeLab Stockholm.","code":""},{"path":"https://ludvigla.github.io/semla/articles/STUtility2.html","id":"publication","dir":"Articles","previous_headings":"","what":"Publication","title":"Get started","text":"use STUtility2 published research, please cite following article:","code":""},{"path":"https://ludvigla.github.io/semla/articles/advanced_visualization.html","id":"load-data","dir":"Articles","previous_headings":"","what":"Load data","title":"Advanced visualization","text":"First need load 10x Visium data. ’ll use mouse brain tissue dataset mouse colon dataset shipped semla. can use functions MapFeatures MapLabels make spatial plots showing distribution numeric categorical features. familiar Seurat, functions similar SpatialFeaturePlot SpatialDimPlot sense first can used visualize numeric data latter can used color data points based categorical data.","code":"# Load data se_mbrain <- readRDS(file = system.file(\"extdata\",                                          \"mousebrain/se_mbrain\",                                          package = \"semla\")) se_mbrain$sample_id <- \"mousebrain\" se_mcolon <- readRDS(file = system.file(\"extdata\",                                          \"mousecolon/se_mcolon\",                                          package = \"semla\")) se_mcolon$sample_id <- \"mousecolon\" se <- MergeSTData(se_mbrain, se_mcolon)"},{"path":"https://ludvigla.github.io/semla/articles/advanced_visualization.html","id":"map-numeric-features","dir":"Articles","previous_headings":"","what":"Map numeric features","title":"Advanced visualization","text":"Let’s get started MapFeatures. basic usage map gene expression spatially:","code":"cols <- viridis::rocket(11, direction = -1) p <- MapFeatures(se, features = c(\"Th\", \"Clu\"), colors = cols) p"},{"path":"https://ludvigla.github.io/semla/articles/advanced_visualization.html","id":"summary-subplot","dir":"Articles","previous_headings":"Map numeric features","what":"Summary subplot","title":"Advanced visualization","text":"can also use function MapFeaturesSummary add subplot next spatial plot summarizing gene expression section using either box plot, violin plot, histogram, density plot. function takes one gene time, can patch two plots together manually desired.","code":"p <- MapFeaturesSummary(se,                          features = \"Clu\",                          subplot_type = \"violin\",                          colors = cols) p p1 <- MapFeaturesSummary(se,                          section_number = 1,                          features = \"Clu\",                           subplot_type = \"box\",                           colors = cols,                           fill_color = \"white\") p2 <- MapFeaturesSummary(se,                          section_number = 1,                          features = \"Clu\",                           subplot_type = \"histogram\",                           colors = cols) p1|p2 genes_to_plot <- c(\"Clu\", \"Apod\", \"Cd79a\")  plot_list <- lapply(genes_to_plot, function(g){   MapFeaturesSummary(se,                      section_number = 1,                      features = g,                       subplot_type = \"density\",                       pt_size = 0.8,                      colors = cols) }) wrap_plots(plot_list, nrow = 1)"},{"path":"https://ludvigla.github.io/semla/articles/advanced_visualization.html","id":"overlay-maps-on-images","dir":"Articles","previous_headings":"Map numeric features","what":"Overlay maps on images","title":"Advanced visualization","text":"want create map H&E images can setting image_use = raw. can , need load images Seurat object:  Right now ’s quite difficult see tissue underneath spots. can add opacity colors scaled feature values make spots low expression transparent:","code":"cols_he <- viridis::viridis(11) se <- LoadImages(se, verbose = FALSE)  p <- MapFeatures(se,                   features = c(\"Th\", \"Clu\"),                   image_use = \"raw\",                   colors = cols_he) p p <- MapFeatures(se,                   features = c(\"Th\", \"Clu\"),                   image_use = \"raw\",                  colors = cols_he,                   scale_alpha = TRUE) p"},{"path":"https://ludvigla.github.io/semla/articles/advanced_visualization.html","id":"transpose-patchwork-layout","dir":"Articles","previous_headings":"Map numeric features","what":"Transpose patchwork layout","title":"Advanced visualization","text":"default, MapFeatures arranges features columns samples rows. can transpose plot setting arrange_features “row”:","code":"p <- MapFeatures(se,                   features = c(\"Th\", \"Clu\"),                   arrange_features = \"row\",                   color = cols) p"},{"path":"https://ludvigla.github.io/semla/articles/advanced_visualization.html","id":"independent-color-bars","dir":"Articles","previous_headings":"Map numeric features","what":"Independent color bars","title":"Advanced visualization","text":"color bars now identical feature. MapFeatures calculates range feature uses range determine limits color bars. want change behavior scale values independently, can set scale = \"free\":","code":"p <- MapFeatures(se,                   features = c(\"Th\", \"Clu\"),                   scale = \"free\",                   colors = cols) p"},{"path":"https://ludvigla.github.io/semla/articles/advanced_visualization.html","id":"fit-plot-area-to-spots","dir":"Articles","previous_headings":"Map numeric features","what":"Fit plot area to spots","title":"Advanced visualization","text":"MapFeatures used image dimensions define plot area dimensions. Sometimes, small piece tissue, end lot white space. can override behavior setting override_plot_dims = TRUE make MapFeatures compute dimensions based coordinates. Notice tissues expanded:","code":"p <- MapFeatures(se,                   features = c(\"Th\", \"Clu\"),                   override_plot_dims = TRUE,                   color = cols) p"},{"path":"https://ludvigla.github.io/semla/articles/advanced_visualization.html","id":"controlling-themes","dir":"Articles","previous_headings":"Map numeric features","what":"Controlling themes","title":"Advanced visualization","text":"Themes can modified adding new ggplot theme using & operator. operator make sure theme added subplot patchwork. example, let’s say want place legends right side plots instead:  can also remove color legends entirely:  remove everything except spatial feature map:","code":"p <- MapFeatures(se, features = c(\"Th\", \"Clu\"), color = cols) &   theme(legend.position = \"right\", legend.text = element_text(angle = 0)) p p <- MapFeatures(se, features = c(\"Th\", \"Clu\"), colors = cols) &   theme(legend.position = \"none\") p p <- MapFeatures(se, features = c(\"Th\", \"Clu\"), colors = cols) &   theme(legend.position = \"none\",          plot.title = element_blank(),          plot.subtitle = element_blank()) p"},{"path":"https://ludvigla.github.io/semla/articles/advanced_visualization.html","id":"collect-color-bars","dir":"Articles","previous_headings":"Map numeric features","what":"Collect color bars","title":"Advanced visualization","text":"don’t want color bar next tissue section, can collect identical color bars place side. can use plot_layout(guides = \"collect\") modify . Note want place color bar right side plots, need set arrange_features = \"row\"` adjust legend position:  already looks quite good, color bars bit misplaced. can adjust placement modifying legend margins:","code":"p <- MapFeatures(se,                   features = c(\"Th\", \"Clu\"),                   arrange_features = \"row\",                   colors = cols) +   plot_layout(guides = \"collect\") &   theme(legend.position = \"right\", legend.text = element_text(angle = 0)) p p <- MapFeatures(se,                   features = c(\"Th\", \"Clu\"),                   arrange_features = \"row\",                   color = cols) +   plot_layout(guides = \"collect\") &   theme(legend.position = \"right\",          legend.text = element_text(angle = 0),         legend.margin = margin(t = 50, r = 0, b = 100, l = 0)) p"},{"path":"https://ludvigla.github.io/semla/articles/advanced_visualization.html","id":"do-not-do-this","dir":"Articles","previous_headings":"Map numeric features > Collect color bars","what":"Do not do this","title":"Advanced visualization","text":"set scale = \"free\", color bars longer unique doesn’t make sense collect color bars anymore:","code":"p <- MapFeatures(se,                   features = c(\"Th\", \"Clu\"),                   arrange_features = \"row\",                   scale = \"free\",                   colors = cols) +   plot_layout(guides = \"collect\") &   theme(legend.position = \"right\",          legend.text = element_text(angle = 0),         legend.margin = margin(t = 50, r = 0, b = 100, l = 0)) p"},{"path":"https://ludvigla.github.io/semla/articles/advanced_visualization.html","id":"do-not-do-this-either","dir":"Articles","previous_headings":"Map numeric features > Collect color bars","what":"Do not do this either","title":"Advanced visualization","text":"set arrange_features = \"col\", placement color bar make sense case either. color bars now located right side, features arranged row:  Instead, want arrange features columns, make sense place color bars top column adjust legend margins accordingly:","code":"p <- MapFeatures(se,                   features = c(\"Th\", \"Clu\"),                   arrange_features = \"col\",                   colors = cols) +   plot_layout(guides = \"collect\") &   theme(legend.position = \"right\",          legend.text = element_text(angle = 0),         legend.margin = margin(t = 50, r = 0, b = 100, l = 0)) p p <- MapFeatures(se,                   features = c(\"Th\", \"Clu\"),                   arrange_features = \"col\",                   color = cols) +   plot_layout(guides = \"collect\") &   theme(legend.position = \"top\",          legend.text = element_text(angle = 0),         legend.margin = margin(t = 0, r = 100, b = 0, l = 10)) p"},{"path":"https://ludvigla.github.io/semla/articles/advanced_visualization.html","id":"remove-plot-margins","dir":"Articles","previous_headings":"Map numeric features","what":"Remove plot margins","title":"Advanced visualization","text":"still think ’s much empty space around tissues patchwork, try setting override_plot_dims = TRUE crop plot area fit spots:","code":"p <- MapFeatures(se,                   features = c(\"Th\", \"Clu\"),                   override_plot_dims = TRUE,                   color = cols) p"},{"path":"https://ludvigla.github.io/semla/articles/advanced_visualization.html","id":"crop","dir":"Articles","previous_headings":"Map numeric features","what":"Crop","title":"Advanced visualization","text":"H&E images also cropped fit new plot dimensions override_plot_dims = TRUE. can particularly useful working small tissue sections cover small portion 10x Visium capture area.  Note plots dimensions calculated entire dataset override_plot_dims = TRUE. tissue sections placed different part capture area, resulting “crop” window might looking . want avoid behavior, better make two separate plots. Notice difference plot compared previous plot. previous plot empty space outside tissue.  can also crop images manually defining crop_area. crop_area vector length four defining corners rectangle, x- y-axes defined 0-1. order decide rectangle defined, can get help adding grid plot:  Now want crop GALT tissue mouse colon sample can cut image left=0.45, bottom=0.55, right=0.65, top=0.7:  can patch together nice figure showing expression global level inside GALT:","code":"p <- MapFeatures(se,                   features = c(\"Th\", \"Clu\"),                   image_use = \"raw\",                   override_plot_dims = TRUE,                   color = cols_he) p p1 <- MapFeatures(se,                    features = c(\"Th\", \"Clu\"),                    image_use = \"raw\",                    override_plot_dims = TRUE,                    color = cols_he,                    section_number = 1) p2 <- MapFeatures(se,                    features = c(\"Th\", \"Clu\"),                    image_use = \"raw\",                    override_plot_dims = TRUE,                    color = cols_he,                    section_number = 2) p1 / p2 p <- MapFeatures(se,                   features = c(\"Th\", \"Clu\"),                   image_use = \"raw\",                   color = cols_he,                   pt_alpha = 0.5) &   theme(panel.grid.major = element_line(linetype = \"dashed\"), axis.text = element_text()) p p <- MapFeatures(se,                   features = c(\"Cd79a\", \"Clu\"),                   image_use = \"raw\",                   pt_size = 3,                   section_number = 2,                   color = cols_he,                   crop_area = c(0.45, 0.55, 0.65, 0.7)) p p_global <- MapFeatures(se,                          features = c(\"Cd79a\", \"Clu\"),                          image_use = \"raw\",                          scale_alpha = TRUE,                         pt_size = 1,                          section_number = 2,                          color = cols_he,                          override_plot_dims = TRUE) p_GALT <- MapFeatures(se,                        features = c(\"Cd79a\", \"Clu\"),                        image_use = \"raw\",                        scale_alpha = TRUE,                        pt_size = 3,                        section_number = 2,                        color = cols_he,                        crop_area = c(0.45, 0.55, 0.65, 0.7)) &   theme(plot.title = element_blank(),          plot.subtitle = element_blank(),          legend.position = \"none\")  (p_global / p_GALT)"},{"path":"https://ludvigla.github.io/semla/articles/advanced_visualization.html","id":"increase-resolution","dir":"Articles","previous_headings":"Map numeric features","what":"Increase resolution","title":"Advanced visualization","text":"Right now, can see resolution zoomed image quite low. reason images loaded height 400 pixels default setting LoadImages. want , can reload images higher resolution given provided higher resolution images input. example, used “tissue_hires_image.png” files input ReadVisiumData, images roughly 2000x2000 pixels size, can reload images higher resolution. run LoadImages set image_height = 1000 able view H%&E images slightly higher resolution. Note higher resolution images take space might slow plotting considerably.","code":"se_high_res <- LoadImages(se, image_height = 1000) ## ## ── Loading H&E images ── ## ## ℹ Loading image from /private/var/folders/zb/1fj07x_5343fvs_k28gnm1z80002xs/T/RtmpFJGwBj/temp_libpath502354c29e9d/semla/extdata/mousebrain/spatial/tissue_hires_image.jpg ## ℹ Scaled image from 2000x1882 to 1000x941 pixels ## ℹ Loading image from /private/var/folders/zb/1fj07x_5343fvs_k28gnm1z80002xs/T/RtmpFJGwBj/temp_libpath502354c29e9d/semla/extdata/mousecolon/spatial/tissue_hires_image.jpg ## ℹ Scaled image from 1804x2000 to 1000x1109 pixels ## ℹ Saving loaded H&E images as 'rasters' in Seurat object # Check object sizes print(object.size(se), units = \"MB\") ## 15.8 Mb print(object.size(se_high_res), units = \"MB\") ## 39.2 Mb p_global <- MapFeatures(se_high_res,                          features = c(\"Cd79a\", \"Clu\"),                          image_use = \"raw\",                          scale_alpha = TRUE,                         pt_size = 1,                          section_number = 2,                          color = cols_he,                          override_plot_dims = TRUE) p_GALT <- MapFeatures(se_high_res,                        features = c(\"Cd79a\", \"Clu\"),                        image_use = \"raw\",                        scale_alpha = TRUE,                        pt_size = 3,                        section_number = 2,                        color = cols_he,                        crop_area = c(0.45, 0.55, 0.65, 0.7)) &   theme(plot.title = element_blank(),          plot.subtitle = element_blank(),          legend.position = \"none\")  (p_global / p_GALT)"},{"path":"https://ludvigla.github.io/semla/articles/advanced_visualization.html","id":"map-categorical-features","dir":"Articles","previous_headings":"","what":"Map categorical features","title":"Advanced visualization","text":"categorical data, use MapLabels() instead MapFeatures(). function allows us color spots based column Seurat object containing categorical data.","code":"MapLabels(se, column_name = \"sample_id\", ncol = 1) &   theme(legend.position = \"right\")"},{"path":"https://ludvigla.github.io/semla/articles/advanced_visualization.html","id":"order-of-categories","dir":"Articles","previous_headings":"Map categorical features","what":"Order of categories","title":"Advanced visualization","text":"Categorical data can represented character vectors factors, factors ’s easier control order labels well colors. want customize order, can convert column factor set levels please:","code":"se$sample_id_factor <- factor(se$sample_id, levels = c(\"mousecolon\", \"mousebrain\")) MapLabels(se, column_name = \"sample_id_factor\", ncol = 1) &   theme(legend.position = \"right\")"},{"path":"https://ludvigla.github.io/semla/articles/advanced_visualization.html","id":"colors","dir":"Articles","previous_headings":"Map categorical features","what":"Colors","title":"Advanced visualization","text":"pass named vector colors can control coloring labels:  Let’s run unsupervised clustering data get slightly interesting results work . NB: doesn’t make much sense run data-driven clustering two completely different tissue types, interested demonstrating can use MapLabels.","code":"MapLabels(se, column_name = \"sample_id_factor\", ncol = 1,           colors = c(\"mousecolon\" = \"#4477AA\", \"mousebrain\" = \"#CC6677\")) &   theme(legend.position = \"right\") se <- se |>   NormalizeData() |>   ScaleData() |>   FindVariableFeatures() |>   RunPCA() |>   FindNeighbors(reduction = \"pca\", dims = 1:10) |>   FindClusters(resolution = 0.2) ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ##  ## Number of nodes: 5164 ## Number of edges: 170850 ##  ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.9210 ## Number of communities: 5 ## Elapsed time: 0 seconds"},{"path":"https://ludvigla.github.io/semla/articles/advanced_visualization.html","id":"map-clusters","dir":"Articles","previous_headings":"Map categorical features","what":"Map clusters","title":"Advanced visualization","text":"","code":"MapLabels(se, column_name = \"seurat_clusters\", ncol = 1) &   theme(legend.position = \"right\")"},{"path":"https://ludvigla.github.io/semla/articles/advanced_visualization.html","id":"summary-subplot-1","dir":"Articles","previous_headings":"Map categorical features","what":"Summary subplot","title":"Advanced visualization","text":"Similarly MapFeaturesSummary(), also MapLabelsSummary(), adds stacked barchart displaying cluster proportion (percentage) section. Passing bar_display = \"count\" instead show actual spot count per cluster. Let’s combine MapLabelsSummary custom cluster colors.  can adjust things, like width text size, bar plot arguments bar_width bar_label_size.","code":"cluster_colors <- setNames(RColorBrewer::brewer.pal(length(levels(se$seurat_clusters)), \"Set1\"),                             nm = levels(se$seurat_clusters))  MapLabelsSummary(se,                   column_name = \"seurat_clusters\",                   ncol = 1,                   colors = cluster_colors) MapLabelsSummary(se,                   column_name = \"seurat_clusters\",                  section_number = 1,                   label_by = \"sample_id\",                  colors = cluster_colors,                  pt_size = 2,                  bar_display = \"count\",                  bar_width = 2,                   bar_label_size = 4) &   theme(plot.title = element_text(hjust=0.5, size = 14, face = \"bold\"))"},{"path":[]},{"path":"https://ludvigla.github.io/semla/articles/advanced_visualization.html","id":"point-size","dir":"Articles","previous_headings":"Map categorical features > Format legend","what":"Point size","title":"Advanced visualization","text":"want increase size spots color legend, can override fill aesthetic controls appearance points without changing size points plot. can using guides(fill = guide_legend(override.aes = list(size = ...))):","code":"MapLabels(se,            column_name = \"seurat_clusters\",            ncol = 1,           colors = cluster_colors) &   guides(fill = guide_legend(override.aes = list(size = 3))) &   theme(legend.position = \"right\")"},{"path":"https://ludvigla.github.io/semla/articles/advanced_visualization.html","id":"legend-arrangement","dir":"Articles","previous_headings":"Map categorical features > Format legend","what":"Legend arrangement","title":"Advanced visualization","text":"Another useful option adjust arrangement color legend. example, lot different categories, might easier read labels arranged multiple columns:","code":"MapLabels(se,            column_name = \"seurat_clusters\",            ncol = 1,           colors = cluster_colors) &   guides(fill = guide_legend(override.aes = list(size = 3),                               ncol = 2)) &   theme(legend.position = \"right\")"},{"path":"https://ludvigla.github.io/semla/articles/advanced_visualization.html","id":"collect-legends","dir":"Articles","previous_headings":"Map categorical features > Format legend","what":"Collect legends","title":"Advanced visualization","text":"Since sub plots share color legends, can collect place side plot:","code":"MapLabels(se,            column_name = \"seurat_clusters\",            ncol = 1,           colors = cluster_colors) +   plot_layout(guides = \"collect\") &   guides(fill = guide_legend(override.aes = list(size = 3),                               ncol = 2)) &   theme(legend.position = \"right\")"},{"path":"https://ludvigla.github.io/semla/articles/advanced_visualization.html","id":"overlay-maps-on-images-1","dir":"Articles","previous_headings":"Map categorical features","what":"Overlay maps on images","title":"Advanced visualization","text":"just MapFeatures, can add H&E images plots:","code":"MapLabels(se,            column_name = \"seurat_clusters\",            image_use = \"raw\",            override_plot_dims = TRUE,            pt_alpha = 0.6,           colors = cluster_colors) +   plot_layout(guides = \"collect\") &   guides(fill = guide_legend(override.aes = list(size = 3),                               ncol = 2)) &   theme(legend.position = \"right\")"},{"path":"https://ludvigla.github.io/semla/articles/advanced_visualization.html","id":"split-labels","dir":"Articles","previous_headings":"Map categorical features","what":"Split labels","title":"Advanced visualization","text":"Sometimes can get cluttered plot difficult see cluster located tissue, especially many clusters similar colors. case, MapLabels can split data separate panels, one label:  split data, can one section warning thrown first available section selected. want use different section, can specify one use section_number:","code":"MapLabels(se,            column_name = \"seurat_clusters\",            split_labels = TRUE,           colors = cluster_colors) +   plot_layout(guides = \"collect\") &   theme(legend.position = \"right\",          legend.title = element_blank(),          legend.margin = margin(-10,-10,-10, 0)) &   guides(fill = guide_legend(override.aes = list(size = 3))) ## Warning: No section_number selected. Selecting section 1. MapLabels(se,            column_name = \"seurat_clusters\",            split_labels = TRUE,            section_number = 2,            ncol = 1,           colors = cluster_colors) +   plot_layout(guides = \"collect\") &   theme(legend.position = \"right\")"},{"path":"https://ludvigla.github.io/semla/articles/advanced_visualization.html","id":"remove-background","dir":"Articles","previous_headings":"Map categorical features > Split labels","what":"Remove background","title":"Advanced visualization","text":"mapping categorical features split view might useful see underlying image. set drop_na = TRUE, background spots removed:   semla: 1.0.0","code":"MapLabels(se,            column_name = \"seurat_clusters\",            split_labels = TRUE,            image_use = \"raw\",            drop_na = TRUE,            override_plot_dims = TRUE,           colors = cluster_colors) +   plot_layout(guides = \"collect\") &   theme(legend.position = \"right\",          legend.title = element_blank(),          legend.margin = margin(-10, 10, -10, 10),          plot.title = element_blank(),          plot.margin = margin(0, 5, 5, 0)) &   guides(fill = guide_legend(override.aes = list(size = 3))) ## Warning: No section_number selected. Selecting section 1. sessionInfo() ## R version 4.2.1 (2022-06-23) ## Platform: x86_64-apple-darwin13.4.0 (64-bit) ## Running under: macOS Big Sur ... 10.16 ##  ## Matrix products: default ## BLAS/LAPACK: /Users/ludviglarsson/miniconda3/envs/R4.2/lib/libopenblasp-r0.3.21.dylib ##  ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ## [1] patchwork_1.1.2    tibble_3.1.8       semla_1.0.0        ggplot2_3.4.1      ## [5] dplyr_1.1.0        SeuratObject_4.1.3 Seurat_4.3.0       ##  ## loaded via a namespace (and not attached): ##   [1] Rtsne_0.16             colorspace_2.0-3       deldir_1.0-6           ##   [4] ellipsis_0.3.2         ggridges_0.5.3         rprojroot_2.0.3        ##   [7] fs_1.5.2               spatstat.data_3.0-0    rstudioapi_0.14        ##  [10] farver_2.1.1           leiden_0.4.2           listenv_0.8.0          ##  [13] ggrepel_0.9.3          fansi_1.0.3            codetools_0.2-18       ##  [16] splines_4.2.1          cachem_1.0.6           knitr_1.39             ##  [19] zeallot_0.1.0          polyclip_1.10-0        jsonlite_1.8.3         ##  [22] ica_1.0-3              cluster_2.1.4          png_0.1-7              ##  [25] uwot_0.1.14            spatstat.sparse_3.0-0  shiny_1.7.4            ##  [28] sctransform_0.3.5      compiler_4.2.1         httr_1.4.4             ##  [31] Matrix_1.5-3           fastmap_1.1.0          lazyeval_0.2.2         ##  [34] cli_3.4.1              later_1.3.0            htmltools_0.5.4        ##  [37] tools_4.2.1            igraph_1.3.4           gtable_0.3.0           ##  [40] glue_1.6.2             RANN_2.6.1             reshape2_1.4.4         ##  [43] Rcpp_1.0.9             scattermore_0.8        jquerylib_0.1.4        ##  [46] pkgdown_2.0.6          vctrs_0.5.2            nlme_3.1-159           ##  [49] spatstat.explore_3.0-5 progressr_0.10.1       lmtest_0.9-40          ##  [52] spatstat.random_3.0-1  xfun_0.32              stringr_1.5.0          ##  [55] globals_0.16.0         mime_0.12              miniUI_0.1.1.1         ##  [58] lifecycle_1.0.3        irlba_2.3.5            goftest_1.2-3          ##  [61] future_1.27.0          MASS_7.3-58.1          zoo_1.8-10             ##  [64] scales_1.2.1           ragg_1.2.2             promises_1.2.0.1       ##  [67] spatstat.utils_3.0-1   parallel_4.2.1         RColorBrewer_1.1-3     ##  [70] yaml_2.3.5             memoise_2.0.1          reticulate_1.26        ##  [73] pbapply_1.5-0          gridExtra_2.3          sass_0.4.2             ##  [76] stringi_1.7.8          highr_0.9              desc_1.4.1             ##  [79] rlang_1.0.6            pkgconfig_2.0.3        systemfonts_1.0.4      ##  [82] matrixStats_0.62.0     evaluate_0.16          lattice_0.20-45        ##  [85] tensor_1.5             ROCR_1.0-11            purrr_1.0.1            ##  [88] labeling_0.4.2         htmlwidgets_1.5.4      cowplot_1.1.1          ##  [91] tidyselect_1.2.0       parallelly_1.32.1      RcppAnnoy_0.0.19       ##  [94] plyr_1.8.7             magrittr_2.0.3         R6_2.5.1               ##  [97] magick_2.7.3           generics_0.1.3         DBI_1.1.3              ## [100] withr_2.5.0            pillar_1.8.1           fitdistrplus_1.1-8     ## [103] abind_1.4-5            survival_3.4-0         sp_1.5-1               ## [106] future.apply_1.9.0     KernSmooth_2.23-20     utf8_1.2.2             ## [109] spatstat.geom_3.0-3    plotly_4.10.0          rmarkdown_2.15         ## [112] viridis_0.6.2          grid_4.2.1             data.table_1.14.2      ## [115] forcats_0.5.2          digest_0.6.29          xtable_1.8-4           ## [118] dbscan_1.1-10          tidyr_1.3.0            httpuv_1.6.5           ## [121] textshaping_0.3.6      munsell_0.5.0          viridisLite_0.4.1      ## [124] bslib_0.4.0            shinyjs_2.1.0"},{"path":"https://ludvigla.github.io/semla/articles/categorical_features.html","id":"load-data","dir":"Articles","previous_headings":"","what":"Load data","title":"Visualization of categorical features","text":"First need load 10x Visium data. ’ll use mouse brain tissue dataset mouse colon dataset shipped semla.","code":"# Load data se_mbrain <- readRDS(file = system.file(\"extdata\",                                          \"mousebrain/se_mbrain\",                                          package = \"semla\")) se_mbrain$sample_id <- \"mousebrain\" se_mcolon <- readRDS(file = system.file(\"extdata\",                                          \"mousecolon/se_mcolon\",                                          package = \"semla\")) se_mcolon$sample_id <- \"mousecolon\" se <- MergeSTData(se_mbrain, se_mcolon)"},{"path":"https://ludvigla.github.io/semla/articles/categorical_features.html","id":"map-categorical-features","dir":"Articles","previous_headings":"","what":"Map categorical features","title":"Visualization of categorical features","text":"categorical data, use MapLabels() instead MapFeatures(). function allows us color spots based column Seurat object containing categorical data.  Let’s run unsupervised clustering data get slightly interesting results work . NB: doesn’t make much sense run data-driven clustering two completely different tissue types, interested demonstrating can use MapLabels.","code":"# Here we use the & operator from the patchwork R package to add a theme # You can find more details in the 'advanced' tutorial MapLabels(se, column_name = \"sample_id\", ncol = 1) &   theme(legend.position = \"right\") se <- se |>   NormalizeData() |>   ScaleData() |>   FindVariableFeatures() |>   RunPCA() |>   FindNeighbors(reduction = \"pca\", dims = 1:10) |>   FindClusters(resolution = 0.2) ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ##  ## Number of nodes: 5164 ## Number of edges: 170850 ##  ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.9210 ## Number of communities: 5 ## Elapsed time: 0 seconds"},{"path":"https://ludvigla.github.io/semla/articles/categorical_features.html","id":"map-clusters","dir":"Articles","previous_headings":"","what":"Map clusters","title":"Visualization of categorical features","text":"can also use function MapLabelsSummary() want add stacked bar plot next spatial plot, summarizing percentage spots cluster section. rather view actual spot count can pass bar_display = \"count\" instead.","code":"MapLabels(se, column_name = \"seurat_clusters\", ncol = 1) &   theme(legend.position = \"right\") MapLabelsSummary(se,                   column_name = \"seurat_clusters\",                   ncol = 1,                   section_number = 1) &   theme(legend.position = \"none\")"},{"path":"https://ludvigla.github.io/semla/articles/categorical_features.html","id":"overlay-maps-on-images","dir":"Articles","previous_headings":"","what":"Overlay maps on images","title":"Visualization of categorical features","text":"just MapFeatures, can add H&E images plots. , just need load H&E images Seurat object first LoadImages.","code":"se <- LoadImages(se, verbose = FALSE)  MapLabels(se,            column_name = \"seurat_clusters\",            image_use = \"raw\",            override_plot_dims = TRUE) +   plot_layout(guides = \"collect\") &   guides(fill = guide_legend(override.aes = list(size = 3),                               ncol = 2)) &   theme(legend.position = \"right\")"},{"path":"https://ludvigla.github.io/semla/articles/categorical_features.html","id":"crop-image","dir":"Articles","previous_headings":"","what":"Crop image","title":"Visualization of categorical features","text":"can crop images manually defining crop_area. crop_area vector length four defining corners rectangle, x- y-axes defined 0-1. order decide rectangle defined, can get help adding grid plot:  Now want crop GALT tissue mouse colon sample can cut image left=0.45, bottom=0.55, right=0.65, top=0.7:  can patch together nice figure showing whole tissue zoom GALT:   semla: 1.0.0","code":"p <- MapLabels(se,                 column_name = \"seurat_clusters\",                 image_use = \"raw\",                 pt_alpha = 0.5) &   theme(panel.grid.major = element_line(linetype = \"dashed\"), axis.text = element_text()) p p <- MapLabels(se,                 column_name = \"selection\",                 image_use = \"raw\",                 pt_size = 5,                 section_number = 2,                 crop_area = c(0.45, 0.55, 0.65, 0.7)) p # override_plot_dims=TRUE can be used to crop the image to only # include the region that contain spots (see 'advanced' tutorial) p_global <- MapLabels(se,                        column_name = \"selection\",                        image_use = \"raw\",                       pt_size = 1,                        section_number = 2,                        override_plot_dims = TRUE) &   guides(fill = guide_legend(override.aes = list(size = 3)))  p_GALT <- MapLabels(se,                      column_name = \"selection\",                      image_use = \"raw\",                       pt_size = 5,                      section_number = 2,                      crop_area = c(0.45, 0.55, 0.65, 0.7)) &   theme(plot.title = element_blank(),          plot.subtitle = element_blank(),          legend.position = \"none\")  (p_global / p_GALT) sessionInfo() ## R version 4.2.1 (2022-06-23) ## Platform: x86_64-apple-darwin13.4.0 (64-bit) ## Running under: macOS Big Sur ... 10.16 ##  ## Matrix products: default ## BLAS/LAPACK: /Users/ludviglarsson/miniconda3/envs/R4.2/lib/libopenblasp-r0.3.21.dylib ##  ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ## [1] patchwork_1.1.2    tibble_3.1.8       semla_1.0.0        ggplot2_3.4.1      ## [5] dplyr_1.1.0        SeuratObject_4.1.3 Seurat_4.3.0       ##  ## loaded via a namespace (and not attached): ##   [1] Rtsne_0.16             colorspace_2.0-3       deldir_1.0-6           ##   [4] ellipsis_0.3.2         ggridges_0.5.3         rprojroot_2.0.3        ##   [7] fs_1.5.2               spatstat.data_3.0-0    rstudioapi_0.14        ##  [10] farver_2.1.1           leiden_0.4.2           listenv_0.8.0          ##  [13] ggrepel_0.9.3          fansi_1.0.3            codetools_0.2-18       ##  [16] splines_4.2.1          cachem_1.0.6           knitr_1.39             ##  [19] zeallot_0.1.0          polyclip_1.10-0        jsonlite_1.8.3         ##  [22] ica_1.0-3              cluster_2.1.4          png_0.1-7              ##  [25] uwot_0.1.14            spatstat.sparse_3.0-0  shiny_1.7.4            ##  [28] sctransform_0.3.5      compiler_4.2.1         httr_1.4.4             ##  [31] Matrix_1.5-3           fastmap_1.1.0          lazyeval_0.2.2         ##  [34] cli_3.4.1              later_1.3.0            htmltools_0.5.4        ##  [37] tools_4.2.1            igraph_1.3.4           gtable_0.3.0           ##  [40] glue_1.6.2             RANN_2.6.1             reshape2_1.4.4         ##  [43] Rcpp_1.0.9             scattermore_0.8        jquerylib_0.1.4        ##  [46] pkgdown_2.0.6          vctrs_0.5.2            nlme_3.1-159           ##  [49] spatstat.explore_3.0-5 progressr_0.10.1       lmtest_0.9-40          ##  [52] spatstat.random_3.0-1  xfun_0.32              stringr_1.5.0          ##  [55] globals_0.16.0         mime_0.12              miniUI_0.1.1.1         ##  [58] lifecycle_1.0.3        irlba_2.3.5            goftest_1.2-3          ##  [61] future_1.27.0          MASS_7.3-58.1          zoo_1.8-10             ##  [64] scales_1.2.1           ragg_1.2.2             promises_1.2.0.1       ##  [67] spatstat.utils_3.0-1   parallel_4.2.1         RColorBrewer_1.1-3     ##  [70] yaml_2.3.5             memoise_2.0.1          reticulate_1.26        ##  [73] pbapply_1.5-0          gridExtra_2.3          sass_0.4.2             ##  [76] stringi_1.7.8          highr_0.9              desc_1.4.1             ##  [79] rlang_1.0.6            pkgconfig_2.0.3        systemfonts_1.0.4      ##  [82] matrixStats_0.62.0     evaluate_0.16          lattice_0.20-45        ##  [85] tensor_1.5             ROCR_1.0-11            purrr_1.0.1            ##  [88] labeling_0.4.2         htmlwidgets_1.5.4      cowplot_1.1.1          ##  [91] tidyselect_1.2.0       parallelly_1.32.1      RcppAnnoy_0.0.19       ##  [94] plyr_1.8.7             magrittr_2.0.3         R6_2.5.1               ##  [97] magick_2.7.3           generics_0.1.3         DBI_1.1.3              ## [100] withr_2.5.0            pillar_1.8.1           fitdistrplus_1.1-8     ## [103] abind_1.4-5            survival_3.4-0         sp_1.5-1               ## [106] future.apply_1.9.0     KernSmooth_2.23-20     utf8_1.2.2             ## [109] spatstat.geom_3.0-3    plotly_4.10.0          rmarkdown_2.15         ## [112] grid_4.2.1             data.table_1.14.2      forcats_0.5.2          ## [115] digest_0.6.29          xtable_1.8-4           dbscan_1.1-10          ## [118] tidyr_1.3.0            httpuv_1.6.5           textshaping_0.3.6      ## [121] munsell_0.5.0          viridisLite_0.4.1      bslib_0.4.0            ## [124] shinyjs_2.1.0"},{"path":"https://ludvigla.github.io/semla/articles/cell_type_mapping_with_NNLS.html","id":"mbrain","dir":"Articles","previous_headings":"","what":"Mouse brain","title":"Cell type mapping with NNLS","text":"tutorial, use single-cell data set Allen Brain Atlas. can check code chunk follow link download manually. also need download 10x Visium data 10x Genomics website. can download files directly R following code chunk download data directly . Load Visium data semla Seurat object. following steps assumes mouse brain 10x Visium data located ./mousebrain/visium/. Load single-cell data","code":"options(timeout=200) tmpdir <- \".\" # Set current wd or change to tmpdir() dir.create(paste0(tmpdir, \"/mousebrain\")) targetdir <- paste0(tmpdir, \"/mousebrain\") dir.create(paste0(targetdir, \"/single-cell\")) destfile <- paste0(targetdir, \"/single-cell/allen_brain.rds\") download.file(\"https://www.dropbox.com/s/cuowvm4vrf65pvq/allen_cortex.rds?dl=1\", destfile = destfile) dir.create(paste0(targetdir, \"/visium\"))  # Download section 1 dir.create(paste0(targetdir, \"/visium/S1\")) download.file(url = \"https://cf.10xgenomics.com/samples/spatial-exp/1.0.0/V1_Mouse_Brain_Sagittal_Anterior/V1_Mouse_Brain_Sagittal_Anterior_filtered_feature_bc_matrix.h5\",                destfile = paste0(targetdir, \"/visium/S1/filtered_feature_bc_matrix.h5\")) download.file(url = \"https://cf.10xgenomics.com/samples/spatial-exp/1.0.0/V1_Mouse_Brain_Sagittal_Anterior/V1_Mouse_Brain_Sagittal_Anterior_spatial.tar.gz\",               destfile = paste0(targetdir, \"/visium/S1/spatial.tar.gz\")) untar(tarfile = paste0(targetdir, \"/visium/S1/spatial.tar.gz\"),        exdir =  paste0(targetdir, \"/visium/S1/\")) file.remove(paste0(targetdir, \"/visium/S1/spatial.tar.gz\"))  # Download section 2 dir.create(paste0(targetdir, \"/visium/S2\")) download.file(url = \"https://cf.10xgenomics.com/samples/spatial-exp/1.0.0/V1_Mouse_Brain_Sagittal_Posterior/V1_Mouse_Brain_Sagittal_Posterior_filtered_feature_bc_matrix.h5\",                destfile = paste0(targetdir, \"/visium/S2/filtered_feature_bc_matrix.h5\")) download.file(url = \"https://cf.10xgenomics.com/samples/spatial-exp/1.0.0/V1_Mouse_Brain_Sagittal_Posterior/V1_Mouse_Brain_Sagittal_Posterior_spatial.tar.gz\",               destfile = paste0(targetdir, \"/visium/S2/spatial.tar.gz\")) untar(tarfile = paste0(targetdir, \"/visium/S2/spatial.tar.gz\"),        exdir =  paste0(targetdir, \"/visium/S2/\")) file.remove(paste0(targetdir, \"/visium/S2/spatial.tar.gz\")) # Assemble spaceranger output files samples <- Sys.glob(\"./mousebrain/visium/*/filtered_feature_bc_matrix.h5\") imgs <- Sys.glob(\"./mousebrain/visium/*/spatial/tissue_hires_image.png\") spotfiles <- Sys.glob(\"./mousebrain/visium/*/spatial/tissue_positions_list.csv\") json <- Sys.glob(\"./mousebrain/visium/*/spatial/scalefactors_json.json\")  infoTable <- tibble(samples, imgs, spotfiles, json,                      section_id = paste0(\"section_\", 1:2))  # Create Seurat object with 1 Sagittal Anterior section and 1 Sagittal Posterior section se_brain_spatial <- ReadVisiumData(infoTable) se_allen <- readRDS(\"./mousebrain/single-cell/allen_brain.rds\")"},{"path":"https://ludvigla.github.io/semla/articles/cell_type_mapping_with_NNLS.html","id":"normalize-data","dir":"Articles","previous_headings":"Mouse brain","what":"Normalize data","title":"Cell type mapping with NNLS","text":"apply log-normalization procedure 10x Visium data (se_brain_spatial) single-cell data (se_brain_singlecell). set number variable features quite high later use intersect variable features single-cell data variable features 10x Visium data NNLS. NNLS method quite fast actually need select subset features. Instead, can just use genes shared across single-cell 10x Visium data. can visualize available cell types UMAP embedding cells. access 23 annotated cell types, including L2-L6 layer neurons distinct spatial distribution tissue.","code":"# Normalize data and find variable features for Visium data se_brain_spatial <- se_brain_spatial |>   NormalizeData() |>   FindVariableFeatures(nfeatures = 10000)  # Normalize data and run vanilla analysis to create UMAP embedding se_allen <- se_allen |>   NormalizeData() |>   FindVariableFeatures() |>    ScaleData() |>    RunPCA() |>    RunUMAP(reduction = \"pca\", dims = 1:30)  # Rerun FindVariableFeatures to increase the number before cell type deconvolution se_allen <- se_allen |>    FindVariableFeatures(nfeatures = 10000) DimPlot(se_allen, group.by = \"subclass\")"},{"path":"https://ludvigla.github.io/semla/articles/cell_type_mapping_with_NNLS.html","id":"run-nnls","dir":"Articles","previous_headings":"Mouse brain","what":"Run NNLS","title":"Cell type mapping with NNLS","text":"RunNNLS() method requires normalized Seurat object 10x Visium data normalized Seurat object single-cell data. groups argument defines cell type labels taken single-cell Seurat object. single-cell Seurat object, labels stored “subclass” column. NB: CR cell type discarded number cell lower 10. 10 lower limit allowed number cells per cell type can overridden minCells_per_celltype. plots show spatial distributions proportions selected set cell types.","code":"DefaultAssay(se_brain_spatial) <- \"Spatial\"  ti <- Sys.time() se_brain_spatial <- RunNNLS(object = se_brain_spatial,                              singlecell_object = se_allen,                              groups = \"subclass\") ## ## ── Predicting cell type proportions ── ## ## ℹ Fetching data from Seurat objects ## →   Filtering out features that are only present in one data set ## →   Kept 3378 features for deconvolution ## Loading required namespace: RcppML ## ℹ Preparing data for NNLS ## →   Downsampling scRNA-seq data to include a maximum of 50 cells per cell type ## →   Cell type(s) CR have too few cells (<10) and will be excluded ## →   Kept 22 cell types after filtering ## →   Calculating cell type expression profiles ## ℹ Predicting cell type proportions with NNLS for 22 cell types ## ℹ Returning results in a new 'Assay' named 'celltypeprops' ## ℹ Setting default assay to 'celltypeprops' ## ✔ Finished sprintf(\"RunNNLS completed in %s seconds\", round(Sys.time() - ti, digits = 2)) ## [1] \"RunNNLS completed in 3.23 seconds\" # Check available cell types rownames(se_brain_spatial) ##  [1] \"Astro\"      \"Endo\"       \"L2/3 IT\"    \"L4\"         \"L5 IT\"      ##  [6] \"L5 PT\"      \"L6 CT\"      \"L6 IT\"      \"L6b\"        \"Lamp5\"      ## [11] \"Macrophage\" \"Meis2\"      \"NP\"         \"Oligo\"      \"Peri\"       ## [16] \"Pvalb\"      \"SMC\"        \"Serpinf1\"   \"Sncg\"       \"Sst\"        ## [21] \"VLMC\"       \"Vip\" # Plot selected cell types DefaultAssay(se_brain_spatial) <- \"celltypeprops\"  selected_celltypes <- c(\"L2/3 IT\", \"L4\", \"L5 IT\",                         \"L5 PT\", \"L6 CT\", \"L6 IT\", \"L6b\",                         \"Oligo\", \"Pvalb\", \"Meis2\", \"Astro\",                        \"VLMC\", \"SMC\") se_brain_spatial <- LoadImages(se_brain_spatial, image_height = 1e3) ## ## ── Loading H&E images ── ## ## ℹ Loading image from ./mousebrain/visium/S1/spatial/tissue_hires_image.png ## ℹ Scaled image from 1998x2000 to 1000x1001 pixels ## ℹ Loading image from ./mousebrain/visium/S2/spatial/tissue_hires_image.png ## ℹ Scaled image from 1998x2000 to 1000x1001 pixels ## ℹ Saving loaded H&E images as 'rasters' in Seurat object plots <- lapply(seq_along(selected_celltypes), function(i) {   MapFeatures(se_brain_spatial, pt_size = 1.3,             features = selected_celltypes[i], image_use = \"raw\",             arrange_features = \"row\", scale = \"shared\",              override_plot_dims = TRUE,             colors = RColorBrewer::brewer.pal(n = 9, name = \"Spectral\") |> rev(),              scale_alpha = TRUE)  +   plot_layout(guides = \"collect\") &    theme(legend.position = \"right\", legend.margin = margin(b = 50),         legend.text = element_text(angle = 0),         plot.title = element_blank()) }) |> setNames(nm = selected_celltypes)"},{"path":"https://ludvigla.github.io/semla/articles/cell_type_mapping_with_NNLS.html","id":"mapped-mouse-brain-cell-types","dir":"Articles","previous_headings":"Mouse brain","what":"Mapped mouse brain cell types","title":"Cell type mapping with NNLS","text":"L2/3 L4 L5 L5 PT L6 CT L6 L6b Oligo Pvalb Meis2 Astro VLMC SMC","code":""},{"path":"https://ludvigla.github.io/semla/articles/cell_type_mapping_with_NNLS.html","id":"visualize-multiple-cell-types","dir":"Articles","previous_headings":"Mouse brain","what":"Visualize multiple cell types","title":"Cell type mapping with NNLS","text":"can also visualize cell types one single plot MapMultipleFeatures().","code":"# Load H&E images se_brain_spatial <- se_brain_spatial |>    LoadImages()  # Plot multiple features MapMultipleFeatures(se_brain_spatial,                      image_use = \"raw\",                      pt_size = 2, max_cutoff = 0.99,                     override_plot_dims = TRUE,                      colors = c(\"#332288\", \"#88CCEE\", \"#44AA99\", \"#117733\", \"#DDCC77\", \"#CC6677\",\"#AA4499\"),                     features = selected_celltypes[1:7]) +   plot_layout(guides = \"collect\")"},{"path":"https://ludvigla.github.io/semla/articles/cell_type_mapping_with_NNLS.html","id":"cell-type-co-localization","dir":"Articles","previous_headings":"Mouse brain","what":"Cell type co-localization","title":"Cell type mapping with NNLS","text":"computing pair-wise correlation cell types across spots, can get idea cell types often appear together spots.   can also use predicted cell type proportions compute factors using NMF, thereby summarizing cell types presence within location set predefined factors. factor can viewed niche certain cell type composition.","code":"cor_matrix <- FetchData(se_brain_spatial, selected_celltypes) |>    mutate_all(~ if_else(.x<0.1, 0, .x)) |>  # Filter lowest values (-> set as 0)   cor()  diag(cor_matrix) <- NA max_val <- max(cor_matrix, na.rm = T) cols <- RColorBrewer::brewer.pal(7, \"RdYlBu\") |> rev(); cols[4] <- \"white\" pheatmap::pheatmap(cor_matrix,                     breaks = seq(-max_val, max_val, length.out = 100),                    color=colorRampPalette(cols)(100),                    cellwidth = 14, cellheight = 14,                     treeheight_col = 10, treeheight_row = 10,                     main = \"Cell type correlation\\nwithin spots\") nmf_data <- FetchData(se_brain_spatial, selected_celltypes) |>    RcppML::nmf(k = 10, verbose = F)  nmf_data_h <- nmf_data$h |> as.data.frame() rownames(nmf_data_h) <- paste0(\"Factor_\", 1:10) colnames(nmf_data_h) <- selected_celltypes  nmf_data_h <- nmf_data_h |>    mutate_at(colnames(nmf_data_h),              ~(scale(., center = FALSE, scale = max(., na.rm = TRUE)/1)))  nmf_data_h$Factor <- rownames(nmf_data_h) |>    factor(levels = paste0(\"Factor_\", 1:10)) nmf_data_h_df <- nmf_data_h |>    tidyr::pivot_longer(cols = all_of(selected_celltypes),                        names_to = \"Cell\",                        values_to = \"Weight\")  ggplot(nmf_data_h_df, aes(x=Factor, y=Cell, size=Weight, color=Weight)) +   geom_point() +   labs(title=\"Cell type contribution\", x=\"Factor\", y = \"Cell type\",         color = \"\", size = \"Scaled weight\") +   scale_color_viridis_c(direction = -1, option = \"magma\") +   theme_bw() +   theme(axis.text.x = element_text(angle=45, hjust=1),          panel.grid = element_blank())"},{"path":"https://ludvigla.github.io/semla/articles/cell_type_mapping_with_NNLS.html","id":"mkidney","dir":"Articles","previous_headings":"","what":"Mouse kidney","title":"Cell type mapping with NNLS","text":"second example, ’ll look data mouse kidney. can obtain single-cell data TabulaMurisSenisData R package bioconductor. Let’s load data create Seurat object . 10x Visium mouse kidney data can downloaded 10x genomics website.","code":"sce <- TabulaMurisSenisDroplet(tissues = \"Kidney\")$Kidney umis <- as(counts(sce), \"dgCMatrix\") se_kidney_singlecell <- CreateSeuratObject(counts = umis, meta.data = colData(sce) |> as.data.frame()) dir.create(paste0(tmpdir, \"/kidney\")) targetdir <- paste0(tmpdir, \"/kidney\") dir.create(paste0(targetdir, \"/visium\"))  # Download section 1 download.file(url = \"https://cf.10xgenomics.com/samples/spatial-exp/1.1.0/V1_Mouse_Kidney/V1_Mouse_Kidney_filtered_feature_bc_matrix.h5\",                destfile = paste0(targetdir, \"/visium/filtered_feature_bc_matrix.h5\")) download.file(url = \"https://cf.10xgenomics.com/samples/spatial-exp/1.1.0/V1_Mouse_Kidney/V1_Mouse_Kidney_spatial.tar.gz\",               destfile = paste0(targetdir, \"/visium/spatial.tar.gz\")) untar(tarfile = paste0(targetdir, \"/visium/spatial.tar.gz\"),        exdir =  paste0(targetdir, \"/visium/\")) file.remove(paste0(targetdir, \"/visium/spatial.tar.gz\"))  samples <- \"./kidney/visium/filtered_feature_bc_matrix.h5\" imgs <- \"./kidney/visium/spatial/tissue_hires_image.png\" spotfiles <- \"./kidney/visium/spatial/tissue_positions_list.csv\" json <- \"./kidney/visium/spatial/scalefactors_json.json\"  infoTable <- tibble::tibble(samples, imgs, spotfiles, json)  se_kidney_spatial <- ReadVisiumData(infoTable)"},{"path":"https://ludvigla.github.io/semla/articles/cell_type_mapping_with_NNLS.html","id":"normalize-data-1","dir":"Articles","previous_headings":"Mouse kidney","what":"Normalize data","title":"Cell type mapping with NNLS","text":"apply normalization procedure se_kidney_spatial se_kidney_singlecell run FindVariableFeatures() detect top variable genes. single-cell kidney data, ’ll also filter data prior normalization include cells collected age 18m remove cells labels “nan” “CD45”. leaves us 17 cell types.","code":"se_kidney_spatial <- se_kidney_spatial |>   NormalizeData() |>   FindVariableFeatures(nfeatures = 10000) keep_cells <- colnames(se_kidney_singlecell)[se_kidney_singlecell$age == \"18m\" & (!se_kidney_singlecell$free_annotation %in% c(\"nan\", \"CD45\"))] se_kidney_singlecell <- subset(se_kidney_singlecell, cells = keep_cells) se_kidney_singlecell <- se_kidney_singlecell |>   NormalizeData() |>   FindVariableFeatures() |>    ScaleData() |>    RunPCA() |>    RunUMAP(reduction = \"pca\", dims = 1:30)  se_kidney_singlecell <- se_kidney_singlecell |>    FindVariableFeatures(nfeatures = 10000)"},{"path":"https://ludvigla.github.io/semla/articles/cell_type_mapping_with_NNLS.html","id":"run-nnls-1","dir":"Articles","previous_headings":"Mouse kidney","what":"Run NNLS","title":"Cell type mapping with NNLS","text":", RunNNLS() method requires single-cell Seurat object 10x Visium Seurat object. cell type annotations stored “free_annotation” column. NB: two cell types discarded didn’t pass minimum allowed cells per cell type threshold. cell types discarded NK cells plasma cells.","code":"ti <- Sys.time() DefaultAssay(se_kidney_spatial) <- \"Spatial\" se_kidney_spatial <- RunNNLS(object = se_kidney_spatial,                        singlecell_object = se_kidney_singlecell,                        groups = \"free_annotation\") ## ## ── Predicting cell type proportions ── ## ## ℹ Fetching data from Seurat objects ## →   Filtering out features that are only present in one data set ## →   Kept 4993 features for deconvolution ## ℹ Preparing data for NNLS ## →   Downsampling scRNA-seq data to include a maximum of 50 cells per cell type ## →   Cell type(s) CD45    NK cell,CD45    plasma cell have too few cells (<10) and will be excluded ## →   Kept 15 cell types after filtering ## →   Calculating cell type expression profiles ## ℹ Predicting cell type proportions with NNLS for 15 cell types ## ℹ Returning results in a new 'Assay' named 'celltypeprops' ## ℹ Setting default assay to 'celltypeprops' ## ✔ Finished sprintf(\"RunNNLS finished in %s seconds\", round(Sys.time() - ti, digits = 2)) ## [1] \"RunNNLS finished in 0.58 seconds\" # Check available cell types rownames(se_kidney_spatial) ##  [1] \"CD45    B cell\"                                             ##  [2] \"CD45    T cell\"                                             ##  [3] \"CD45    macrophage\"                                         ##  [4] \"Epcam     kidney distal convoluted tubule epithelial cell\"  ##  [5] \"Epcam    brush cell\"                                        ##  [6] \"Epcam    kidney collecting duct principal cell\"             ##  [7] \"Epcam    kidney proximal convoluted tubule epithelial cell\" ##  [8] \"Epcam    podocyte\"                                          ##  [9] \"Epcam    proximal tube epithelial cell\"                     ## [10] \"Epcam    thick ascending tube S epithelial cell\"            ## [11] \"Pecam    Kidney cortex artery cell\"                         ## [12] \"Pecam    fenestrated capillary endothelial\"                 ## [13] \"Pecam    kidney capillary endothelial cell\"                 ## [14] \"Stroma    fibroblast\"                                       ## [15] \"Stroma    kidney mesangial cell\" # Plot selected cell types DefaultAssay(se_kidney_spatial) <- \"celltypeprops\"  selected_celltypes <- c(\"Epcam     kidney distal convoluted tubule epithelial cell\",                         \"Epcam    brush cell\",                         \"Epcam    kidney collecting duct principal cell\",                         \"Epcam    kidney proximal convoluted tubule epithelial cell\",                         \"Epcam    podocyte\",                         \"Epcam    proximal tube epithelial cell\",                         \"Epcam    thick ascending tube S epithelial cell\",                         \"Pecam    fenestrated capillary endothelial\",                         \"Pecam    kidney capillary endothelial cell\",                         \"Stroma    kidney mesangial cell\") plots <- lapply(seq_along(selected_celltypes), function(i) {   MapFeatures(se_kidney_spatial, pt_size = 1.3,             features = selected_celltypes[i],              override_plot_dims = TRUE) &    theme(plot.title = element_blank()) }) |> setNames(nm = selected_celltypes)"},{"path":"https://ludvigla.github.io/semla/articles/cell_type_mapping_with_NNLS.html","id":"mapped-kidney-cell-types","dir":"Articles","previous_headings":"Mouse kidney","what":"Mapped kidney cell types","title":"Cell type mapping with NNLS","text":"Epcam kidney distal convoluted tubule epithelial cell Epcam brush cell Epcam kidney collecting duct principal cell Epcam kidney proximal convoluted tubule epithelial cell Epcam podocyte Epcam proximal tube epithelial cell Epcam thick ascending tube S epithelial cell Pecam fenestrated capillary endothelial Pecam kidney capillary endothelial cell Stroma kidney mesangial cell","code":""},{"path":"https://ludvigla.github.io/semla/articles/cell_type_mapping_with_NNLS.html","id":"visualize-multiple-cell-types-1","dir":"Articles","previous_headings":"Mouse kidney","what":"Visualize multiple cell types","title":"Cell type mapping with NNLS","text":"can select cell types visualize one plot  zoom region interest   semla: 1.0.0 RcppML: 0.3.7","code":"# Load H&E images se_kidney_spatial <- se_kidney_spatial |>    LoadImages()  # Plot multiple features MapMultipleFeatures(se_kidney_spatial,                      image_use = \"raw\",                      pt_size = 2, max_cutoff = 0.95,                     override_plot_dims = TRUE,                      colors = c(\"#332288\", \"#88CCEE\", \"#117733\", \"#DDCC77\", \"#CC6677\",\"#AA4499\"),                     features = selected_celltypes[c(1, 2, 3, 4, 6, 7)]) +   plot_layout(guides = \"collect\") # Reload H&E image in higher resolution se_kidney_spatial <- LoadImages(se_kidney_spatial, image_height = 1500)  # Plot H&E image rst <- GetImages(se_kidney_spatial)[[1]] p1 <- ggplot()  +   ggtitle(\"H&E image of zoomed in area\") +    theme(plot.title = element_text(hjust = 0.2)) +   inset_element(p = rst[(0.5*nrow(rst)):(0.7*nrow(rst)), (0.5*ncol(rst)):(0.7*ncol(rst))],                  left = 0, bottom = 0, right = 1, top = 1)  # Plot multiple features with zoom p2 <- MapMultipleFeatures(se_kidney_spatial,                      image_use = \"raw\",                      pt_size = 4.5, max_cutoff = 0.95,                     crop_area = c(0.5, 0.5, 0.7, 0.7),                     colors = c(\"#332288\", \"#88CCEE\", \"#117733\", \"#DDCC77\", \"#CC6677\",\"#AA4499\"),                     features = selected_celltypes[c(1, 2, 3, 4, 6, 7)]) +   plot_layout(guides = \"collect\") &   theme(plot.title = element_blank())  p1 / p2 sessionInfo() ## R version 4.2.1 (2022-06-23) ## Platform: x86_64-apple-darwin13.4.0 (64-bit) ## Running under: macOS Big Sur ... 10.16 ##  ## Matrix products: default ## BLAS/LAPACK: /Users/ludviglarsson/miniconda3/envs/R4.2/lib/libopenblasp-r0.3.21.dylib ##  ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ##  ## attached base packages: ## [1] stats4    stats     graphics  grDevices utils     datasets  methods   ## [8] base      ##  ## other attached packages: ##  [1] patchwork_1.1.2             purrr_1.0.1                 ##  [3] SingleCellExperiment_1.18.0 SummarizedExperiment_1.26.1 ##  [5] Biobase_2.56.0              GenomicRanges_1.48.0        ##  [7] GenomeInfoDb_1.32.4         IRanges_2.30.1              ##  [9] S4Vectors_0.34.0            BiocGenerics_0.42.0         ## [11] MatrixGenerics_1.8.1        matrixStats_0.62.0          ## [13] TabulaMurisSenisData_1.2.0  tibble_3.1.8                ## [15] semla_1.0.0                 ggplot2_3.4.1               ## [17] dplyr_1.1.0                 SeuratObject_4.1.3          ## [19] Seurat_4.3.0                ##  ## loaded via a namespace (and not attached): ##   [1] utf8_1.2.2                    spatstat.explore_3.0-5        ##   [3] reticulate_1.26               tidyselect_1.2.0              ##   [5] RSQLite_2.2.17                AnnotationDbi_1.58.0          ##   [7] htmlwidgets_1.5.4             grid_4.2.1                    ##   [9] Rtsne_0.16                    munsell_0.5.0                 ##  [11] codetools_0.2-18              ragg_1.2.2                    ##  [13] ica_1.0-3                     future_1.27.0                 ##  [15] miniUI_0.1.1.1                withr_2.5.0                   ##  [17] spatstat.random_3.0-1         colorspace_2.0-3              ##  [19] progressr_0.10.1              filelock_1.0.2                ##  [21] highr_0.9                     knitr_1.39                    ##  [23] rstudioapi_0.14               ROCR_1.0-11                   ##  [25] tensor_1.5                    listenv_0.8.0                 ##  [27] labeling_0.4.2                GenomeInfoDbData_1.2.8        ##  [29] RcppML_0.3.7                  polyclip_1.10-0               ##  [31] pheatmap_1.0.12               farver_2.1.1                  ##  [33] bit64_4.0.5                   rhdf5_2.40.0                  ##  [35] rprojroot_2.0.3               parallelly_1.32.1             ##  [37] vctrs_0.5.2                   generics_0.1.3                ##  [39] xfun_0.32                     BiocFileCache_2.4.0           ##  [41] R6_2.5.1                      DelayedArray_0.22.0           ##  [43] bitops_1.0-7                  rhdf5filters_1.8.0            ##  [45] spatstat.utils_3.0-1          cachem_1.0.6                  ##  [47] assertthat_0.2.1              promises_1.2.0.1              ##  [49] scales_1.2.1                  gtable_0.3.0                  ##  [51] globals_0.16.0                goftest_1.2-3                 ##  [53] rlang_1.0.6                   zeallot_0.1.0                 ##  [55] systemfonts_1.0.4             splines_4.2.1                 ##  [57] lazyeval_0.2.2                spatstat.geom_3.0-3           ##  [59] BiocManager_1.30.18           yaml_2.3.5                    ##  [61] reshape2_1.4.4                abind_1.4-5                   ##  [63] httpuv_1.6.5                  tools_4.2.1                   ##  [65] ellipsis_0.3.2                jquerylib_0.1.4               ##  [67] RColorBrewer_1.1-3            ggridges_0.5.3                ##  [69] Rcpp_1.0.9                    plyr_1.8.7                    ##  [71] zlibbioc_1.42.0               RCurl_1.98-1.8                ##  [73] dbscan_1.1-10                 deldir_1.0-6                  ##  [75] pbapply_1.5-0                 cowplot_1.1.1                 ##  [77] zoo_1.8-10                    ggrepel_0.9.3                 ##  [79] cluster_2.1.4                 fs_1.5.2                      ##  [81] magrittr_2.0.3                data.table_1.14.2             ##  [83] magick_2.7.3                  scattermore_0.8               ##  [85] lmtest_0.9-40                 RANN_2.6.1                    ##  [87] ggnewscale_0.4.8              fitdistrplus_1.1-8            ##  [89] shinyjs_2.1.0                 mime_0.12                     ##  [91] evaluate_0.16                 xtable_1.8-4                  ##  [93] gridExtra_2.3                 compiler_4.2.1                ##  [95] KernSmooth_2.23-20            crayon_1.5.1                  ##  [97] htmltools_0.5.4               later_1.3.0                   ##  [99] tidyr_1.3.0                   DBI_1.1.3                     ## [101] ExperimentHub_2.4.0           dbplyr_2.2.1                  ## [103] MASS_7.3-58.1                 rappdirs_0.3.3                ## [105] Matrix_1.5-3                  cli_3.4.1                     ## [107] gdata_2.18.0.1                parallel_4.2.1                ## [109] igraph_1.3.4                  forcats_0.5.2                 ## [111] pkgconfig_2.0.3               pkgdown_2.0.6                 ## [113] sp_1.5-1                      plotly_4.10.0                 ## [115] spatstat.sparse_3.0-0         bslib_0.4.0                   ## [117] XVector_0.36.0                stringr_1.5.0                 ## [119] digest_0.6.29                 sctransform_0.3.5             ## [121] RcppAnnoy_0.0.19              spatstat.data_3.0-0           ## [123] Biostrings_2.64.1             rmarkdown_2.15                ## [125] leiden_0.4.2                  uwot_0.1.14                   ## [127] curl_4.3.2                    gtools_3.9.3                  ## [129] shiny_1.7.4                   lifecycle_1.0.3               ## [131] nlme_3.1-159                  jsonlite_1.8.3                ## [133] Rhdf5lib_1.18.2               desc_1.4.1                    ## [135] viridisLite_0.4.1             fansi_1.0.3                   ## [137] pillar_1.8.1                  lattice_0.20-45               ## [139] KEGGREST_1.36.3               fastmap_1.1.0                 ## [141] httr_1.4.4                    survival_3.4-0                ## [143] interactiveDisplayBase_1.34.0 glue_1.6.2                    ## [145] png_0.1-7                     BiocVersion_3.15.2            ## [147] bit_4.0.4                     stringi_1.7.8                 ## [149] sass_0.4.2                    HDF5Array_1.24.2              ## [151] blob_1.2.3                    textshaping_0.3.6             ## [153] AnnotationHub_3.4.0           memoise_2.0.1                 ## [155] irlba_2.3.5                   future.apply_1.9.0"},{"path":"https://ludvigla.github.io/semla/articles/digital_unrolling.html","id":"mouse-colon-data","dir":"Articles","previous_headings":"","what":"Mouse colon data","title":"Digital unrolling","text":"Let’s load quick look data.  H&E image, can clearly see organization large part lower intestine. outermost part roll ascending colon center roll rectum. can identify genes regionalized pattern pretty easily great somehow unroll tissue can investigate gene expression patterns along proximal-distance axis. spatial map expression Fxyd4 -regulated closer distal part colon.","code":"se_mcolon <- readRDS(system.file(\"extdata/mousecolon\",                                   \"se_mcolon\",                                   package = \"semla\"))  se_mcolon <- se_mcolon |>    LoadImages() ## ## ── Loading H&E images ── ## ## ℹ Loading image from /private/var/folders/zb/1fj07x_5343fvs_k28gnm1z80002xs/T/RtmpFJGwBj/temp_libpath502354c29e9d/semla/extdata/mousecolon/spatial/tissue_hires_image.jpg ## ℹ Scaled image from 1804x2000 to 400x443 pixels ## ℹ Saving loaded H&E images as 'rasters' in Seurat object ImagePlot(se_mcolon) MapFeatures(se_mcolon, features = \"Fxyd4\",              image_use = \"raw\", override_plot_dims = TRUE,             colors = c(\"darkblue\", \"cyan\", \"yellow\", \"red\", \"darkred\"))"},{"path":"https://ludvigla.github.io/semla/articles/digital_unrolling.html","id":"pre-processing","dir":"Articles","previous_headings":"","what":"Pre-processing","title":"Digital unrolling","text":"goal tutorial show semla can used find “unrolled” coordinate system. achieve , can start shiny application CutSpatialNetwork() allow us interesting stuff. later. get started, need little bit pre-processing. First, tile H&E image using TileImage(). Tiling necessary make possible visualize H&E images interactive way. path raw H&E image can found GetStaffli(se_mcolon)@imgs. NB: image file moved, TileImage path might longer valid. Make sure path valid proceeding. get decent resolution, use “tissue_hires_image.png” output spaceranger. Now can load image magick, tile image export local directory. function returns path directory tiles exported . save variable called tilepath CutSpatialNetwork() function requires another file work properly. file holds information “spatial network” (see GetSpatialNetwork() details) used shiny application define spots Visium data connected . demonstrate means, can generate spatial network visualize .  plot , can see edges connects neighboring spots . Now let’s export spatial network make available shiny application.","code":"im <- GetStaffli(se_mcolon)@imgs[1] sprintf(\"File exists: %s\", file.exists(im)) ## [1] \"File exists: TRUE\" library(magick) im <- image_read(im) tilepath <- TileImage(im = im, outpath = \"~/Downloads/\") spatnet <- GetSpatialNetwork(se_mcolon)[[1]]  library(ggplot2)  ggplot() +   geom_segment(data = spatnet, aes(x = x_start, xend = x_end, y = y_start, yend = y_end)) +   scale_y_reverse() +   coord_fixed() export_graph(se_mcolon, sampleID = 1, outdir = tilepath$datapath)"},{"path":"https://ludvigla.github.io/semla/articles/digital_unrolling.html","id":"prepare-network","dir":"Articles","previous_headings":"","what":"Prepare network","title":"Digital unrolling","text":"Now ready run app! app loads, see H&E image spots edges. goal disconnect layer roll cutting edges spots different layers. Cutting can done holding SHIFT key move cursor across edges make red. can also “repair” edges holding CTRL key. image illustrates edges two layers sliced. Sliced edges colored red edges cut, press Quit & Save button. just close app without pressing “Quit & Save”, results returned back R. NB: need make sure save output variable. , save output tidy_network. downstream steps, crucial layers separated appropriately. Even single edge two layer make impossible run stream steps reliably. image demonstrates situation separation fail. arrow points two edges (colored black) still connects two separate layers Luckily, changes made app default written spatial network file, miss something, can simply run app fix issue. Let’s plot full network filtered network:  just like , separated layers!","code":"tidy_network <- CutSpatialNetwork(se_mcolon, datadir = tilepath$datapath) library(tidygraph) library(patchwork) library(dplyr)  edges_full <- tidy_network |>    activate(edges) |>    as_tibble() edges_filtered <- tidy_network |>    activate(edges) |>    as_tibble() |>    filter(keep)  p1 <- ggplot(edges_full,         aes(x, xend = x_end, y, yend = y_end)) +   geom_segment() +   scale_y_reverse() +   coord_fixed() +   ggtitle(\"Full network\")  p2 <- ggplot(edges_filtered,         aes(x, xend = x_end, y, yend = y_end)) +   geom_segment() +   scale_y_reverse() +   coord_fixed() +   ggtitle(\"Filtered network\")  p1 + p2"},{"path":"https://ludvigla.github.io/semla/articles/digital_unrolling.html","id":"unrolling-the-network","dir":"Articles","previous_headings":"","what":"Unrolling the network","title":"Digital unrolling","text":"Now comes part actual “unrolling” using AdjustTissueCoordinates(). important things note . AdjustTissueCoordinates applies algorithm sort nodes spatial graph end points. Distances nodes used proxy actual distances tissue. distances nodes shortest paths, .e. minimum number edges needed visit (geodesic). obvious reasons, distances calculated nodes connected, reason, function handles connected graphs. Unfortunately, roll fully connected, function deal largest sub graph.  second, smaller sub graph discarded. Another thing note function relies assumptions shape folded tissue. try somethings completely different, let’s say tissue folded zig-zag shape, might work well. tidy_network_adjusted variable holds tibble node coordinates new x_dist y_dist coordinates. sanity check, can color original spatial map new distance values see make sense.  x_dist coordinates, arguably relevant regionalization patterns, looks quite good. y_dist coordinate shows distances base roll (muscle tissue) edge (mucosa). clear y_dist bit misplaced misplaced uneven thickness tissue protruding structures, particular proximal part. Now new coordinate system, can start looking regionalization gene expression along proximal-distal axis.  coordinates hands, quite straightforward extract genes whose expression depend distance along proximal-distal axis. part tutorial, rather simple way sorting genes expression heatmap. , becomes quite clear genes regionalized. one part heatmap stands , just right side center, genes expressed lymphoid structure located part colon.   semla: 1.0.0","code":"all_networks <- to_components(tidy_network |>                                  activate(edges) |>                                  filter(keep)) edges_labeled <- do.call(bind_rows, lapply(seq_along(all_networks), function(i) {   all_networks[[i]] |>      activate(edges) |>      as_tibble() |>      mutate(graph = paste0(\"sub graph\", i)) }))  ggplot(edges_labeled, aes(x, xend = x_end, y, yend = y_end)) +   geom_segment() +   scale_y_reverse() +   coord_fixed() +   facet_grid(~graph) tidy_network_adjusted <- AdjustTissueCoordinates(full_graph = tidy_network) ## ℹ Removing 537 edges ## ℹ Checking for disconnected graphs ## ℹ More than 1 subgraph identified. Keeping the largest subgraph ## ℹ Calculating pairwise geodesics between nodes in graph ## ℹ Identifying end points ## ℹ Finding shortest path beetween end points ## ℹ Checking location of nodes relative to shortest path nodes ## ℹ Rescaling y distances to ensure non-negative values ## ✔ Finished! p1 <- ggplot(tidy_network_adjusted, aes(x, y, color = x_dist)) +   geom_point() +   scale_color_gradientn(colours = RColorBrewer::brewer.pal(n = 9, name = \"Spectral\") |>                            rev()) +   coord_fixed() +   scale_y_reverse()  p2 <- ggplot(tidy_network_adjusted, aes(x, y, color = y_dist)) +   geom_point() +   scale_color_gradientn(colours = RColorBrewer::brewer.pal(n = 9, name = \"Spectral\") |>                            rev()) +   coord_fixed() +   scale_y_reverse()  p1 + p2 library(tibble) library(tidyr)  selected_genes <- c(\"Fxyd4\", \"Slc37a2\", \"Hmgcs2\", \"Cyp4b1\")  se_mcolon <- ScaleData(se_mcolon) gg <- FetchData(se_mcolon, vars = selected_genes, slot = \"scale.data\") |>    rownames_to_column(var = \"name\") |>    left_join(y = tidy_network_adjusted, by = \"name\") |>    pivot_longer(all_of(selected_genes), names_to = \"variable\", values_to = \"value\")  ggplot(gg, aes(x_dist, value, color = variable)) +   geom_smooth() sorted_spots <- tidy_network_adjusted |>    arrange(x_dist) |>    pull(name)  # Get scale data scale_data <- GetAssayData(se_mcolon,                             slot = \"scale.data\",                             assay = \"Spatial\")[VariableFeatures(se_mcolon), sorted_spots] |>    as.matrix()  # Bin data bins <- cut(1:ncol(scale_data), breaks = 50) binMat <- do.call(cbind, lapply(levels(bins), function(lvl) {   rowMeans(scale_data[, bins == lvl]) }))  pheatmap::pheatmap(binMat, cluster_cols = FALSE, border_color = FALSE,                    breaks = seq(-1, 1, length.out = 50),                     color = scico::scico(palette = \"bam\", n = 51)) sessionInfo() ## R version 4.2.1 (2022-06-23) ## Platform: x86_64-apple-darwin13.4.0 (64-bit) ## Running under: macOS Big Sur ... 10.16 ##  ## Matrix products: default ## BLAS/LAPACK: /Users/ludviglarsson/miniconda3/envs/R4.2/lib/libopenblasp-r0.3.21.dylib ##  ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ## [1] tidyr_1.3.0        tibble_3.1.8       patchwork_1.1.2    tidygraph_1.2.2    ## [5] semla_1.0.0        ggplot2_3.4.1      dplyr_1.1.0        SeuratObject_4.1.3 ## [9] Seurat_4.3.0       ##  ## loaded via a namespace (and not attached): ##   [1] systemfonts_1.0.4      plyr_1.8.7             igraph_1.3.4           ##   [4] lazyeval_0.2.2         sp_1.5-1               splines_4.2.1          ##   [7] listenv_0.8.0          scattermore_0.8        digest_0.6.29          ##  [10] htmltools_0.5.4        magick_2.7.3           fansi_1.0.3            ##  [13] magrittr_2.0.3         memoise_2.0.1          tensor_1.5             ##  [16] cluster_2.1.4          ROCR_1.0-11            globals_0.16.0         ##  [19] matrixStats_0.62.0     pkgdown_2.0.6          spatstat.sparse_3.0-0  ##  [22] colorspace_2.0-3       ggrepel_0.9.3          textshaping_0.3.6      ##  [25] xfun_0.32              jsonlite_1.8.3         progressr_0.10.1       ##  [28] spatstat.data_3.0-0    zeallot_0.1.0          survival_3.4-0         ##  [31] zoo_1.8-10             glue_1.6.2             polyclip_1.10-0        ##  [34] gtable_0.3.0           leiden_0.4.2           scico_1.3.1            ##  [37] future.apply_1.9.0     abind_1.4-5            scales_1.2.1           ##  [40] pheatmap_1.0.12        DBI_1.1.3              spatstat.random_3.0-1  ##  [43] miniUI_0.1.1.1         Rcpp_1.0.9             viridisLite_0.4.1      ##  [46] xtable_1.8-4           reticulate_1.26        htmlwidgets_1.5.4      ##  [49] httr_1.4.4             RColorBrewer_1.1-3     ellipsis_0.3.2         ##  [52] ica_1.0-3              pkgconfig_2.0.3        farver_2.1.1           ##  [55] sass_0.4.2             uwot_0.1.14            deldir_1.0-6           ##  [58] utf8_1.2.2             tidyselect_1.2.0       labeling_0.4.2         ##  [61] rlang_1.0.6            reshape2_1.4.4         later_1.3.0            ##  [64] munsell_0.5.0          tools_4.2.1            cachem_1.0.6           ##  [67] cli_3.4.1              dbscan_1.1-10          generics_0.1.3         ##  [70] ggridges_0.5.3         evaluate_0.16          stringr_1.5.0          ##  [73] fastmap_1.1.0          yaml_2.3.5             ragg_1.2.2             ##  [76] goftest_1.2-3          knitr_1.39             fs_1.5.2               ##  [79] fitdistrplus_1.1-8     purrr_1.0.1            RANN_2.6.1             ##  [82] pbapply_1.5-0          future_1.27.0          nlme_3.1-159           ##  [85] mime_0.12              compiler_4.2.1         rstudioapi_0.14        ##  [88] plotly_4.10.0          png_0.1-7              spatstat.utils_3.0-1   ##  [91] bslib_0.4.0            stringi_1.7.8          highr_0.9              ##  [94] desc_1.4.1             forcats_0.5.2          lattice_0.20-45        ##  [97] Matrix_1.5-3           shinyjs_2.1.0          vctrs_0.5.2            ## [100] pillar_1.8.1           lifecycle_1.0.3        spatstat.geom_3.0-3    ## [103] lmtest_0.9-40          jquerylib_0.1.4        RcppAnnoy_0.0.19       ## [106] data.table_1.14.2      cowplot_1.1.1          irlba_2.3.5            ## [109] httpuv_1.6.5           R6_2.5.1               promises_1.2.0.1       ## [112] KernSmooth_2.23-20     gridExtra_2.3          parallelly_1.32.1      ## [115] codetools_0.2-18       MASS_7.3-58.1          rprojroot_2.0.3        ## [118] withr_2.5.0            sctransform_0.3.5      mgcv_1.8-40            ## [121] parallel_4.2.1         grid_4.2.1             rmarkdown_2.15         ## [124] Rtsne_0.16             spatstat.explore_3.0-5 shiny_1.7.4"},{"path":"https://ludvigla.github.io/semla/articles/feature_viewer.html","id":"feature-viewer","dir":"Articles","previous_headings":"","what":"Feature viewer","title":"Interactive Feature Viewer","text":"Using mouse brain data set example, ’ll go use FeatureViewer() application.","code":"se <- readRDS(system.file(\"extdata/mousecolon\", \"se_mcolon\", package = \"semla\")) |>    LoadImages() ## ## ── Loading H&E images ── ## ## ℹ Loading image from /private/var/folders/zb/1fj07x_5343fvs_k28gnm1z80002xs/T/RtmpFJGwBj/temp_libpath502354c29e9d/semla/extdata/mousecolon/spatial/tissue_hires_image.jpg ## ℹ Scaled image from 1804x2000 to 400x443 pixels ## ℹ Saving loaded H&E images as 'rasters' in Seurat object ImagePlot(se)"},{"path":"https://ludvigla.github.io/semla/articles/feature_viewer.html","id":"data-export","dir":"Articles","previous_headings":"Feature viewer","what":"Data export","title":"Interactive Feature Viewer","text":"initiate viewer, call FeatureViewer() function Seurat object input. FeatureViewer() automatically attempt export necessary files temporary directory (default) specified directory (datadir). files include tiled H&E images, spot coordinates additional meta data file image related information. working larger data set multiple tissue sections, probably want avoid exporting files time open viewer. can find instruction tutorial Advanced.","code":""},{"path":"https://ludvigla.github.io/semla/articles/feature_viewer.html","id":"running-the-interactive-viewer","dir":"Articles","previous_headings":"Feature viewer","what":"Running the interactive viewer","title":"Interactive Feature Viewer","text":"app closed, changes made app returned Seurat object, need call se <- FeatureViewer(se) save changes Seurat object. important note application exited clicking ‘save’ icon top right corner app, otherwise changes ’ve made returned R. NB: Like functions provided semla, FeatureViewer() works Seurat objects processed semla. app open default browser:   get started, can click ‘question mark’ icon give instructions use app:","code":"se <- FeatureViewer(se)"},{"path":"https://ludvigla.github.io/semla/articles/feature_viewer.html","id":"zoom-and-pan","dir":"Articles","previous_headings":"Feature viewer","what":"Zoom and pan","title":"Interactive Feature Viewer","text":"can zoom using mouse wheel pan dragging clicking dragging H&E image. opacity slider allows us hide spots wish view clear view H&E image:","code":""},{"path":"https://ludvigla.github.io/semla/articles/feature_viewer.html","id":"selecting-features","dir":"Articles","previous_headings":"Feature viewer","what":"Selecting features","title":"Interactive Feature Viewer","text":"Feature drop list, can select numeric feature available Seurat object. includes vectors stored meta.data slot well dimensionality reduction vectors stored reductions slot. multiple assays available Seurat object, features active assay available. avoid naming conflicts different assays can share identical feature IDs. want select raw scaled counts, can specify Assay slot use slot argument FeatureViewer.","code":""},{"path":"https://ludvigla.github.io/semla/articles/feature_viewer.html","id":"other-options","dir":"Articles","previous_headings":"Feature viewer","what":"Other options","title":"Interactive Feature Viewer","text":"opacity slider: scale spot opacity. scale alpha: scale spot opacity numeric features based feature values. Trim slider: trim lower upper bounds selected numeric feature values. 0 corresponds minimum value 1 corresponds maximum value. Colorscale: select color palette numeric features. center zero: centers color scale 0 can useful visualizing centered values, example principal component vectors scaled expression. center zero active, appropriate use divergent color palette ‘Colorscales’, RdBu.","code":""},{"path":"https://ludvigla.github.io/semla/articles/feature_viewer.html","id":"category","dir":"Articles","previous_headings":"Feature viewer","what":"Category","title":"Interactive Feature Viewer","text":"Categorical variables stored Seurat object meta.data slot made available ‘Category’ drop-list. can select new category select current category press ENTER update view.","code":""},{"path":"https://ludvigla.github.io/semla/articles/feature_viewer.html","id":"lasso-tool","dir":"Articles","previous_headings":"Feature viewer","what":"Lasso tool","title":"Interactive Feature Viewer","text":"example , selected meta.data column called orig.ident currently contains one label. categorical variable selected, get option add new labels. can add new label, need select spots ‘lasso tool’ top left corner toolbar:  Select color color picker, write new label name press ENTER save changes:  new label added, pop color legend. Labels can share color, wish update color existing label, can select spots selection, select new color, write label name press ENTER. update color spots label. NB: lasso tool freeze current view, meaning able zoom pan lasso tool active. Deactivate lasso tool enable navigation viewer.","code":""},{"path":"https://ludvigla.github.io/semla/articles/feature_viewer.html","id":"add-new-categories","dir":"Articles","previous_headings":"Feature viewer","what":"Add new categories","title":"Interactive Feature Viewer","text":"add new category, simply click ‘Category’ drop-box, delete text, write new category name press ENTER","code":""},{"path":"https://ludvigla.github.io/semla/articles/feature_viewer.html","id":"save-changes","dir":"Articles","previous_headings":"Feature viewer","what":"Save changes","title":"Interactive Feature Viewer","text":"continue working R need quit application pressing ‘save & quit’ icon top right corner toolbar.","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/articles/feature_viewer.html","id":"export-data","dir":"Articles","previous_headings":"Advanced","what":"Export data","title":"Interactive Feature Viewer","text":"export necessary data viewer specific output directory ExportDataForViewer() function. can come handy working larger datasets don’t want re-export data every time run viewer. output directory specified outdir argument needs existing writable directory. files already exist location, need set overwrite=TRUE want overwrite files. ExportDataForViewer() creates new directory inside outdir called ‘viewer_data’, full path /viewer_data. path returned function passed FeatureViewer. can also specify samples export data sampleIDs argument. example, chose export one section 1 (sampleIDs=1), able view section FeatureViewer. Now can pass datadir = datapath FeatureViewer load files directory instead exporting files .","code":"datapath <- ExportDataForViewer(se, sampleIDs = 1, outdir = \"~/Downloads/\") se <- FeatureViewer(se, datadir = datapath)"},{"path":"https://ludvigla.github.io/semla/articles/feature_viewer.html","id":"multiple-sections","dir":"Articles","previous_headings":"Advanced","what":"Multiple sections","title":"Interactive Feature Viewer","text":"using multiple datasets, able select Sample drop-list viewer. Note working many datasets, app might slow considerably. case, might better view selected sections specified sampleIDs.  semla: 1.0.0","code":"se_mbrain <- readRDS(system.file(\"extdata/mousebrain\", \"se_mbrain\", package = \"semla\")) se_mcolon <- readRDS(system.file(\"extdata/mousecolon\", \"se_mcolon\", package = \"semla\")) se_merged <- MergeSTData(se_mbrain, se_mcolon) |> LoadImages() se_merged <- FeatureViewer(se_merged)"},{"path":"https://ludvigla.github.io/semla/articles/getting_started.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Get started","text":"install semla, run following command R: Load libraries","code":"remotes::install_github(\"ludvigla/semla\") library(semla) library(tibble)"},{"path":"https://ludvigla.github.io/semla/articles/getting_started.html","id":"load-data","dir":"Articles","previous_headings":"","what":"Load data","title":"Get started","text":"Currently, semla exclusively supports 10x Visium data. easiest way load data use ReadVisiumData() function. First, need couple files output 10x Genomics Space Ranger command line tool. files assembled data.frame-like object one sample per row can used ReadVisiumData(). samples : file paths expression matrices imgs : file paths H&E images spotfiles : file paths spot coordinate tables json : file paths scale factor json files can also add number columns infoTable passed meta data columns Seurat object. can example useful want add clinical metadata, experimental information etc. example data two Visium data sets, one mouse brain one mouse colon data set. add sample_id column describing tissue type .  Now ready load 10x Visium data Seurat object:  can use Seurat methods long require spatial information. ’s important know Seurat R package stores spatial information (H&E images coordinates) differently semla, meaning Seurat functions SpatialFeaturePlot() FindSpatiallyVariableFeatures() work. semla comes ’s suite tools methods can learn tutorials.  need access spatial data, images coordinates, can use GetStaffli function Seurat object.  H&E images loaded LoadImages called Seurat object.  enough get started rest tutorials! NB: important thing know generic functions, subset merge used semla. Instead, use SubsetSTData() MergeSTData() functions - See vignette Subset/merge.","code":"data_root_directory <- file.path(system.file(\"extdata\", package = \"semla\"), \"*\")  samples <- Sys.glob(paths = file.path(data_root_directory,                                        \"filtered_feature_bc_matrix.h5\"))  imgs <- Sys.glob(paths = file.path(data_root_directory,                                     \"spatial\", \"tissue_hires_image.png\"))  spotfiles <- Sys.glob(paths = file.path(data_root_directory,                                          \"spatial\", \"tissue_positions_list.csv\"))  json <- Sys.glob(paths = file.path(data_root_directory,                                     \"spatial\", \"scalefactors_json.json\")) infoTable <- tibble(samples, imgs, spotfiles, json, # Add required columns                     sample_id = c(\"mousebrain\", \"mousecolon\")) # Add additional column se <- ReadVisiumData(infoTable) se ## An object of class Seurat  ## 188 features across 5164 samples within 1 assay  ## Active assay: Spatial (188 features, 0 variable features) spatial_data <- GetStaffli(se) se <- LoadImages(se) ImagePlot(se)"},{"path":"https://ludvigla.github.io/semla/articles/image_alignment.html","id":"basic-image-transformation","dir":"Articles","previous_headings":"","what":"Basic image transformation","title":"Image alignment","text":"first step generate tibble transformations want apply. generate_rigid_transform() helper function makes task bit easier. example , ’ll mirror H&E image along x axis, rotate 30 degrees, move 20% right 20% . Translations (tr_x tr_y) provided proportions. example, tr_x = 0.1 means ’ll move H&E image 20% image width right. Now ready apply transformations: original H&E image still stored Seurat object, plotting need specify want use transformed image:   spot coordinates transformed together H&E image, use MapFeatures() MapLabels(), see spots still correctly positioned H&E image. NB: Translations might result moving parts H&E image outside predefined ‘canvas’. example , results spots located outside view therefore dropped. original image dimensions always retained.","code":"transforms <- generate_rigid_transform(mirror_x = TRUE, angle = 30, tr_x = 0.2, tr_y = -0.2) transforms ## # A tibble: 1 × 7 ##   sampleID mirror_x mirror_y angle  tr_x  tr_y scalefactor ##      <dbl> <lgl>    <lgl>    <dbl> <dbl> <dbl>       <dbl> ## 1        1 TRUE     FALSE       30   0.2  -0.2           1 se_mbrain <- RigidTransformImages(se_mbrain, transforms = transforms) ImagePlot(se_mbrain) title(\"Original H&E image\") ImagePlot(se_mbrain, image_use = \"transformed\") title(\"Transformed H&E image\") MapFeatures(se_mbrain, features = \"nFeature_Spatial\", image_use = \"transformed\") ## Warning: Removed 27 rows containing missing values (`geom_point()`)."},{"path":"https://ludvigla.github.io/semla/articles/image_alignment.html","id":"interactive-alignment","dir":"Articles","previous_headings":"","what":"Interactive alignment","title":"Image alignment","text":"take look three H&E images different orientations, goal align common coordinate system. can click ‘show’ see code used generate dummy data using RigidTransformImages.  call RunAlignment, interactive application open separate window.  click Help, see instructions use app:  can select H&E images put view clicking button alignment panel:  H&E images can moved around dragging image cursor. dotted borders around H&E images highlights dimensions ‘canvas’. Anything outside borders removed. interaction handled pressing key clicking H&E image. example, can change transparency holding q w clicking H&E image. can rotate H&E image holding SHIFT dragging blue dot corner image. Similarly, scaling can done holding dragging blue dot. example , can see ‘image2’ scaled rotated align ‘image1’. left align ‘image2’ ‘image1’:  end, able get decent alignment three H&E images. table top alignment panel shows transformations applied:  satisfied alignment, can press Quit & Save button trigger alignment H&E images (R) results saved Seurat object. set image_use='transformed' MapFeatures, see H&E images now aligned. NB: Manipulating images often lead cropping. first image , can see corners cropped filled empty white space.  Now data aligned, easier look specific areas tissue sections crop_area option","code":"se_merged <- MergeSTData(se_mbrain, list(se_mbrain, se_mbrain)) |> LoadImages() transforms1 <- generate_rigid_transform(mirror_x = TRUE, angle = 45, sampleID = 1) transforms2 <- generate_rigid_transform(mirror_x = TRUE, scalefactor = 0.8, sampleID = 2) transforms3 <- generate_rigid_transform(mirror_y = TRUE, scalefactor = 0.6, sampleID = 3) transforms <- bind_rows(transforms1, transforms2, transforms3) se_merged <- RigidTransformImages(se_merged, transforms = transforms, verbose = TRUE) se_merged@tools$Staffli@rasterlists$raw <- se_merged@tools$Staffli@rasterlists$transformed se_merged@tools$Staffli@rasterlists$transformed <- NULL se_merged@tools$Staffli@meta_data <- se_merged@tools$Staffli@meta_data |>    select(-pxl_col_in_fullres, -pxl_row_in_fullres) |>    rename(pxl_col_in_fullres = pxl_col_in_fullres_transformed, pxl_row_in_fullres = pxl_row_in_fullres_transformed) ImagePlot(se_merged, mar = c(0, 0, 0, 0), ncol = 3) se_merged <- RunAlignment(se_merged) MapFeatures(se_merged, features = \"nFeature_Spatial\", image_use = \"transformed\", ncol = 3) &   theme(legend.position = \"right\", legend.text = element_text(angle = 0)) se_merged <- LoadImages(se_merged, image_height = 1.5e3) MapFeatures(se_merged, features = \"nFeature_Spatial\", image_use = \"transformed\",              ncol = 3, crop_area = c(0.4, 0.43, 0.6, 0.67)) &   theme(legend.position = \"right\", legend.text = element_text(angle = 0))"},{"path":"https://ludvigla.github.io/semla/articles/image_alignment.html","id":"images-with-different-dimensions","dir":"Articles","previous_headings":"","what":"Images with different dimensions","title":"Image alignment","text":"RunAlignment applies transformations image independently makes sure original dimensions images kept. behavior might seem confusing first. Let’s say want force images align first H&E image can use transformed coordinates 3D visualization, work without additional processing. example , can see two H&E images slightly different dimensions. second image (mouse colon tissue) aspect ration lower 1 whereas first image (mouse brain tissue) aspect ratio higher 1 images loaded height. applying transformations second image, dashed box define image placed relative first image, image keep aspect ratio. apply rigid transformations according image , result :  can see second image fits top bottom dashed box, sides wider box.","code":"se_mbrain <- readRDS(file = system.file(\"extdata\",                                          \"mousebrain/se_mbrain\",                                          package = \"semla\")) se_mcolon <- readRDS(file = system.file(\"extdata\",                                          \"mousecolon/se_mcolon\",                                          package = \"semla\")) se_merged <- MergeSTData(se_mbrain, se_mcolon) |> LoadImages()  se_merged <- RunAlignment(se_merged) ImagePlot(se_merged, image_use = \"transformed\")"},{"path":"https://ludvigla.github.io/semla/articles/image_alignment.html","id":"d-visualization","dir":"Articles","previous_headings":"","what":"3D visualization","title":"Image alignment","text":"3D visualization requires additional processing. tissue section, spot coordinates can defined completely different scales. order place coordinates scale, can adjust coordinates dividing width/height H&E images. code can used scale transformed coordinates common coordinate system, case range 0 1. can use sampleID z-coordinate create “z-stack” can visualized 3D. ’ll leave actual 3D visualization exercise, achieve can example use R package plotly.  semla: 1.0.0","code":"xy_coords <- GetStaffli(se_merged)@meta_data |>    select(pxl_col_in_fullres_transformed, pxl_row_in_fullres_transformed, sampleID) |>    group_by(sampleID) |>    group_split()    image_info <- GetStaffli(se_merged)@image_info  # Adjust coordinates adjusted_coords <- do.call(bind_rows, lapply(seq_along(xy_coords), function(i) {   xy <- xy_coords[[i]]   full_width <- image_info[i, ]$full_width   full_height <- image_info[i, ]$full_height   xy <- xy |>      mutate(x = pxl_col_in_fullres_transformed/full_width,            y = pxl_row_in_fullres_transformed/full_height) |>      select(x, y, sampleID) })) sessionInfo() ## R version 4.2.1 (2022-06-23) ## Platform: x86_64-apple-darwin13.4.0 (64-bit) ## Running under: macOS Big Sur ... 10.16 ##  ## Matrix products: default ## BLAS/LAPACK: /Users/ludviglarsson/miniconda3/envs/R4.2/lib/libopenblasp-r0.3.21.dylib ##  ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ## [1] semla_1.0.0        ggplot2_3.4.1      dplyr_1.1.0        SeuratObject_4.1.3 ## [5] Seurat_4.3.0       ##  ## loaded via a namespace (and not attached): ##   [1] Rtsne_0.16             colorspace_2.0-3       deldir_1.0-6           ##   [4] ellipsis_0.3.2         ggridges_0.5.3         rprojroot_2.0.3        ##   [7] fs_1.5.2               spatstat.data_3.0-0    rstudioapi_0.14        ##  [10] farver_2.1.1           leiden_0.4.2           listenv_0.8.0          ##  [13] ggrepel_0.9.3          fansi_1.0.3            codetools_0.2-18       ##  [16] splines_4.2.1          cachem_1.0.6           knitr_1.39             ##  [19] zeallot_0.1.0          polyclip_1.10-0        jsonlite_1.8.3         ##  [22] ica_1.0-3              cluster_2.1.4          png_0.1-7              ##  [25] uwot_0.1.14            spatstat.sparse_3.0-0  shiny_1.7.4            ##  [28] sctransform_0.3.5      compiler_4.2.1         httr_1.4.4             ##  [31] Matrix_1.5-3           fastmap_1.1.0          lazyeval_0.2.2         ##  [34] cli_3.4.1              later_1.3.0            htmltools_0.5.4        ##  [37] tools_4.2.1            igraph_1.3.4           gtable_0.3.0           ##  [40] glue_1.6.2             RANN_2.6.1             reshape2_1.4.4         ##  [43] Rcpp_1.0.9             scattermore_0.8        jquerylib_0.1.4        ##  [46] pkgdown_2.0.6          vctrs_0.5.2            nlme_3.1-159           ##  [49] spatstat.explore_3.0-5 progressr_0.10.1       lmtest_0.9-40          ##  [52] spatstat.random_3.0-1  xfun_0.32              stringr_1.5.0          ##  [55] globals_0.16.0         mime_0.12              miniUI_0.1.1.1         ##  [58] lifecycle_1.0.3        irlba_2.3.5            goftest_1.2-3          ##  [61] future_1.27.0          MASS_7.3-58.1          zoo_1.8-10             ##  [64] scales_1.2.1           ragg_1.2.2             promises_1.2.0.1       ##  [67] spatstat.utils_3.0-1   parallel_4.2.1         RColorBrewer_1.1-3     ##  [70] yaml_2.3.5             memoise_2.0.1          reticulate_1.26        ##  [73] pbapply_1.5-0          gridExtra_2.3          sass_0.4.2             ##  [76] stringi_1.7.8          highr_0.9              desc_1.4.1             ##  [79] rlang_1.0.6            pkgconfig_2.0.3        systemfonts_1.0.4      ##  [82] matrixStats_0.62.0     evaluate_0.16          lattice_0.20-45        ##  [85] tensor_1.5             ROCR_1.0-11            purrr_1.0.1            ##  [88] labeling_0.4.2         patchwork_1.1.2        htmlwidgets_1.5.4      ##  [91] cowplot_1.1.1          tidyselect_1.2.0       parallelly_1.32.1      ##  [94] RcppAnnoy_0.0.19       plyr_1.8.7             magrittr_2.0.3         ##  [97] R6_2.5.1               magick_2.7.3           generics_0.1.3         ## [100] DBI_1.1.3              withr_2.5.0            pillar_1.8.1           ## [103] fitdistrplus_1.1-8     abind_1.4-5            survival_3.4-0         ## [106] sp_1.5-1               tibble_3.1.8           future.apply_1.9.0     ## [109] KernSmooth_2.23-20     utf8_1.2.2             spatstat.geom_3.0-3    ## [112] plotly_4.10.0          rmarkdown_2.15         grid_4.2.1             ## [115] data.table_1.14.2      forcats_0.5.2          digest_0.6.29          ## [118] xtable_1.8-4           dbscan_1.1-10          tidyr_1.3.0            ## [121] httpuv_1.6.5           textshaping_0.3.6      munsell_0.5.0          ## [124] viridisLite_0.4.1      bslib_0.4.0            shinyjs_2.1.0"},{"path":"https://ludvigla.github.io/semla/articles/images_and_coordinates.html","id":"image-transformation","dir":"Articles","previous_headings":"","what":"Image transformation","title":"Images and spot coordinates","text":"semla uses magick R package read process images. Please look vignette want know magick. Let’s load H&E image visualize :  H&E image 2000 pixels high 1882 pixels wide. want scale image, can use image_scale() magick:  can also apply various types transformations:  working multiple SRT data sets, can useful align tissue sections roughly orientation size. words, might want register H&E images reference image. , want apply rotations, reflections translations. issue default magick rotation function creates bounding box hold entire image, makes image bigger. plots cans see rotated image 586x586 pixels size compared 400x425 images. main issue want map spots H&E images rotation, scale now changed spots appear smaller. Instead, convenient keep input dimensions. semla provide two functions complement transformation functions available magick R package: ImageTranslate() ImageTransform(). ImageTranslate can used move H&E image. imagine art board dimensions image, function can used move H&E image art board. However, part image inside art board kept. ImageTransform can used rotate translate H&E images. , transformations occur inside art board part image still inside art board returned.  can see, regardless transformation apply, image dimensions remain .","code":"he <- system.file(\"extdata/mousebrain/spatial\", \"tissue_hires_image.png\", package = \"semla\") im <- image_read(he)  # get information about image info <- image_info(im) info ## # A tibble: 1 × 7 ##   format width height colorspace matte filesize density ##   <chr>  <int>  <int> <chr>      <lgl>    <int> <chr>   ## 1 PNG     1882   2000 sRGB       FALSE  5031054 72x72 # Plot HE image par(mar = c(0, 0, 1, 0)) im |> as.raster() |> plot() title(paste0(info$width, \"x\", info$height)) # Scale down and plot HE image im_small <- im |> image_scale(\"400\")  info_small <- image_info(im_small) info_small ## # A tibble: 1 × 7 ##   format width height colorspace matte filesize density ##   <chr>  <int>  <int> <chr>      <lgl>    <int> <chr>   ## 1 PNG      400    425 sRGB       FALSE        0 72x72 par(mar = c(0, 0, 1, 0)) im_small |> as.raster() |> plot() title(paste0(info_small$width, \"x\", info_small$height)) # Rotate image im_rot <- im_small |> image_rotate(degrees = 45)  # Mirror image along x axis im_xrefl <- im_small |> image_flop()  # Mirror image along y axis im_yrefl <- im_small |> image_flip()  par(mfrow = c(2, 2), mar = c(0, 0, 2, 0)) im_small |> as.raster() |> plot() title(paste0(\"original \", info_small$width, \"x\", info_small$height)) im_rot |> as.raster() |> plot() title(paste0(\"rotated 45 degrees (\",               image_info(im_rot)$width, \"x\", image_info(im_rot)$height, \")\")) im_xrefl |> as.raster() |> plot() title(paste0(\"reflected along x axis (\",               image_info(im_xrefl)$width, \"x\", image_info(im_xrefl)$height, \")\")) im_yrefl |> as.raster() |> plot() title(paste0(\"reflected along y axis (\",               image_info(im_yrefl)$width, \"x\", image_info(im_yrefl)$height, \")\")) # Move image 100 pixels to the right and 100 pixels down im_rot <- im_small |> ImageTranslate(xy_offset = c(100, 100))  # Rotate image 45 degrees im_transf <- im_small |> ImageTransform(angle = 45, xy_offset = c(0, 0))  # Rotate image 45 degrees and move image 100 pixels to the left and 100 pixels up im_transf2 <- im_small |> ImageTransform(angle = 45, xy_offset = c(-100, -100))  par(mfrow = c(2, 2), mar = c(0, 0, 2, 0)) im_small |> as.raster() |> plot() title(paste0(\"original (\", info_small$width, \"x\", info_small$height, \")\")) im_rot |> as.raster() |> plot() title(paste0(\"moved towards bottom right corner (\",               image_info(im_rot)$width, \"x\", image_info(im_rot)$height, \")\")) im_transf |> as.raster() |> plot() title(paste0(\"rotated 45 degrees clockwise (\",               image_info(im_transf)$width, \"x\", image_info(im_transf)$height, \")\")) im_transf2 |> as.raster() |> plot() title(paste0(\"rotated 45 degrees clockwise and moved (\",               image_info(im_transf2)$width, \"x\", image_info(im_transf2)$height, \")\"))"},{"path":"https://ludvigla.github.io/semla/articles/images_and_coordinates.html","id":"spot-transformation","dir":"Articles","previous_headings":"","what":"Spot transformation","title":"Images and spot coordinates","text":"Let’s load spot coordinates H&E image . access Visium grid coordinates H&E image coordinates full resolution image used spaceranger count. also column spot barcodes column called selected holds information sots located tissue. can illustrate means plot:  spots value 1 correspond spots tissue. right now, tissue upside plot relative H&E image. origin (0, 0) plot located bottom left corner, images upper right corner. can fix easily inverting y axis. However, properly, need dimensions H&E image… Unfortunately, don’t access information right now need load scalefactors H&E image provided spaceranger output folder. Now can see scaling factor original H&E image tissue_lowres image ~0.03. Let’s load tissue_lowres convert coordinates fit image: couple important things pay attention . x, y coordinates now transformed fit H&E image therefore can set limits plot H&E image dimensions (see limits scale_*_continuous()). also need set expand = c(0, 0) make sure margins removed plot area. also need invert y axis can now H&E image height (image_info(im)$height).  also functions available apply transformations spots: CoordTransform() CoordMirror(). CoordTransform equivalent ImageTransform spot coordinates, meaning can apply rotations translations. main difference CoordTransform rotates around predefined center. want apply rotation H&E image corresponding spot coordinates, want set center argument center H&E image. Let’s demonstrate spot coordinates:  spots rotated around center spots (red cross). Instead, want define center rotate spots around, center H&E image.  Now let’s look can transform coordinates images time.","code":"# get example coordinate file cordinatefile <- system.file(\"extdata/mousebrain/spatial\",                               \"tissue_positions_list.csv\",                               package = \"semla\")  # Load coordinates xy <- LoadSpatialCoordinates(coordinatefiles = cordinatefile, verbose = T) xy ## # A tibble: 2,560 × 7 ##    barcode            selected     y     x pxl_row_in_fullres pxl_col_…¹ sampl…² ##    <chr>                 <int> <int> <int>              <int>      <int>   <int> ##  1 CATACAAAGCCGAACC-1        1    13    35               4117       6086       1 ##  2 CTGAGCAAGTAACAAG-1        1    15    25               4472       5062       1 ##  3 GGGTACCCACGGTCCT-1        1    14    26               4294       5164       1 ##  4 ACGGAATTTAGCAAAT-1        1    15    27               4472       5266       1 ##  5 GGGCGGTCCTATTGTC-1        1    14    28               4294       5369       1 ##  6 ATGTTACGAGCAATAC-1        1    15    29               4472       5471       1 ##  7 AACCATGGGATCGCTA-1        1    14    30               4294       5574       1 ##  8 TCGCATCCCTAAGTGT-1        1    15    31               4473       5676       1 ##  9 ACTTAGTACGACAAGA-1        1    14    32               4295       5778       1 ## 10 GAGCTCTCGGACCTAA-1        1    15    33               4473       5881       1 ## # … with 2,550 more rows, and abbreviated variable names ¹​pxl_col_in_fullres, ## #   ²​sampleID ggplot(xy, aes(pxl_col_in_fullres, pxl_row_in_fullres, color = factor(selected))) +    geom_point() scalefactorfile <- system.file(\"extdata/mousebrain/spatial\",                               \"scalefactors_json.json\",                               package = \"semla\")  # read scalefactors scalefactors <- jsonlite::read_json(scalefactorfile) scalefactors ## $spot_diameter_fullres ## [1] 143.3171 ##  ## $tissue_hires_scalef ## [1] 0.1039393 ##  ## $fiducial_diameter_fullres ## [1] 214.9757 ##  ## $tissue_lowres_scalef ## [1] 0.03118179 lowresimagefile <- system.file(\"extdata/mousebrain/spatial\",                               \"tissue_lowres_image.png\",                               package = \"semla\")  # Load image im <- image_read(lowresimagefile) image_info(im) ## # A tibble: 1 × 7 ##   format width height colorspace matte filesize density ##   <chr>  <int>  <int> <chr>      <lgl>    <int> <chr>   ## 1 PNG      565    600 sRGB       FALSE   467277 72x72 # Convert coordinates xy <- xy |>   mutate(across(pxl_col_in_fullres:pxl_row_in_fullres,                  ~ .x*scalefactors$tissue_lowres_scalef)) g <- im |>    rasterGrob(width = unit(1, \"npc\"), height = unit(1, \"npc\"), interpolate = TRUE)  ggplot(xy, aes(pxl_col_in_fullres,                 pxl_row_in_fullres,                 color = factor(selected))) +   annotation_custom(g, -Inf, Inf, -Inf, Inf) +   geom_point() +   scale_x_continuous(limits = c(0, image_info(im)$width), expand = c(0, 0)) +   scale_y_reverse(limits = c(image_info(im)$height, 0), expand = c(0, 0)) # Select only x, y coordinates xy_coords <- xy |>   head(n = 1500) |>   select(pxl_col_in_fullres, pxl_row_in_fullres)  # Midpoint c_xy <- colMeans(xy_coords)  # Apply transformation to apot coordinates xy_transformed <- CoordTransform(xy_coords, angle = 45, xy_offset = c(0, 0))  # Plot spot coordinates gg <- rbind(cbind(xy_coords |> setNames(c(\"x\", \"y\")), type = \"original\"),              cbind(xy_transformed |> setNames(c(\"x\", \"y\")), type = \"transformed\")) ggplot(gg, aes(x, y, color = type)) +   geom_point()  +   geom_point(aes(x = c_xy[1], y = c_xy[2]), color = \"red\",               size = 5, shape = 4, stroke = 3) +   facet_grid(~type) +   scale_x_continuous(limits = c(0, image_info(im)$width), expand = c(0, 0)) +   scale_y_reverse(limits = c(image_info(im)$height, 0), expand = c(0, 0)) # Select only x, y coordinates xy_coords <- xy |>   head(n = 1500) |>   select(pxl_col_in_fullres, pxl_row_in_fullres)  # Apply transformation to apot coordinates xy_transformed <- CoordTransform(xy_coords, angle = 45, xy_offset = c(0, 0),                                   center = c(image_info(im)$width/2,                                              image_info(im)$height - image_info(im)$height/2))  # Plot spot coordinates gg <- rbind(cbind(xy_coords |> setNames(c(\"x\", \"y\")), type = \"original\"),              cbind(xy_transformed |> setNames(c(\"x\", \"y\")), type = \"transformed\"))  ggplot(gg, aes(x, y, color = type)) +   geom_point()  +   geom_point(aes(x = image_info(im)$width/2,                   y = image_info(im)$height/2),               color = \"blue\", size = 5, stroke = 3, shape = 4) +   facet_grid(~type) +   scale_x_continuous(limits = c(0, image_info(im)$width), expand = c(0, 0)) +   scale_y_reverse(limits = c(image_info(im)$height, 0), expand = c(0, 0))"},{"path":[]},{"path":"https://ludvigla.github.io/semla/articles/images_and_coordinates.html","id":"rotation","dir":"Articles","previous_headings":"Transform images and spots","what":"Rotation","title":"Images and spot coordinates","text":"CoordAndImageTransform() makes transformation process bit simpler. can provide H&E image corresponding spot coordinates apply transformations objects simultaneously. note spot coordinates still defined way , .e. origin top left corner. means still need invert y axis. Since spots now outside “art board”, missed drawing plot. example, lose 46 spots!","code":"# Select only x, y coordinates xy_coords <- xy |>   select(pxl_col_in_fullres, pxl_row_in_fullres)  # Apply transformations transf_res <- CoordAndImageTransform(im, xy_coords, angle = 45, xy_offset_image = c(0, 0))  # Plot results g <- transf_res$im_transf |>    rasterGrob(width = unit(1, \"npc\"), height = unit(1, \"npc\"), interpolate = TRUE)  # Add selected to transf_res$xy_transf transf_res$xy_transf$selected <- xy$selected  # Note that the y axis still needs to be reversed ggplot(transf_res$xy_transf, aes(tr_x, tr_y,                 color = factor(selected))) +   annotation_custom(g, -Inf, Inf, -Inf, Inf) +   geom_point() +   scale_x_continuous(limits = c(0, image_info(im)$width), expand = c(0, 0)) +   scale_y_reverse(limits = c(image_info(im)$height, 0), expand = c(0, 0))"},{"path":"https://ludvigla.github.io/semla/articles/images_and_coordinates.html","id":"rotation-translation","dir":"Articles","previous_headings":"Transform images and spots","what":"Rotation + translation","title":"Images and spot coordinates","text":"semla: 1.0.0 magick: 2.7.3","code":"# Select only x, y coordinates xy_coords <- xy |>   select(pxl_col_in_fullres, pxl_row_in_fullres)  # Apply transformations transf.res <- CoordAndImageTransform(im, xy_coords, angle = 45, xy_offset_image = c(100, 100))  # Plot results g <- transf.res$im_transf |>    rasterGrob(width = unit(1, \"npc\"), height = unit(1, \"npc\"), interpolate = TRUE)  # Add selected to transf.res$xy_transf transf.res$xy_transf$selected <- xy$selected  ggplot(transf.res$xy_transf, aes(tr_x, image_info(im)$height - tr_y,                 color = factor(selected))) +   annotation_custom(g, -Inf, Inf, -Inf, Inf) +   geom_point() +   scale_x_continuous(limits = c(0, image_info(im)$width), expand = c(0, 0)) +   scale_y_continuous(limits = c(0, image_info(im)$height), expand = c(0, 0)) # Select only x, y coordinates xy_coords <- xy |>   select(pxl_col_in_fullres, pxl_row_in_fullres)  # Apply transformations transf.res <- CoordAndImageTransform(im, xy_coords, angle = 45, mirror_x = TRUE)  # Plot results g <- transf.res$im_transf |>    rasterGrob(width = unit(1, \"npc\"), height = unit(1, \"npc\"), interpolate = TRUE)  # Add selected to transf.res$xy_transf transf.res$xy_transf$selected <- xy$selected  ggplot(transf.res$xy_transf, aes(tr_x, image_info(im)$height - tr_y,                 color = factor(selected))) +   annotation_custom(g, -Inf, Inf, -Inf, Inf) +   geom_point() +   scale_x_continuous(limits = c(0, image_info(im)$width), expand = c(0, 0)) +   scale_y_continuous(limits = c(0, image_info(im)$height), expand = c(0, 0)) sessionInfo() ## R version 4.2.1 (2022-06-23) ## Platform: x86_64-apple-darwin13.4.0 (64-bit) ## Running under: macOS Big Sur ... 10.16 ##  ## Matrix products: default ## BLAS/LAPACK: /Users/ludviglarsson/miniconda3/envs/R4.2/lib/libopenblasp-r0.3.21.dylib ##  ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ##  ## attached base packages: ## [1] grid      stats     graphics  grDevices utils     datasets  methods   ## [8] base      ##  ## other attached packages: ## [1] jsonlite_1.8.3     magick_2.7.3       semla_1.0.0        ggplot2_3.4.1      ## [5] dplyr_1.1.0        SeuratObject_4.1.3 Seurat_4.3.0       ##  ## loaded via a namespace (and not attached): ##   [1] Rtsne_0.16             colorspace_2.0-3       deldir_1.0-6           ##   [4] ellipsis_0.3.2         ggridges_0.5.3         rprojroot_2.0.3        ##   [7] fs_1.5.2               spatstat.data_3.0-0    rstudioapi_0.14        ##  [10] farver_2.1.1           leiden_0.4.2           listenv_0.8.0          ##  [13] ggrepel_0.9.3          fansi_1.0.3            codetools_0.2-18       ##  [16] splines_4.2.1          cachem_1.0.6           knitr_1.39             ##  [19] zeallot_0.1.0          polyclip_1.10-0        ica_1.0-3              ##  [22] cluster_2.1.4          png_0.1-7              uwot_0.1.14            ##  [25] spatstat.sparse_3.0-0  shiny_1.7.4            sctransform_0.3.5      ##  [28] compiler_4.2.1         httr_1.4.4             Matrix_1.5-3           ##  [31] fastmap_1.1.0          lazyeval_0.2.2         cli_3.4.1              ##  [34] later_1.3.0            htmltools_0.5.4        tools_4.2.1            ##  [37] igraph_1.3.4           gtable_0.3.0           glue_1.6.2             ##  [40] RANN_2.6.1             reshape2_1.4.4         Rcpp_1.0.9             ##  [43] scattermore_0.8        jquerylib_0.1.4        pkgdown_2.0.6          ##  [46] vctrs_0.5.2            nlme_3.1-159           spatstat.explore_3.0-5 ##  [49] progressr_0.10.1       lmtest_0.9-40          spatstat.random_3.0-1  ##  [52] xfun_0.32              stringr_1.5.0          globals_0.16.0         ##  [55] mime_0.12              miniUI_0.1.1.1         lifecycle_1.0.3        ##  [58] irlba_2.3.5            goftest_1.2-3          future_1.27.0          ##  [61] MASS_7.3-58.1          zoo_1.8-10             scales_1.2.1           ##  [64] ragg_1.2.2             promises_1.2.0.1       spatstat.utils_3.0-1   ##  [67] parallel_4.2.1         RColorBrewer_1.1-3     yaml_2.3.5             ##  [70] memoise_2.0.1          reticulate_1.26        pbapply_1.5-0          ##  [73] gridExtra_2.3          sass_0.4.2             stringi_1.7.8          ##  [76] highr_0.9              desc_1.4.1             rlang_1.0.6            ##  [79] pkgconfig_2.0.3        systemfonts_1.0.4      matrixStats_0.62.0     ##  [82] evaluate_0.16          lattice_0.20-45        tensor_1.5             ##  [85] ROCR_1.0-11            purrr_1.0.1            labeling_0.4.2         ##  [88] patchwork_1.1.2        htmlwidgets_1.5.4      cowplot_1.1.1          ##  [91] tidyselect_1.2.0       parallelly_1.32.1      RcppAnnoy_0.0.19       ##  [94] plyr_1.8.7             magrittr_2.0.3         R6_2.5.1               ##  [97] generics_0.1.3         DBI_1.1.3              withr_2.5.0            ## [100] pillar_1.8.1           fitdistrplus_1.1-8     abind_1.4-5            ## [103] survival_3.4-0         sp_1.5-1               tibble_3.1.8           ## [106] future.apply_1.9.0     KernSmooth_2.23-20     utf8_1.2.2             ## [109] spatstat.geom_3.0-3    plotly_4.10.0          rmarkdown_2.15         ## [112] data.table_1.14.2      forcats_0.5.2          digest_0.6.29          ## [115] xtable_1.8-4           dbscan_1.1-10          tidyr_1.3.0            ## [118] httpuv_1.6.5           textshaping_0.3.6      munsell_0.5.0          ## [121] viridisLite_0.4.1      bslib_0.4.0            shinyjs_2.1.0"},{"path":"https://ludvigla.github.io/semla/articles/mask_images.html","id":"load-data","dir":"Articles","previous_headings":"","what":"Load data","title":"Mask images","text":"First need load 10x Visium data. ’ll use mouse brain tissue dataset mouse colon dataset shipped semla. plot H&E images, can see entire capture area shown, including fiducials (dots marks edges capture area).","code":"# Load data se_mbrain <- readRDS(file = system.file(\"extdata\",                                          \"mousebrain/se_mbrain\",                                          package = \"semla\")) se_mbrain$sample_id <- \"mousebrain\" se_mcolon <- readRDS(file = system.file(\"extdata\",                                          \"mousecolon/se_mcolon\",                                          package = \"semla\")) se_mcolon$sample_id <- \"mousecolon\" se_merged <- MergeSTData(se_mbrain, se_mcolon) |>    LoadImages() ImagePlot(se_merged)"},{"path":"https://ludvigla.github.io/semla/articles/mask_images.html","id":"mask-images","dir":"Articles","previous_headings":"","what":"Mask images","title":"Mask images","text":"MaskImages makes possible remove background:  masking H&E images Seurat object created semla, “raw” image replaced, meaning plot functions MapFeatures MapLabels now use masked image instead.  want use original H&E images, can simply reload LoadImages.","code":"se_merged <- se_merged |>    MaskImages()  ImagePlot(se_merged) MapFeatures(se_merged, features = c(\"Th\", \"Il22ra2\"), image_use = \"raw\",              override_plot_dims = TRUE, colors = RColorBrewer::brewer.pal(n = 9, name = \"Spectral\") |> rev()) # Reload images from source files se_merged <- LoadImages(se_merged)"},{"path":"https://ludvigla.github.io/semla/articles/mask_images.html","id":"notes-about-he-masking","dir":"Articles","previous_headings":"","what":"Notes about H&E masking","title":"Mask images","text":"Masking always trivial task MaskImages might fail, particular faced one following issues: presence staining artefacts using stains H&E presence bubbles types speckles/dust tissues low contrast background, e.g. adipose tissue image loaded high resolution","code":""},{"path":"https://ludvigla.github.io/semla/articles/mask_images.html","id":"custom-masking-advanced","dir":"Articles","previous_headings":"Notes about H&E masking","what":"Custom masking (advanced)","title":"Mask images","text":"MaskImages fails, possible mask images manually, requires knowledge image processing. simple example one can mask mouse brain tissue section using magick R package:  results perfect still speckles background parts tissue section masked. even simple approach like can give decent results! processing done using R package magick package able manipulate images get pretty much result want. package vignette good resource get started: magick intro masked image, can convert back raster object place Seurat object. Now working 1 tissue section, multiple tissue sections need make sure list raster objects contains 1 image per sample correct order. Also, adjust dimensions image!!! exactly dimensions images started otherwise, spots longer aligned properly.   semla: 1.0.0","code":"# Fetch H&E rasters  mcolon_rasters <- se_mcolon |> LoadImages() |> GetImages()  # Load image as a magick-image object image <- image_read(mcolon_rasters[[1]])  # Convert image to CMYK colorspace and extract the magenta channel im_magenta <- image |>     image_convert(colorspace = \"cmyk\") |>     image_channel(channel = \"Magenta\")  # Add blur effect to image and threshold image im_threshold <- im_magenta |>     image_blur(sigma = 2) |>     image_threshold(type = \"black\", threshold = \"20%\") |>     image_threshold(type = \"white\", threshold = \"20%\")   # Mask H&E by combining H&E image with mask mask <- im_threshold |>    image_transparent(color = \"black\") im_composite <- image_composite(mask, image)  # Plot images par(mfrow = c(2, 2), mar = c(0, 0, 0, 0)) image |> as.raster() |> plot() title(\"H&E image\", line = -2) im_magenta |> as.raster() |> plot() title(\"Magenta color channel\", col.main = \"white\", line = -2) im_threshold |> as.raster() |> plot() title(\"Image mask\", col.main = \"white\", line = -2) im_composite |> as.raster() |> plot() title(\"Masked H&E image\", line = -2) se_mcolon@tools$Staffli@rasterlists$raw <- list(as.raster(im_composite))  MapFeatures(se_mcolon, features = \"nFeature_Spatial\", image_use = \"raw\",              pt_alpha = 0.5, pt_size = 1.5) sessionInfo() ## R version 4.2.1 (2022-06-23) ## Platform: x86_64-apple-darwin13.4.0 (64-bit) ## Running under: macOS Big Sur ... 10.16 ##  ## Matrix products: default ## BLAS/LAPACK: /Users/ludviglarsson/miniconda3/envs/R4.2/lib/libopenblasp-r0.3.21.dylib ##  ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ## [1] magick_2.7.3       semla_1.0.0        ggplot2_3.4.1      dplyr_1.1.0        ## [5] SeuratObject_4.1.3 Seurat_4.3.0       ##  ## loaded via a namespace (and not attached): ##   [1] Rtsne_0.16             colorspace_2.0-3       deldir_1.0-6           ##   [4] ellipsis_0.3.2         ggridges_0.5.3         rprojroot_2.0.3        ##   [7] fs_1.5.2               spatstat.data_3.0-0    rstudioapi_0.14        ##  [10] farver_2.1.1           leiden_0.4.2           listenv_0.8.0          ##  [13] ggrepel_0.9.3          fansi_1.0.3            codetools_0.2-18       ##  [16] splines_4.2.1          cachem_1.0.6           knitr_1.39             ##  [19] zeallot_0.1.0          polyclip_1.10-0        jsonlite_1.8.3         ##  [22] ica_1.0-3              cluster_2.1.4          png_0.1-7              ##  [25] uwot_0.1.14            spatstat.sparse_3.0-0  shiny_1.7.4            ##  [28] sctransform_0.3.5      compiler_4.2.1         httr_1.4.4             ##  [31] Matrix_1.5-3           fastmap_1.1.0          lazyeval_0.2.2         ##  [34] cli_3.4.1              later_1.3.0            htmltools_0.5.4        ##  [37] tools_4.2.1            igraph_1.3.4           gtable_0.3.0           ##  [40] glue_1.6.2             RANN_2.6.1             reshape2_1.4.4         ##  [43] Rcpp_1.0.9             scattermore_0.8        jquerylib_0.1.4        ##  [46] pkgdown_2.0.6          vctrs_0.5.2            nlme_3.1-159           ##  [49] spatstat.explore_3.0-5 progressr_0.10.1       lmtest_0.9-40          ##  [52] spatstat.random_3.0-1  xfun_0.32              stringr_1.5.0          ##  [55] globals_0.16.0         mime_0.12              miniUI_0.1.1.1         ##  [58] lifecycle_1.0.3        irlba_2.3.5            goftest_1.2-3          ##  [61] future_1.27.0          MASS_7.3-58.1          zoo_1.8-10             ##  [64] scales_1.2.1           ragg_1.2.2             promises_1.2.0.1       ##  [67] spatstat.utils_3.0-1   parallel_4.2.1         RColorBrewer_1.1-3     ##  [70] yaml_2.3.5             memoise_2.0.1          reticulate_1.26        ##  [73] pbapply_1.5-0          gridExtra_2.3          sass_0.4.2             ##  [76] stringi_1.7.8          highr_0.9              desc_1.4.1             ##  [79] rlang_1.0.6            pkgconfig_2.0.3        systemfonts_1.0.4      ##  [82] matrixStats_0.62.0     evaluate_0.16          lattice_0.20-45        ##  [85] tensor_1.5             ROCR_1.0-11            purrr_1.0.1            ##  [88] labeling_0.4.2         patchwork_1.1.2        htmlwidgets_1.5.4      ##  [91] cowplot_1.1.1          tidyselect_1.2.0       parallelly_1.32.1      ##  [94] RcppAnnoy_0.0.19       plyr_1.8.7             magrittr_2.0.3         ##  [97] R6_2.5.1               generics_0.1.3         DBI_1.1.3              ## [100] withr_2.5.0            pillar_1.8.1           fitdistrplus_1.1-8     ## [103] abind_1.4-5            survival_3.4-0         sp_1.5-1               ## [106] tibble_3.1.8           future.apply_1.9.0     KernSmooth_2.23-20     ## [109] utf8_1.2.2             spatstat.geom_3.0-3    plotly_4.10.0          ## [112] rmarkdown_2.15         grid_4.2.1             data.table_1.14.2      ## [115] forcats_0.5.2          digest_0.6.29          xtable_1.8-4           ## [118] dbscan_1.1-10          tidyr_1.3.0            httpuv_1.6.5           ## [121] textshaping_0.3.6      munsell_0.5.0          viridisLite_0.4.1      ## [124] bslib_0.4.0            shinyjs_2.1.0"},{"path":"https://ludvigla.github.io/semla/articles/numeric_features.html","id":"load-data","dir":"Articles","previous_headings":"","what":"Load data","title":"Visualization of numeric features","text":"First need load 10x Visium data. ’ll use mouse brain tissue dataset mouse colon dataset shipped semla.","code":"# Load data se_mbrain <- readRDS(file = system.file(\"extdata\",                                          \"mousebrain/se_mbrain\",                                          package = \"semla\")) se_mbrain$sample_id <- \"mousebrain\" se_mcolon <- readRDS(file = system.file(\"extdata\",                                          \"mousecolon/se_mcolon\",                                          package = \"semla\")) se_mcolon$sample_id <- \"mousecolon\" se <- MergeSTData(se_mbrain, se_mcolon)"},{"path":"https://ludvigla.github.io/semla/articles/numeric_features.html","id":"map-numeric-features","dir":"Articles","previous_headings":"","what":"Map numeric features","title":"Visualization of numeric features","text":"Let’s get started MapFeatures(). basic usage map gene expression spatially:  can also plot numeric features present within meta.data slot, quality metrics ‘nCount_Spatial’ ‘nFeature_Spatial’. view distribution selected feature per sample, function MapFeaturesSummary() can used add subplot next spatial plot (choose histogram, box, violin, density plot).","code":"cols <- viridis::rocket(11, direction = -1)  p <- MapFeatures(se,                   features = c(\"Th\", \"Clu\"),                   colors = cols) p p <- MapFeaturesSummary(se,                          features = \"nFeature_Spatial\",                          subplot_type = \"violin\",                         colors = cols) p"},{"path":"https://ludvigla.github.io/semla/articles/numeric_features.html","id":"map-dimensionality-reduction-vectors","dir":"Articles","previous_headings":"","what":"Map dimensionality reduction vectors","title":"Visualization of numeric features","text":"MapFeatures handles type numeric features can fetched using Seurat function FetchData(). includes latent vectors dimensionality reduction methods. plotting numeric features centered 0, appropriate also center color scale select ‘divergent’ color palette.","code":"se <- se |>    ScaleData() |>    FindVariableFeatures() |>    RunPCA() ## Centering and scaling data matrix ## PC_ 1  ## Positive:  Ptgds, Snap25, Rtn1, Cck, Nrgn, Eef1a2, Snca, Olfm1, Uchl1, Mobp  ##     Mbp, Plp1, Stmn2, Fabp5, Hpca, Pvalb, Nnat, Nptxr, Cpne6, Npy  ##     Clu, Mag, Pcp4, Apod, Scg2, Crym, Hbb-bs, Mal, Arc, Mog  ## Negative:  Car1, Cyp2c55, Cnn1, Aqp8, Dsp, Emp1, 1810065E05Rik, Tgm3, Acta2, Cd24a  ##     Hmgcs2, Tagln, Fabp2, Col1a2, Myh11, H2-Aa, Actg2, S100g, Car4, Pyy  ##     Ces2e, Apol10a, Mgat4c, Prdx6, Slc37a2, Prkcd, Ang4, Cd74, Atp12a, Myl9  ## PC_ 2  ## Positive:  Slc6a3, Th, Mog, Chrna6, Apod, Mag, Drd2, Opalin, En1, Mal  ##     Lhx1os, Aldh1a1, Slc18a2, Slc10a4, Mobp, Cnp, Dlk1, Plp1, Ret, Sncg  ##     Spp1, Mbp, Ddc, Ptgds, Tcf7l2, Calb2, Pitx2, Tnnt1, Pvalb, Slc13a4  ## Negative:  Nov, Lamp5, Egr1, Nr4a1, Crym, Neurod6, Arc, Nptxr, Myh7, Coro1a  ##     Sst, Cort, Npy, Tmsb4x, Spink8, Cpne6, Grp, Mfge8, Nrgn, Rprm  ##     Fibcd1, Myl4, Hpca, Chgb, Vip, Snca, Cck, Tac2, Olfm1, Trh  ## PC_ 3  ## Positive:  Slc18a2, En1, Th, Slc10a4, Slc6a3, Chrna6, Dlk1, Sncg, Drd2, Ret  ##     Ddc, Calb2, Cpne7, Hpcal1, Dcn, Scg2, Nnat, Vip, Coro1a, Prph  ##     Stmn2, Nos1, Mfge8, Myh7, Ecel1, Tmsb4x, Htr3a, Trh, Snca, Tac1  ## Negative:  Myoc, Hbb-bt, Hba-a1, Mog, Opalin, Gfap, Slc13a4, Mag, Mal, Mobp  ##     Apod, Pvalb, Ptgds, C1ql2, Tnnt1, Reg3b, Plp1, Lhx1os, Tcf7l2, Hba-a2  ##     Mbp, Iapp, Fabp2, Hbb-bs, Fmod, Defb37, Myl4, Car1, Cyp2c55, Spp1  ## PC_ 4  ## Positive:  H2-DMb2, Ly6d, Ighd, Il22ra2, Cd52, Cd79b, Cd79a, Ighm, Clu, C3  ##     Spib, Mfge8, Lyz2, Ccl20, Ubd, Cnp, Iglc2, Hba-a2, Ly6g, Ighg2b  ##     Myoc, H2-Eb1, Hbb-bs, Hbb-bt, Hba-a1, Apod, Slc13a4, Cd74, Vtn, Fabp5  ## Negative:  En1, Cyp4b1, Ces1g, Chrna6, Slc10a2, Defb37, Th, Sct, Slc18a2, Slc10a4  ##     Slc6a3, Slc51a, Nov, Iapp, Drd2, Tmigd1, Fabp2, Dlk1, Reg3b, Myh7  ##     Cpne7, 1810065E05Rik, Cyp2d26, Apol10a, Cyp2c55, Emp1, Spink8, Nts, Mgat4c, S100g  ## PC_ 5  ## Positive:  Trbc2, Myl4, Arc, Egr1, Nr4a1, Ighm, Coro1a, Lamp5, Ly6d, Cplx3  ##     Ighd, Th, En1, H2-DMb2, Neurod6, Opalin, Cd79b, Chrna6, Cd79a, Il22ra2  ##     Mobp, Mog, Spib, Drd2, Pvalb, Cnp, Mal, Mag, Cd52, Slc6a3  ## Negative:  Myoc, Slc13a4, Fmod, Dcn, Gfap, Hba-a2, Hbb-bt, Hba-a1, Vtn, Trh  ##     Ecel1, Hbb-bs, Slc6a20a, Nnat, Mgp, Nos1, Spp1, Fibcd1, Htr3a, Vgll3  ##     Cpne7, Calb2, Hpcal1, C1ql2, Spink8, Crym, Myl9, Lypd1, Rcn1, Cartpt MapFeatures(se,              features = \"PC_2\",              center_zero = TRUE,              section_number = 1,              pt_size = 2,             colors = RColorBrewer::brewer.pal(n = 11, name = \"RdBu\") |> rev())"},{"path":"https://ludvigla.github.io/semla/articles/numeric_features.html","id":"overlay-maps-on-images","dir":"Articles","previous_headings":"","what":"Overlay maps on images","title":"Visualization of numeric features","text":"want create map H&E images can setting image_use = raw. can , need load images Seurat object:  Right now ’s quite difficult see tissue underneath spots. can add opacity colors scaled feature values make spots low expression transparent:","code":"se <- LoadImages(se, verbose = FALSE) cols <- RColorBrewer::brewer.pal(11, \"Spectral\") |> rev()  p <- MapFeatures(se,                   features = c(\"Th\", \"Clu\"),                   image_use = \"raw\",                   colors = cols) p p <- MapFeatures(se,                   features = c(\"Th\", \"Clu\"),                   image_use = \"raw\",                   colors = cols,                   scale_alpha = TRUE) p"},{"path":"https://ludvigla.github.io/semla/articles/numeric_features.html","id":"crop-image","dir":"Articles","previous_headings":"","what":"Crop image","title":"Visualization of numeric features","text":"can crop images manually defining crop_area. crop_area vector length four defining opposite corners rectangle, x- y-axes defined 0-1. order easily see rectangle defined can get help adding grid plot.  Clu gene expression reveals area lymphoid tissue colon sample. Now want crop GALT tissue mouse colon sample can cut image : x-left = 0.45 y-left = 0.55 x-right = 0.65 y-right = 0.7 Provide coordinates crop_area argument order (x-left, y-left, x-right, y-right).  can patch together nice figure showing expression global level inside GALT:   semla: 1.0.0","code":"p <- MapFeatures(se,                   section_number = 2,                   features = \"Clu\",                   image_use = \"raw\",                   color = cols,                   pt_alpha = 0.5) &   labs(x=\"x-axis\", y=\"y-axis\") &   theme(panel.grid.major = element_line(linetype = \"dashed\"),          axis.text = element_text(),          axis.title = element_text()) p p <- MapFeatures(se, features = c(\"Cd79a\", \"Clu\"), image_use = \"raw\",                   pt_size = 3, section_number = 2,                   color = cols, crop_area = c(0.45, 0.55, 0.65, 0.7)) p p_global <- MapFeatures(se,                          features = c(\"Cd79a\", \"Clu\"),                          image_use = \"raw\",                          scale_alpha = TRUE,                         pt_size = 1,                          section_number = 2,                          color = cols,                          override_plot_dims = TRUE)  p_GALT <- MapFeatures(se,                        features = c(\"Cd79a\", \"Clu\"),                        image_use = \"raw\",                        scale_alpha = TRUE,                        pt_size = 3,                        section_number = 2,                        color = cols,                        crop_area = c(0.45, 0.55, 0.65, 0.7)) &   theme(plot.title = element_blank(),          plot.subtitle = element_blank(),          legend.position = \"none\")  (p_global / p_GALT)"},{"path":"https://ludvigla.github.io/semla/articles/radial_distances.html","id":"load-data","dir":"Articles","previous_headings":"","what":"Load data","title":"Radial distances","text":"First need download 10x Visium data. ’ll use breast cancer dataset provided 10x:","code":"# Create an empty folder in current directory dir.create(paste0(\"./bc_visium\"))  download.file(url = \"https://cf.10xgenomics.com/samples/spatial-exp/1.0.0/V1_Breast_Cancer_Block_A_Section_1/V1_Breast_Cancer_Block_A_Section_1_filtered_feature_bc_matrix.h5\", destfile = \"./bc_visium/filtered_feature_bc_matrix.h5\") download.file(url = \"https://cf.10xgenomics.com/samples/spatial-exp/1.0.0/V1_Breast_Cancer_Block_A_Section_1/V1_Breast_Cancer_Block_A_Section_1_spatial.tar.gz\", destfile = \"./bc_visium/spatial.tar.gz\") untar(tarfile = \"./bc_visium/spatial.tar.gz\",        exdir =  \"./bc_visium/\") file.remove(\"./bc_visium/spatial.tar.gz\") samples <- \"bc_visium/filtered_feature_bc_matrix.h5\" imgs <- \"bc_visium/spatial/tissue_hires_image.png\" spotfiles <- \"bc_visium/spatial/tissue_positions_list.csv\" json <- \"bc_visium/spatial/scalefactors_json.json\"  # Create a tibble/data.frame with file paths infoTable <- tibble(samples, imgs, spotfiles, json)  # Create Seurat object se <- ReadVisiumData(infoTable = infoTable)"},{"path":"https://ludvigla.github.io/semla/articles/radial_distances.html","id":"data","dir":"Articles","previous_headings":"","what":"Data","title":"Radial distances","text":"Next, ’ll use Seurat run simple data processing/analysis workflow: normalize data scale data find variable features run dimensionality reduction PCA Create SNN graph Cluster data Now identified clusters data based spot expression profiles, can plot clusters spatially MapLabels.  purpose analysis, just need define region interest tissue sections. just well use tissue morphology basis define region. plot , can see clusters confined distinct regions, example cluster 9:","code":"se <- se |>   NormalizeData() |>   ScaleData() |>   FindVariableFeatures() |>   RunPCA() |>   FindNeighbors(reduction = \"pca\", dims = 1:30) |>   FindClusters() ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ##  ## Number of nodes: 3813 ## Number of edges: 141050 ##  ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8713 ## Number of communities: 13 ## Elapsed time: 0 seconds se <- LoadImages(se) ## ## ── Loading H&E images ── ## ## ℹ Loading image from /Users/ludviglarsson/10x_data/BC_block_S1/spatial/tissue_hires_image.png ## ℹ Scaled image from 2000x2000 to 400x400 pixels ## ℹ Saving loaded H&E images as 'rasters' in Seurat object MapLabels(se, column_name = \"seurat_clusters\",            image_use = \"raw\", pt_alpha = 0.6, pt_size = 2) +   plot_layout(guides = \"collect\") &   theme(legend.position = \"right\") &   guides(fill = guide_legend(override.aes = list(size = 3), ncol = 2)) se$cluster_9 <- ifelse(se$seurat_clusters %in% \"9\", \"9\", NA) MapLabels(se, column_name = \"cluster_9\", override_plot_dims = TRUE,            image_use = \"raw\", drop_na = TRUE, pt_size = 2) +   plot_layout(guides = \"collect\") &   theme(legend.position = \"right\") &   guides(fill = guide_legend(override.aes = list(size = 3), ncol = 2))"},{"path":"https://ludvigla.github.io/semla/articles/radial_distances.html","id":"disconnect-regions","dir":"Articles","previous_headings":"","what":"Disconnect regions","title":"Radial distances","text":"Cluster 9 concentrated region rich cancer cells also spots parts tissue. point might interested one regions case can split cluster_9 spatially disconnected compartments. purpose, can use DisconnectRegions:  spatially disconnected region cluster 9 now label, order largest smallest. Singletons spots completely isolated spots label. One course achieve result manual selection spots, example using FeatureViewer function, DisconnectRegions makes easier automate. point, might entirely clear one need feature, hopefully make sense look ‘radial distances’ next section.","code":"se <- DisconnectRegions(se, column_name = \"seurat_clusters\", selected_groups = \"9\") ## ℹ Extracting disconnected components for group '9' ## ℹ Detecting disconnected regions for 178 spots ## Loading required namespace: tidygraph ## ℹ Found 5 disconnected graph(s) in data ## ℹ Sorting disconnected regions by decreasing size ## ℹ Found 2 singletons in data ## →   These will be labeled as 'singletons' MapLabels(se, column_name = \"9_split\", override_plot_dims = TRUE,            image_use = \"raw\", drop_na = TRUE, pt_size = 2) +   plot_layout(guides = \"collect\") &   theme(legend.position = \"right\") &   guides(fill = guide_legend(override.aes = list(size = 3), ncol = 2))"},{"path":"https://ludvigla.github.io/semla/articles/radial_distances.html","id":"radial-distance","dir":"Articles","previous_headings":"","what":"Radial distance","title":"Radial distances","text":"Imagine interested looking expression certain genes function distance region interest. can compute distances region interest (ROI) using RadialDistances. ’ll use cluster 3 ROI computation.  can illustrate results coloring spots based radial distances cluster “3”:  distances calculated border ROI, positive values represent radial distances ROI negative values represent radial distances towards center ROI.","code":"se$cluster_3 <- ifelse(se$seurat_clusters %in% \"3\", \"3\", NA) MapLabels(se, column_name = \"cluster_3\", override_plot_dims = TRUE,            image_use = \"raw\", drop_na = TRUE, pt_size = 2) +   theme(legend.position = \"right\") &   guides(fill = guide_legend(override.aes = list(size = 5), ncol = 2)) se <- RadialDistance(se, column_name = \"seurat_clusters\", selected_groups = \"3\") ## ℹ Running calculations for sample 1 ## ℹ Calculating radial distances for group '3' ## ℹ Removing 3 spots with 0 neighbors. ## ℹ Extracting border spots from a region with 413 spots ## →   Detected 75 spots on borders ## →   Detected 413 spots inside borders ## →   Detected 3400 spots outside borders ## ✔ Returning radial distances MapFeatures(se, features = \"r_dist_3\", center_zero = TRUE, pt_size = 2,              colors = RColorBrewer::brewer.pal(n = 11, name = \"RdBu\") |> rev(),             override_plot_dims = TRUE)"},{"path":"https://ludvigla.github.io/semla/articles/radial_distances.html","id":"pixel-coordinates","dir":"Articles","previous_headings":"Radial distance","what":"Pixel coordinates","title":"Radial distances","text":"distances given pixels relative image pixels coordinates loaded creating Seurat object. know conversion factor pixels original H&E image microns, can easily convert radial distances microns. example data, center--center spot distance 273 pixels image know actual center--center spot distance 100 microns. Alternatively, can set convert_to_microns = TRUE make RadialDistance conversion . Note conversion assumes working Visium data least spots adjacent dataset.","code":"se$r_dist_3 <- (100/273)*se$r_dist_3 se <- RadialDistance(se, column_name = \"seurat_clusters\",                       selected_groups = \"3\", convert_to_microns = TRUE) ## ℹ Running calculations for sample 1 ## ℹ Calculating radial distances for group '3' ## ℹ Removing 3 spots with 0 neighbors. ## ℹ Extracting border spots from a region with 413 spots ## →   Detected 75 spots on borders ## →   Detected 413 spots inside borders ## →   Detected 3400 spots outside borders ## ✔ Returning radial distances"},{"path":"https://ludvigla.github.io/semla/articles/radial_distances.html","id":"convert-radial-distances","dir":"Articles","previous_headings":"Radial distance","what":"Convert radial distances","title":"Radial distances","text":"scale distances somewhat inconvenient color scale, can apply transformation make easier visualize, example square root distance:  distances, can now explore expression certain genes function distance ROI. interested microenvironment outside cluster 3, filter data maximum radial distance 1000 microns outside cluster 3. red dashed line represents tumor border.  can see expression CRISP3 high inside cluster “3” declines rapidly border whereas IGLC2 show opposite trend. can also visualize trends spatially:  bother using radial distances? access information makes possible identify genes change distance ROI. example , example identify genes whose expression decrease increase distance tumor gives us useful tool characterize tumor microenvironment. perhaps even useful application explore relative abundance cell types around inside tumor border, can compute cell type proportions data fist.","code":"se$r_dist_3_sqrt <- sign(se$r_dist_3)*sqrt(abs(se$r_dist_3)) MapFeatures(se, features = \"r_dist_3_sqrt\", center_zero = TRUE, pt_size = 2,              colors = RColorBrewer::brewer.pal(n = 11, name = \"RdBu\") |> rev(),             override_plot_dims = TRUE) sel_genes <- c(\"CRISP3\", \"IGLC2\")  se[[]] |>    bind_cols(FetchData(se, vars = sel_genes)) |>    filter(r_dist_3 < 1e3) |>    pivot_longer(all_of(sel_genes), names_to = \"variable\", values_to = \"value\") |>    ggplot(aes(r_dist_3, value, color = variable)) +     geom_smooth(method = \"gam\", formula = y ~ s(x, bs = \"cs\")) +     geom_vline(aes(xintercept = 0, color = \"border\"), linetype = \"dashed\") MapFeatures(SubsetSTData(se, expression = r_dist_3 < 1e3),              features = sel_genes, override_plot_dims = TRUE, scale_alpha = TRUE,             image_use = \"raw\", pt_size = 2)"},{"path":"https://ludvigla.github.io/semla/articles/radial_distances.html","id":"focused-search","dir":"Articles","previous_headings":"Radial distance","what":"Focused search","title":"Radial distances","text":"rarely case microenvironment homogeneous directions region interest. breast cancer tissue section, can clearly see tissue composition different depending direction look region interest. RadialDistance therefore provides option narrow search space predefined interval angles. plot (generated AnglePlot) give idea angles calculated certain region. ROI center defined taking median x, y coordinates spots ROI. angles defined clockwise 0° = right, 90° = , …","code":"AnglePlot(se, column_name = \"cluster_3\", selected_group = \"3\", pt_size = 2,           crop_area = c(0.2, 0.3, 1, 1), image_use = \"raw\", radius = 0.3, drop_na = TRUE)"},{"path":"https://ludvigla.github.io/semla/articles/radial_distances.html","id":"disconnected-regions","dir":"Articles","previous_headings":"Radial distance > Focused search","what":"Disconnected regions","title":"Radial distances","text":"proceed, note important ROI spatially connected. , RadialDistance complain finds disconnected components abort function. intended prevent users defining center outside ROI likely happen multiple ROIs present. doesn’t make much sense compute radial distances one center multiple centers present. Instead, can split disconnected components DisconnectRegions focus one ROI. Now idea angles defined, can provide interval angles narrow search area calculate radial distances. color scale plot represents radial distances tumor (cluster 3) center.  want go exploratory approach, can split radial distances slices setting angles_nbreaks. example , narrow search area angles 120-320 degrees split 6 even slices.  Inside Seurat object meta data slot, now three new columns: ‘angle_3’, ‘r_dist_3’ ‘intervals_3’. ‘intervals_3’ columns tells us slice spot belongs . data, can modify previous plot split slice. look genes (CRISP3 IGLC2), can see trends quite similar 6 directions:  However, trend varies substantially depending direction genes. can see expression along radial axis three genes. Depending direction, genes distinct expression profiles.  map expression genes spatially, quite clear genes expressed different niches microenvironment. fact, two “niches” mostly composed tumor cells. Hopefully, demonstration serve motivation carefully think radial distances used specific biological questions. tools provided semla easy adapt many different scenarios.   semla: 1.0.0","code":"se <- RadialDistance(se, column_name = \"seurat_clusters\", selected_groups = \"3\",                       angles = c(200, 240)) ## ℹ Running calculations for sample 1 ## ℹ Calculating radial distances for group '3' ## ℹ Removing 3 spots with 0 neighbors. ## ℹ Extracting border spots from a region with 413 spots ## →   Detected 75 spots on borders ## →   Detected 413 spots inside borders ## →   Detected 3400 spots outside borders ## ✔ Returning radial distances ## ℹ Setting search area between 200 and 240 degrees from region center MapFeatures(se, features = \"r_dist_3\", pt_size = 2) se <- RadialDistance(se, column_name = \"seurat_clusters\", selected_groups = \"3\",                      angles = c(120, 320), angles_nbreaks = 6) ## ℹ Running calculations for sample 1 ## ℹ Calculating radial distances for group '3' ## ℹ Removing 3 spots with 0 neighbors. ## ℹ Extracting border spots from a region with 413 spots ## →   Detected 75 spots on borders ## →   Detected 413 spots inside borders ## →   Detected 3400 spots outside borders ## ✔ Returning radial distances ## ℹ Setting search area between 120 and 320 degrees from region center ## ℹ Splitting search area into 6 interval(s) MapLabels(se, column_name = \"intervals_3\", pt_size = 2, drop_na = TRUE,           colors = RColorBrewer::brewer.pal(n = 6, name = \"Spectral\")) &   guides(fill = guide_legend(override.aes = list(size = 5), ncol = 3)) sel_genes <- c(\"CRISP3\", \"IGLC2\")  se[[]] |>    bind_cols(FetchData(se, vars = sel_genes)) |>    filter(r_dist_3 < 1e3) |>    pivot_longer(all_of(sel_genes), names_to = \"variable\", values_to = \"value\") |>    ggplot(aes(r_dist_3, value, color = variable)) +     geom_smooth(method = \"gam\", formula = y ~ s(x, bs = \"cs\")) +     geom_vline(aes(xintercept = 0, color = \"border\"), linetype = \"dashed\") +     facet_wrap(~ intervals_3, ncol = 3) +     theme_minimal() sel_genes <- c(\"PGM5-AS1\", \"CXCL14\", \"IGHG3\")  se[[]] |>    bind_cols(FetchData(se, vars = sel_genes)) |>    filter(r_dist_3 < 1e3) |>    pivot_longer(all_of(sel_genes), names_to = \"variable\", values_to = \"value\") |>    group_by(variable) |>    mutate(value_centered = value - mean(value)) |> # Note that the values have been centered   ggplot(aes(r_dist_3, value_centered, color = variable)) +     geom_smooth(method = \"gam\", formula = y ~ s(x, bs = \"cs\")) +     geom_vline(aes(xintercept = 0, color = \"border\"), linetype = \"dashed\") +     facet_wrap(~ intervals_3, ncol = 3) +     theme_minimal() MapFeatures(se, crop_area = c(0.45, 0.6, 0.8, 0.93),             features = sel_genes, scale_alpha = TRUE, ncol = 3,             image_use = \"raw\", pt_size = 1.5, colors = viridis::viridis(n = 9),             max_cutoff = 0.99) &   theme(legend.position = \"right\", legend.text = element_text(angle = 0)) sessionInfo() ## R version 4.2.1 (2022-06-23) ## Platform: x86_64-apple-darwin13.4.0 (64-bit) ## Running under: macOS Big Sur ... 10.16 ##  ## Matrix products: default ## BLAS/LAPACK: /Users/ludviglarsson/miniconda3/envs/R4.2/lib/libopenblasp-r0.3.21.dylib ##  ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ## [1] tidyr_1.3.0        scico_1.3.1        patchwork_1.1.2    tibble_3.1.8       ## [5] semla_1.0.0        ggplot2_3.4.1      dplyr_1.1.0        SeuratObject_4.1.3 ## [9] Seurat_4.3.0       ##  ## loaded via a namespace (and not attached): ##   [1] systemfonts_1.0.4      plyr_1.8.7             igraph_1.3.4           ##   [4] lazyeval_0.2.2         sp_1.5-1               splines_4.2.1          ##   [7] listenv_0.8.0          scattermore_0.8        digest_0.6.29          ##  [10] htmltools_0.5.4        viridis_0.6.2          magick_2.7.3           ##  [13] fansi_1.0.3            magrittr_2.0.3         memoise_2.0.1          ##  [16] tensor_1.5             cluster_2.1.4          ROCR_1.0-11            ##  [19] globals_0.16.0         matrixStats_0.62.0     pkgdown_2.0.6          ##  [22] spatstat.sparse_3.0-0  colorspace_2.0-3       ggrepel_0.9.3          ##  [25] textshaping_0.3.6      xfun_0.32              crayon_1.5.1           ##  [28] jsonlite_1.8.3         progressr_0.10.1       spatstat.data_3.0-0    ##  [31] zeallot_0.1.0          survival_3.4-0         zoo_1.8-10             ##  [34] glue_1.6.2             polyclip_1.10-0        gtable_0.3.0           ##  [37] leiden_0.4.2           future.apply_1.9.0     abind_1.4-5            ##  [40] scales_1.2.1           DBI_1.1.3              spatstat.random_3.0-1  ##  [43] miniUI_0.1.1.1         Rcpp_1.0.9             viridisLite_0.4.1      ##  [46] xtable_1.8-4           reticulate_1.26        bit_4.0.4              ##  [49] htmlwidgets_1.5.4      httr_1.4.4             RColorBrewer_1.1-3     ##  [52] ellipsis_0.3.2         ica_1.0-3              pkgconfig_2.0.3        ##  [55] farver_2.1.1           sass_0.4.2             uwot_0.1.14            ##  [58] deldir_1.0-6           utf8_1.2.2             labeling_0.4.2         ##  [61] tidyselect_1.2.0       rlang_1.0.6            reshape2_1.4.4         ##  [64] later_1.3.0            munsell_0.5.0          tools_4.2.1            ##  [67] cachem_1.0.6           cli_3.4.1              dbscan_1.1-10          ##  [70] generics_0.1.3         ggridges_0.5.3         evaluate_0.16          ##  [73] stringr_1.5.0          fastmap_1.1.0          yaml_2.3.5             ##  [76] ragg_1.2.2             goftest_1.2-3          knitr_1.39             ##  [79] bit64_4.0.5            fs_1.5.2               tidygraph_1.2.2        ##  [82] fitdistrplus_1.1-8     purrr_1.0.1            RANN_2.6.1             ##  [85] pbapply_1.5-0          future_1.27.0          nlme_3.1-159           ##  [88] mime_0.12              hdf5r_1.3.5            compiler_4.2.1         ##  [91] rstudioapi_0.14        plotly_4.10.0          png_0.1-7              ##  [94] spatstat.utils_3.0-1   bslib_0.4.0            stringi_1.7.8          ##  [97] highr_0.9              desc_1.4.1             forcats_0.5.2          ## [100] lattice_0.20-45        Matrix_1.5-3           shinyjs_2.1.0          ## [103] vctrs_0.5.2            pillar_1.8.1           lifecycle_1.0.3        ## [106] spatstat.geom_3.0-3    lmtest_0.9-40          jquerylib_0.1.4        ## [109] RcppAnnoy_0.0.19       data.table_1.14.2      cowplot_1.1.1          ## [112] irlba_2.3.5            httpuv_1.6.5           R6_2.5.1               ## [115] promises_1.2.0.1       KernSmooth_2.23-20     gridExtra_2.3          ## [118] parallelly_1.32.1      codetools_0.2-18       MASS_7.3-58.1          ## [121] rprojroot_2.0.3        withr_2.5.0            sctransform_0.3.5      ## [124] mgcv_1.8-40            parallel_4.2.1         grid_4.2.1             ## [127] rmarkdown_2.15         Rtsne_0.16             spatstat.explore_3.0-5 ## [130] shiny_1.7.4"},{"path":"https://ludvigla.github.io/semla/articles/region_neighbors.html","id":"region-neighbors","dir":"Articles","previous_headings":"","what":"Region neighbors","title":"Region neighbors","text":"previous tutorial calculated radial distances center tumor region. distances can easily used define ‘tumor microenvironment’ well leading edge tumor. interested finding spots located border region interest, can use RegionNeighbors() function instead. RegionNeighbors automatically detects spots located inside outside border . Let’s demonstrate works example. want find spots neighbors cluster 3, set column_name = \"seurat_clusters\" column_labels = \"3\": meta.data slot, now new column called “nb_to_3”, short “neighbors cluster 3”. plot , can see column provides information spots outside border cluster 3.  can tweak function identify inner border instead, .e. spots located “tumor edge”. run RegionNeighbors mode=\"inner\", get column called inner_border_3 tells us spots “tumor edge”.  want get inner outer borders, set mode=\"inner_outer. NB: run mode returns “outer” border spots, prefix returned column “nb_to_” default. behavior can overridden setting column_key=...  last mode (mode=\"all_inner_outer\") allows us select outer border spots keeping spots belonging cluster interest.  One example information can used run DE test outer inner borders find genes differentially expressed spots just outside “tumor edge”:  want select wider band spots surrounding ROI, can calculate radial distances set thresholds instead.  semla: 1.0.0","code":"se <- RegionNeighbors(se,                        column_name = \"seurat_clusters\",                        column_labels = \"3\") ## ℹ Finding neighboring spots for '3' ## →   Excluding neighbors from the same group ## →   169 neighbors left ## →   Returning neighbors MapLabels(se, crop_area = c(0.45, 0.6, 0.8, 0.93),           column_name = \"nb_to_3\", drop_na = TRUE,           image_use = \"raw\", pt_size = 3) se <- RegionNeighbors(se,                        column_name = \"seurat_clusters\",                        column_labels = \"3\",                        mode = \"inner\") ## ℹ Finding neighboring spots for '3' ## →   Returning neighbors MapLabels(se,            crop_area = c(0.45, 0.6, 0.8, 0.93),           column_name = \"inner_border_3\",           image_use = \"raw\",            pt_size = 3,            drop_na = TRUE) se <- RegionNeighbors(se, column_name = \"seurat_clusters\",                        column_labels = \"3\", mode = \"inner_outer\") ## ℹ Finding neighboring spots for '3' ## →   Returning neighbors MapLabels(se, crop_area = c(0.45, 0.6, 0.8, 0.93),           column_name = \"nb_to_3\",           image_use = \"raw\", pt_size = 3, drop_na = TRUE) se <- RegionNeighbors(se, column_name = \"seurat_clusters\", column_key = \"(all)nb_to_\",                       column_labels = \"3\", mode = \"all_inner_outer\") ## ℹ Finding neighboring spots for '3' ## →   Returning neighbors MapLabels(se, crop_area = c(0.45, 0.6, 0.8, 0.93),           column_name = \"(all)nb_to_3\",           image_use = \"raw\", pt_size = 3, drop_na = TRUE) border_markers <- FindMarkers(se, ident.1 = \"nb_to_3\",                                ident.2 = \"3\", group.by = \"nb_to_3\")  # Filter results border_markers_up <- border_markers |>    filter(p_val_adj < 0.01, avg_log2FC > 0) |>    arrange(-avg_log2FC) |>    slice_head(n = 10)  # Subset Seurat object to include border spots se_border_spots <- SubsetSTData(se, expression = nb_to_3 %in% c(\"3\", \"nb_to_3\"))  # Violin plot VlnPlot(se_border_spots, features = rownames(border_markers_up), group.by = \"nb_to_3\") &   theme(axis.title = element_blank()) sessionInfo() ## R version 4.2.1 (2022-06-23) ## Platform: x86_64-apple-darwin13.4.0 (64-bit) ## Running under: macOS Big Sur ... 10.16 ##  ## Matrix products: default ## BLAS/LAPACK: /Users/ludviglarsson/miniconda3/envs/R4.2/lib/libopenblasp-r0.3.21.dylib ##  ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ## [1] STUtility2_0.1.0   patchwork_1.1.2    tibble_3.1.8       semla_1.0.0        ## [5] ggplot2_3.4.1      dplyr_1.1.0        SeuratObject_4.1.3 Seurat_4.3.0       ##  ## loaded via a namespace (and not attached): ##   [1] systemfonts_1.0.4      plyr_1.8.7             igraph_1.3.4           ##   [4] lazyeval_0.2.2         sp_1.5-1               splines_4.2.1          ##   [7] listenv_0.8.0          scattermore_0.8        digest_0.6.29          ##  [10] htmltools_0.5.4        magick_2.7.3           fansi_1.0.3            ##  [13] magrittr_2.0.3         memoise_2.0.1          tensor_1.5             ##  [16] cluster_2.1.4          ROCR_1.0-11            limma_3.52.3           ##  [19] globals_0.16.0         matrixStats_0.62.0     pkgdown_2.0.6          ##  [22] spatstat.sparse_3.0-0  colorspace_2.0-3       ggrepel_0.9.3          ##  [25] textshaping_0.3.6      xfun_0.32              crayon_1.5.1           ##  [28] jsonlite_1.8.3         progressr_0.10.1       spatstat.data_3.0-0    ##  [31] zeallot_0.1.0          survival_3.4-0         zoo_1.8-10             ##  [34] glue_1.6.2             polyclip_1.10-0        gtable_0.3.0           ##  [37] leiden_0.4.2           future.apply_1.9.0     abind_1.4-5            ##  [40] scales_1.2.1           DBI_1.1.3              spatstat.random_3.0-1  ##  [43] miniUI_0.1.1.1         Rcpp_1.0.9             viridisLite_0.4.1      ##  [46] xtable_1.8-4           reticulate_1.26        htmlwidgets_1.5.4      ##  [49] httr_1.4.4             RColorBrewer_1.1-3     ellipsis_0.3.2         ##  [52] ica_1.0-3              pkgconfig_2.0.3        farver_2.1.1           ##  [55] sass_0.4.2             uwot_0.1.14            deldir_1.0-6           ##  [58] utf8_1.2.2             labeling_0.4.2         tidyselect_1.2.0       ##  [61] rlang_1.0.6            reshape2_1.4.4         later_1.3.0            ##  [64] munsell_0.5.0          tools_4.2.1            cachem_1.0.6           ##  [67] cli_3.4.1              dbscan_1.1-10          generics_0.1.3         ##  [70] ggridges_0.5.3         evaluate_0.16          stringr_1.5.0          ##  [73] fastmap_1.1.0          yaml_2.3.5             ragg_1.2.2             ##  [76] goftest_1.2-3          knitr_1.39             fs_1.5.2               ##  [79] fitdistrplus_1.1-8     purrr_1.0.1            RANN_2.6.1             ##  [82] pbapply_1.5-0          future_1.27.0          nlme_3.1-159           ##  [85] mime_0.12              ggrastr_1.0.1          compiler_4.2.1         ##  [88] rstudioapi_0.14        beeswarm_0.4.0         plotly_4.10.0          ##  [91] png_0.1-7              spatstat.utils_3.0-1   bslib_0.4.0            ##  [94] stringi_1.7.8          highr_0.9              desc_1.4.1             ##  [97] forcats_0.5.2          lattice_0.20-45        Matrix_1.5-3           ## [100] shinyjs_2.1.0          vctrs_0.5.2            pillar_1.8.1           ## [103] lifecycle_1.0.3        spatstat.geom_3.0-3    lmtest_0.9-40          ## [106] jquerylib_0.1.4        RcppAnnoy_0.0.19       data.table_1.14.2      ## [109] cowplot_1.1.1          irlba_2.3.5            httpuv_1.6.5           ## [112] R6_2.5.1               promises_1.2.0.1       KernSmooth_2.23-20     ## [115] gridExtra_2.3          vipor_0.4.5            parallelly_1.32.1      ## [118] codetools_0.2-18       MASS_7.3-58.1          rprojroot_2.0.3        ## [121] withr_2.5.0            sctransform_0.3.5      parallel_4.2.1         ## [124] grid_4.2.1             tidyr_1.3.0            rmarkdown_2.15         ## [127] Rtsne_0.16             spatstat.explore_3.0-5 shiny_1.7.4            ## [130] ggbeeswarm_0.6.0"},{"path":"https://ludvigla.github.io/semla/articles/semla.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Get started","text":"semla currently available development version GitHub: Load library","code":"remotes::install_github(\"ludvigla/semla\") library(semla) packageVersion(\"semla\")"},{"path":"https://ludvigla.github.io/semla/articles/semla.html","id":"authors","dir":"Articles","previous_headings":"","what":"Authors","title":"Get started","text":"package written Ludvig Larsson Lovisa Franzén part Spatial Research lab SciLifeLab Stockholm.","code":""},{"path":"https://ludvigla.github.io/semla/articles/semla.html","id":"publication","dir":"Articles","previous_headings":"","what":"Publication","title":"Get started","text":"use semla published research, please cite following article: TBD","code":""},{"path":"https://ludvigla.github.io/semla/articles/spatial_statistics_for_labelled_spots.html","id":"demo-data","dir":"Articles","previous_headings":"","what":"Demo data","title":"Spatial statistics for labelled spots","text":"tutorial use data set mouse kidney, available download 10x Genomics. tissue section interesting organization , might want able describe statistical fashion. loading data, quickly process data generate clusters using Seurat’s FindNeighbors() FindClusters() based PCA.   Looking clusters just generated can see many seem follow kind spatial pattern. Cluster 1 dominating center tissue section, forming core (medulla), instance clusters 0, 2, 3 intermingled cortical area section. describe spatial clusters behave relate , can use couple analyses within semla called RunLabelAssortativityTest() RunNeighborhoodEnrichmentTest().","code":"# Set up folders for storing data tmpdir <- \".\" # Set current wd or change to tmpdir() dir.create(paste0(tmpdir, \"/demo_data\")) dir.create(paste0(tmpdir, \"/demo_data/kidney\")) targetdir <- paste0(tmpdir, \"/demo_data/kidney/visium\") dir.create(targetdir) # Download data download.file(url = \"https://cf.10xgenomics.com/samples/spatial-exp/1.1.0/V1_Mouse_Kidney/V1_Mouse_Kidney_filtered_feature_bc_matrix.h5\",               destfile = file.path(targetdir, \"filtered_feature_bc_matrix.h5\")) download.file(url = \"https://cf.10xgenomics.com/samples/spatial-exp/1.1.0/V1_Mouse_Kidney/V1_Mouse_Kidney_spatial.tar.gz\",               destfile = file.path(targetdir, \"spatial.tar.gz\")) untar(tarfile = file.path(targetdir, \"spatial.tar.gz\"),       exdir =  file.path(targetdir)) file.remove(file.path(targetdir, \"spatial.tar.gz\")) # Read data samples <- file.path(targetdir, \"filtered_feature_bc_matrix.h5\") imgs <- file.path(targetdir, \"spatial\", \"tissue_hires_image.png\") spotfiles <- file.path(targetdir, \"spatial\", \"tissue_positions_list.csv\") json <- file.path(targetdir, \"spatial\", \"scalefactors_json.json\")  infoTable <- tibble::tibble(samples, imgs, spotfiles, json) se <- ReadVisiumData(infoTable) ## ## ── Reading 10x Visium data ── ## ## ℹ Loading matrices: ## →   Finished loading expression matrix 1 ## ℹ only 1 expression matrix loaded. ## ✔   There are 32285 features and 1438 spots in the matrix. ## ℹ Loading coordinates: ## →   Finished loading coordinates for sample 1 ## ℹ Collected coordinates for 1438 spots. ## ## ── Creating `Seurat` object ## ✔ Expression matrices and coordinates are compatible ## ℹ Created `Seurat` object ## ℹ Created `Staffli` object ## ✔ Returning a `Seurat` object with 32285 features and 1438 spots # Generate clusters se <- se |>   NormalizeData() |>   ScaleData() |>   FindVariableFeatures() |>   RunPCA(verbose = F) |>   FindNeighbors(reduction = \"pca\", dims = 1:30) |>   FindClusters() ## Centering and scaling data matrix ## Computing nearest neighbor graph ## Computing SNN ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ##  ## Number of nodes: 1438 ## Number of edges: 48160 ##  ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.7913 ## Number of communities: 11 ## Elapsed time: 0 seconds unique_clusters <- levels(se$seurat_clusters) cluster_colors <- setNames(ggsci::pal_d3(\"category20\")(length(unique_clusters)), nm = unique_clusters)  MapLabelsSummary(se,                   column_name = \"seurat_clusters\",                   bar_display = \"count\",                  pt_size = 2,                  override_plot_dims = T,                   bar_label_size = 2.5,                   colors = cluster_colors)"},{"path":"https://ludvigla.github.io/semla/articles/spatial_statistics_for_labelled_spots.html","id":"visium-data-as-a-network","dir":"Articles","previous_headings":"","what":"Visium data as a network","title":"Spatial statistics for labelled spots","text":"spots spatial data can viewed network, connecting spot closest neighbors. Visium, spots form hexagonal patterns, thus spot can connected maximum six neighboring spots, look area direct vicinity. network science, spot referred node, connection nodes called edges, number edges node nodes described node’s degree (k). can create network Visium data using function GetSpatialNetwork(). function returns list (one table per sample), ’ll need fetch first item list. can add information clusters plotting ggplot2.","code":"spatial_network <- GetSpatialNetwork(se)[[1]] se$random_clusters <- se$seurat_clusters |> as.character() |> sample(ncol(se)) spatial_network$cluster <- se[[]][spatial_network$from, \"seurat_clusters\", drop = TRUE] |> as.character() spatial_network$random_clusters <- se[[]][spatial_network$from, \"random_clusters\", drop = TRUE] |> as.character()  head(spatial_network, 4) ## # A tibble: 4 × 10 ##   from           to    dista…¹    nn x_start y_start x_end y_end cluster rando…² ##   <chr>          <chr>   <dbl> <int>   <int>   <int> <int> <int> <chr>   <chr>   ## 1 AAACCGTTCGTCC… AACT…    138.     6    4116    7307  4047  7426 2       2       ## 2 AAACCTAAGCAGC… CAGG…    137.     6    6932    8873  7069  8874 5       4       ## 3 AAACGAGACGGTT… AAGA…    137      6    6669    5280  6532  5280 6       0       ## 4 AAACGGTTGCGAA… ATCT…    137      6    5279    9107  5142  9107 3       8       ## # … with abbreviated variable names ¹​distance, ²​random_clusters ggplot(spatial_network, aes(x = x_start, xend = x_end, y = y_start, yend = y_end, color=cluster)) +   geom_segment() +   geom_point() +   scale_color_manual(values = cluster_colors) +   labs(title=\"Spatial network\") +   scale_y_reverse() +    theme_void() +   theme(aspect.ratio = 1, plot.title = element_text(hjust=0.5))"},{"path":"https://ludvigla.github.io/semla/articles/spatial_statistics_for_labelled_spots.html","id":"lat","dir":"Articles","previous_headings":"","what":"Label Assortativity Analysis","title":"Spatial statistics for labelled spots","text":"term assortativity used within network science describe nodes similar properties connected . Traditionally looked terms node’s degree computing correlation coefficient nodes similar degrees. methods look Newman’s Assortativity (Newman, 2002) Ripley’s Function (Ripley, 1976). Inspired , developed simple method measure connectivity spots belonging cluster, .e. sharing label, measuring network’s average degree, ⟨k⟩, label comparing completely randomly dispersed pattern. randomly distributed pattern can viewed baseline, since rarely obtain pattern dispersed , group spots fully connected highest order organization can achieve. method, label’s ⟨k⟩ therefore min-max scaled ⟨k⟩ randomized network (min) ⟨k⟩ fully connected network (max).","code":""},{"path":"https://ludvigla.github.io/semla/articles/spatial_statistics_for_labelled_spots.html","id":"kidney-data-assortativity","dir":"Articles","previous_headings":"Label Assortativity Analysis","what":"Kidney data assortativity","title":"Spatial statistics for labelled spots","text":"run analysis calling function RunLabelAssortativityTest() storing results new object.  output analysis tibble containing scaled average degree, avg_k_scaled, unique label provided analysis. can also read intermediates analyses used calculations final score. avg_k_scaled goes ~0-1, values around 0 equal randomly dispersed spatial pattern values closer 1 indicating aggregated highly connected organization spots label. Let’s look results!    surprisingly, see cluster 1 clearly top connected cluster. bottom find cluster 7, even slightly negative score (though falls within standard deviation randomized network, look details). can take closer look cluster 1 compares randomly dispersed counterpart prove point. can clearly see cluster’s network higher average degree random network.   Cluster 7 hand score corresponding completely random spatial pattern. Looking spatial distribution spots belonging label can understand case, can also see method describe everything spatial patterns see trend cluster 7 spots localized outer rim section.","code":"res_lat <- RunLabelAssortativityTest(se, column_name = \"seurat_clusters\") ## ## ── Running Label Assortativity Test ── ## ## ℹ Generating neighborhood adjacency data from observed labels in column 'seurat_clusters' ## ✔ Observed label average degree calculations complete ## ℹ Generating neighborhood adjacency data from randomized labels ## ✔ Randomized label adjacency calculations complete from 100 iterations ## ! The standard deviation of some of the permuted results is relatively high (>0.1) which may indicate unreliable results. ## A possible solution could be to increase the number of permutations ('n_permutations'). ## ✔ Scores calculated for each label and returned as output tibble datatable(   res_lat |> arrange(desc(avg_k_scaled)),   rownames = F,   caption = \"Label assortativity results\" ) ggplot(res_lat, aes(x=reorder(label, avg_k_scaled), y=avg_k_scaled)) +   geom_col(width = 0.8) +   geom_hline(yintercept = 0, color=\"black\", size=0.2) +   labs(x=\"Label\", y=\"Scaled average degree\", title=\"Label assortativity score\") +   coord_flip() +   theme_linedraw() +   theme(plot.title = element_text(hjust=0.5, size=12, face = \"bold\"),         axis.text = element_text(size=10),         legend.position = \"none\",         legend.title = element_text(size=10),         legend.text = element_text(size=10)) ## Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0. ## ℹ Please use `linewidth` instead. p1 <- ggplot(spatial_network, aes(x = x_start, xend = x_end, y = y_start, yend = y_end)) +   geom_segment(color=\"grey90\") +   geom_point(data = subset(spatial_network, cluster == \"1\"), color = cluster_colors[\"1\"]) +   labs(title=\"Cluster 1\",        caption = paste0(\"Observed avg k: \", round(subset(res_lat, label==\"1\")[,\"avg_k\"], 2))        )  p2 <- ggplot(spatial_network, aes(x = x_start, xend = x_end, y = y_start, yend = y_end)) +   geom_segment(color=\"grey90\") +   geom_point(data = subset(spatial_network, random_clusters == \"1\"), color = cluster_colors[\"1\"]) +   labs(title=\"Cluster 1 randomly dispersed\",        caption = paste0(\"Random mean avg k: \", round(subset(res_lat, label==\"1\")[,\"min_avg_k_mean\"], 2))        )  (p1 | p2) & scale_y_reverse() & theme_void() & theme(aspect.ratio = 1, plot.title = element_text(hjust=0.5), plot.caption = element_text(hjust=0.5)) p1 <- ggplot(spatial_network, aes(x = x_start, xend = x_end, y = y_start, yend = y_end)) +   geom_segment(color=\"grey90\") +   geom_point(data = subset(spatial_network, cluster == \"7\"), color = cluster_colors[\"7\"]) +   labs(title=\"Cluster 7\",        caption = paste0(\"Observed avg k: \", round(subset(res_lat, label==\"7\")[,\"avg_k\"], 2))        )  p2 <- ggplot(spatial_network, aes(x = x_start, xend = x_end, y = y_start, yend = y_end)) +   geom_segment(color=\"grey90\") +   geom_point(data = subset(spatial_network, random_clusters == \"7\"), color = cluster_colors[\"7\"]) +   labs(title=\"Cluster 7 randomly dispersed\",        caption = paste0(\"Random mean avg k: \", round(subset(res_lat, label==\"7\")[,\"min_avg_k_mean\"], 2))        )  (p1 | p2) & scale_y_reverse() & theme_void() & theme(aspect.ratio = 1, plot.title = element_text(hjust=0.5), plot.caption = element_text(hjust=0.5))"},{"path":"https://ludvigla.github.io/semla/articles/spatial_statistics_for_labelled_spots.html","id":"explore-parameter-settings-n_permutations","dir":"Articles","previous_headings":"Label Assortativity Analysis","what":"Explore parameter settings: n_permutations","title":"Spatial statistics for labelled spots","text":"default, number permutations, n_permutations, used set 100, however, recommended try increasing value may give robust results. many cases though, number permutation little effect outcome analysis. current data set can study effect running tests looking average degree differs using higher number permutations  Looking plots can see number permutations actually little effect outcome standard deviation around 0.1 permuted values uncommon even using high number iterations. case particular data set, confident results even n_permutations set 100. can also see plot observed avg k value cluster 7 falls within standard deviation avg k permutations, sense can say spatial pattern cluster 7 spots equal randomized distribution. previous test also stored information function run time given different numbers permutations. running excessive permutations can save time, however matter seconds.","code":"perm_test <- c(10, 20, 50, 100, seq(from=200, to=1000, by=200)) lat_perm_test_list <- lapply(perm_test, function(n_perm){   f_time <- system.time(result <- RunLabelAssortativityTest(object = se,                                                              column_name = \"seurat_clusters\",                                                              n_permutations = n_perm,                                                              verbose = F))   result$time_s <- f_time[3]   result$n_perm <- n_perm   result }) lat_perm_test <- do.call(bind_rows, lat_perm_test_list) ggplot(lat_perm_test, aes(x=n_perm, y = min_avg_k_mean)) +   geom_point(size=1) +   geom_errorbar(aes(ymin = min_avg_k_mean - min_avg_k_sd, ymax = min_avg_k_mean + min_avg_k_sd)) +   geom_line(data = lat_perm_test, mapping = aes(x=n_perm, y = avg_k), color = \"orange\", linewidth=0.5) +   facet_wrap(~label, scales = \"free_y\") +   labs(title=\"Effect of n_permutations on average degree in randomized network\",         caption = \"Black dots and error bars: average degree mean and s.d from permutations. Orange line: actual observed average degree.\",        y=\"Average degree\", x=\"n permutations\") +   theme_bw() mean(lat_perm_test$min_avg_k_sd) ## [1] 0.1104268 t_plot <- lat_perm_test t_plot <- t_plot |>    group_by(n_perm) |>    summarise(.groups = \"keep\", time_s= max(time_s))  ggplot(t_plot, aes(x=n_perm, y = time_s)) +   geom_line(size=.5) +   geom_point(size=2) +   labs(title=\"Function run time with increasing n permutations\",        y=\"time (s)\", x=\"n permutations\") +   theme_bw()"},{"path":"https://ludvigla.github.io/semla/articles/spatial_statistics_for_labelled_spots.html","id":"net","dir":"Articles","previous_headings":"","what":"Neighborhood Enrichment Analysis","title":"Spatial statistics for labelled spots","text":"purpose neighborhood enrichment analysis test whether spots belonging two different categories localized next spatially. estimate enrichment co-localization need compare random permutations labels, forming null hypothesis saying spots two labels distributed randomly shares connections seen chance. z-score label pair calculated : \\(Z_{AB} = \\frac{x_{AB} - µ_{AB}}{σ_{AB}}\\) \\(x_{AB}\\) number edges observed spots labels B, \\(µ_{AB}\\) permutation mean edges B, \\(σ_{AB}\\) permutation standard deviation edges B. Thus, z-score around 0 can interpreted spatial label co-localization equal seen chance given number spots within categories, positive z-score indicates -representation label pair proximity negative z-score can viewed depletion, repellant effect, label pair spatially.","code":""},{"path":"https://ludvigla.github.io/semla/articles/spatial_statistics_for_labelled_spots.html","id":"kidney-data-neighborhood-enrichment","dir":"Articles","previous_headings":"Neighborhood Enrichment Analysis","what":"Kidney data neighborhood enrichment","title":"Spatial statistics for labelled spots","text":"neighborhood enrichment analysis run calling function RunNeighborhoodEnrichmentTest() storing results new results object.  output, obtain tibble z-scores label pair.  results can also plotted different ways, straightforward look heatmap.   can also plot top enriched pairs bar chart. Since output table contains label pair duplicate, first need remove excessive duplicated values.   results can see spots clusters 4 8 appear lot often next expect chance, spots clusters 0 1 strong negative z-score thus separated spatially. can also plot cluster pairs spatially look results make sense. First, let’s look top two -represented label pairs.   can see case clusters 4 8, spots except one appear next another spot label, clearly demonstrates two clusters really co-localizing spatially tissue. Clusters 3 7 also appearing often next one another, makes sense given high z-score. Now, let’s look bottom two enriched label pairs instead.  Seeing two label pair examples, clear negative z-scores since single instance spots different labels appear adjacent one another.","code":"res_net <- RunNeighborhoodEnrichmentTest(se, column_name = \"seurat_clusters\", n_permutations = 1000) ## ## ── Running Neighborhood Enrichment Analysis ── ## ## ℹ Generating neighborhood adjacency data from observed labels in column 'seurat_clusters' ## ✔ Observed label adjacency calculations complete ## ℹ Generating neighborhood adjacency data from randomized labels ## ✔ Randomized label adjacency calculations complete from 1000 iterations ## ✔ Scores calculated for each label pair and returned as output tibble datatable(   res_net |> arrange(desc(abs(z_score))),    rownames = F,    caption = \"Neighborhood enrichment analysis output\"   ) cluster_labels <- paste0(\"Label_\", sort(unique(se$seurat_clusters))) hm_plot_data <- res_net  hm_plot_data$label_1 <- factor(hm_plot_data$label_1, levels = cluster_labels) hm_plot_data$label_2 <- factor(hm_plot_data$label_2, levels = cluster_labels)  ggplot(hm_plot_data, aes(label_1, label_2, fill= z_score)) +    geom_tile(color = \"white\",             lwd = 1.5,             linetype = 1) +   scale_fill_gradient2(low = \"#0474BA\",                        mid = \"grey90\",                        high = \"#F17720\") +   labs(x=\"\", y=\"\", title=\"Neighborhood enrichment\", fill=\"Z-score\") +   theme_bw() +   coord_fixed() +   theme(panel.grid.major = element_blank(),         axis.text.x = element_text(angle = 45, hjust = 1),         plot.title = element_text(hjust=0.5, size=12, face = \"bold\"),         axis.text = element_text(size=10),         legend.title = element_text(size=10),          legend.text = element_text(size=10)) top_n_plot <- 10 plot_data <- res_net |>    mutate(across(where(is.factor), as.character)) |>    group_by(grp = paste0(pmin(label_1, label_2), \"-\", pmax(label_1, label_2))) |>    slice(1)  |>    ungroup()  |>    select(-grp)  plot_data <- rbind(   plot_data |> arrange(z_score) |> head(top_n_plot) |> filter(z_score < 0),   plot_data |> arrange(desc(z_score)) |> head(top_n_plot) |> filter(z_score > 0)   )  plot_data$direction <- ifelse(plot_data$z_score>0, \"over-represented\", \"under-represented\") colors_direction_fill <- setNames(c(\"#F17720\", \"#0474BA\"), nm = c(\"over-represented\", \"under-represented\"))  ggplot(plot_data, aes(x=reorder(label_label, z_score), y=z_score, fill = direction)) +   geom_col(width = 0.6) +   labs(x=\"\", y=\"Z-score\", title=\"Top enriched label pairs\", fill=\"Enrichment\") +   scale_fill_manual(values = colors_direction_fill) +   geom_hline(yintercept = 0, color=\"black\", size=0.5) +   coord_flip() +   theme_linedraw() +   theme(plot.title = element_text(hjust=0.5, size=12, face = \"bold\"),         axis.text = element_text(size=10),         panel.grid = element_blank(),          legend.position = \"top\",          legend.title = element_text(size=10),          legend.text = element_text(size=10)) p1 <- ggplot(spatial_network, aes(x = x_start, xend = x_end, y = y_start, yend = y_end)) +   geom_segment(color=\"grey90\") +   geom_point(data = subset(spatial_network, cluster == \"4\"), color = cluster_colors[\"4\"]) +   geom_point(data = subset(spatial_network, cluster == \"8\"), color = cluster_colors[\"8\"]) +   labs(title=\"Clusters 4 and 8\")  p2 <- ggplot(spatial_network, aes(x = x_start, xend = x_end, y = y_start, yend = y_end)) +   geom_segment(color=\"grey90\") +   geom_point(data = subset(spatial_network, cluster == \"3\"), color = cluster_colors[\"3\"]) +   geom_point(data = subset(spatial_network, cluster == \"7\"), color = cluster_colors[\"7\"]) +   labs(title=\"Clusters 3 and 7\")  (p1 | p2) & scale_y_reverse() & theme_void() & theme(aspect.ratio = 1, plot.title = element_text(hjust=0.5)) p1 <- ggplot(spatial_network, aes(x = x_start, xend = x_end, y = y_start, yend = y_end)) +   geom_segment(color=\"grey90\") +   geom_point(data = subset(spatial_network, cluster == \"0\"), color = cluster_colors[\"0\"]) +   geom_point(data = subset(spatial_network, cluster == \"1\"), color = cluster_colors[\"1\"]) +   labs(title=\"Clusters 0 and 1\")  p2 <- ggplot(spatial_network, aes(x = x_start, xend = x_end, y = y_start, yend = y_end)) +   geom_segment(color=\"grey90\") +   geom_point(data = subset(spatial_network, cluster == \"1\"), color = cluster_colors[\"1\"]) +   geom_point(data = subset(spatial_network, cluster == \"2\"), color = cluster_colors[\"2\"]) +   labs(title=\"Clusters 1 and 2\")  (p1 | p2) & scale_y_reverse() & theme_void() & theme(aspect.ratio = 1, plot.title = element_text(hjust=0.5))"},{"path":"https://ludvigla.github.io/semla/articles/spatial_statistics_for_labelled_spots.html","id":"explore-parameter-settings-n_permutations-1","dir":"Articles","previous_headings":"Neighborhood Enrichment Analysis","what":"Explore parameter settings: n_permutations","title":"Spatial statistics for labelled spots","text":"RunNeighborhoodEnrichmentTest() function option adjust number permutations used label randomization. Picking high enough value crucial analysis, since standard deviation taken account z-score calculations therefore influence results. valuable test different options look results starts stabilize can therefore regarded robust  can see scores changing quite lot lower numbers permutations start stabilize around n_permutations = 200 . unsure many permutations needed, useful run test like see variable data set requires pick higher number. can also look run times function given increasing numbers permutations used. analysis runs relatively quick, much time loss running analysis large number permutations.","code":"perm_test <- c(10, 20, 50, 100, seq(from=200, to=1000, by=200)) nea_perm_test_list <- lapply(perm_test, function(n_perm){   f_time <- system.time(result <- RunNeighborhoodEnrichmentTest(object = se,                                                                  column_name = \"seurat_clusters\",                                                                  n_permutations = n_perm,                                                                  verbose = F))   result$time_s <- f_time[3]   result$n_perm <- n_perm   result }) nea_perm_test <- do.call(bind_rows, nea_perm_test_list) ggplot(nea_perm_test, aes(x=n_perm, y = z_score, color=label_label)) +   geom_point(size=1) +   geom_line() +   scale_x_continuous(breaks = perm_test) +   labs(title=\"Effect of n_permutations on z-score\",         caption = \"Each line corresponds to the z-score of a label pair\",        y=\"Z-score\", x=\"n permutations\") +   theme_bw() +   theme(legend.position = \"none\", axis.text.x = element_text(angle = 45, hjust = 1)) t_plot <- nea_perm_test t_plot <- t_plot |>    group_by(n_perm) |>    summarise(.groups = \"keep\", time_s= max(time_s))  ggplot(t_plot, aes(x=n_perm, y = time_s)) +   geom_line(size=.5) +   geom_point(size=2) +   scale_x_continuous(breaks = perm_test) +   labs(title=\"Function run time with increasing n permutations\",        y=\"time (s)\", x=\"n permutations\") +   theme_bw() +   theme(axis.text.x = element_text(angle = 45, hjust = 1))"},{"path":"https://ludvigla.github.io/semla/articles/spatial_statistics_for_labelled_spots.html","id":"explore-parameter-settings-column_labels","dir":"Articles","previous_headings":"Neighborhood Enrichment Analysis","what":"Explore parameter settings: column_labels","title":"Spatial statistics for labelled spots","text":"reason like include clusters data set can specify using column_labels argument RunNeighborhoodEnrichmentTest(). subset data contain specified labels prior running analysis, therefore results end different compared running analysis labels.    Now can see clusters 1 8 longer positive enrichment, even spatial relationship using full data set. likely due large size cluster 1 large proportion total number spots belong label, giving high likelihood appearing next spots labels randomly shuffle labels. highlights importance familiar data set cautions different parameters might influence analysis like , section size number spots within label.  semla: 1.0.0","code":"cluster_selection <- c(\"1\", \"4\", \"6\", \"8\") res_net_medulla <- RunNeighborhoodEnrichmentTest(se,                                                   column_name = \"seurat_clusters\",                                                   column_labels = cluster_selection,                                                   n_permutations = 1000) ## ## ── Running Neighborhood Enrichment Analysis ── ## ## ℹ Generating neighborhood adjacency data from observed labels in column 'seurat_clusters' ## ℹ Analysis limited to study 4 unique labels ## ✔ Observed label adjacency calculations complete ## ℹ Generating neighborhood adjacency data from randomized labels ## ✔ Randomized label adjacency calculations complete from 1000 iterations ## ✔ Scores calculated for each label pair and returned as output tibble datatable(   res_net_medulla |> arrange(desc(abs(z_score))),    rownames = F,    caption = \"Neighborhood enrichment analysis output for label subset\"   ) cluster_labels <- paste0(\"Label_\", cluster_selection) hm_plot_data <- res_net_medulla  hm_plot_data$label_1 <- factor(hm_plot_data$label_1, levels = cluster_labels) hm_plot_data$label_2 <- factor(hm_plot_data$label_2, levels = cluster_labels)  ggplot(hm_plot_data, aes(label_1, label_2, fill= z_score)) +    geom_tile(color = \"white\",             lwd = 1.5,             linetype = 1) +   scale_fill_gradient2(low = \"#0474BA\",                        mid = \"grey90\",                        high = \"#F17720\") +   labs(x=\"\", y=\"\", title=\"Neighborhood enrichment\", fill=\"Z-score\") +   theme_bw() +   coord_fixed() +   theme(panel.grid.major = element_blank(),         axis.text.x = element_text(angle = 45, hjust = 1),         plot.title = element_text(hjust=0.5, size=12, face = \"bold\"),         axis.text = element_text(size=10),         legend.title = element_text(size=10),          legend.text = element_text(size=10)) ggplot(subset(spatial_network, cluster %in% cluster_selection), aes(x = x_start, xend = x_end, y = y_start, yend = y_end)) +   geom_segment(color=\"grey90\") +   geom_point(mapping = aes(x = x_start, y = y_start, color = cluster)) +   scale_color_manual(values = cluster_colors[cluster_selection]) +   labs(title=\"Medulla associated clusters\") &    scale_y_reverse() &    theme_void() &    theme(aspect.ratio = 1, plot.title = element_text(hjust=0.5))"},{"path":"https://ludvigla.github.io/semla/articles/subset_and_merge.html","id":"subset-by-selecting-spots","dir":"Articles","previous_headings":"","what":"Subset by selecting spots","title":"Subset and merge","text":"data can subseted specifying spots keep using barcode ID.","code":"spots_to_keep <- c(\"AAACAAGTATCTCCCA-1\", \"AAACACCAATAACTGC-1\",                     \"AAACATTTCCCGGATT-1\", \"AAACCCGAACGAAATC-1\",                     \"AAACCGGGTAGGTACC-1\", \"AAACCGTTCGTCCAGG-1\")  # Subset using selected spots se_mcolon_small <- SubsetSTData(se_mcolon, spots = spots_to_keep) se_mcolon_small ## An object of class Seurat  ## 188 features across 3 samples within 1 assay  ## Active assay: Spatial (188 features, 182 variable features) MapFeaturesSummary(se_mcolon_small, features = \"nFeature_Spatial\", subplot_type = \"histogram\")"},{"path":"https://ludvigla.github.io/semla/articles/subset_and_merge.html","id":"subset-by-selecting-features","dir":"Articles","previous_headings":"","what":"Subset by selecting features","title":"Subset and merge","text":"can also extract data corresponding selected genes interest.","code":"genes_to_keep <- c(\"Hbb-bs\", \"Hba-a1\", \"Hba-a2\", \"Hbb-bt\", \"Slc6a3\", \"Th\")  # Subset using selected genes se_mcolon_fewgenes <- SubsetSTData(se_mcolon, features = genes_to_keep) se_mcolon_fewgenes ## An object of class Seurat  ## 6 features across 2604 samples within 1 assay  ## Active assay: Spatial (6 features, 6 variable features) MapFeaturesSummary(se_mcolon_fewgenes, features = \"nFeature_Spatial\", subplot_type = \"histogram\")"},{"path":"https://ludvigla.github.io/semla/articles/subset_and_merge.html","id":"subset-with-an-expression","dir":"Articles","previous_headings":"","what":"Subset with an expression","title":"Subset and merge","text":"want subset data using information meta.data slot, might easier use expression instead. comes handy want perform QC filtering data.","code":"# Filter by number of unique genes se_mcolon_filtered <- SubsetSTData(se_mcolon, expression = nFeature_Spatial > 30) se_mcolon_filtered ## An object of class Seurat  ## 188 features across 2545 samples within 1 assay  ## Active assay: Spatial (188 features, 182 variable features) MapFeaturesSummary(se_mcolon_filtered, features = \"nFeature_Spatial\", subplot_type = \"histogram\")"},{"path":"https://ludvigla.github.io/semla/articles/subset_and_merge.html","id":"merge-two-data-sets","dir":"Articles","previous_headings":"","what":"Merge two data sets","title":"Subset and merge","text":"Finally, can use MergeSTData() join two objects. example, colon data set merged brain data set.   semla: 1.0.0","code":"se_mbrain <- readRDS(system.file(\"extdata/mousebrain\",                                   \"se_mbrain\",                                   package = \"semla\")) se_merged <- MergeSTData(se_mcolon, se_mbrain)  unique(se_merged$sample_id) ## [1] \"mousecolon\" \"mousebrain\" se_merged ## An object of class Seurat  ## 188 features across 5164 samples within 1 assay  ## Active assay: Spatial (188 features, 0 variable features) MapFeatures(se_merged, features = \"nFeature_Spatial\") sessionInfo() ## R version 4.2.1 (2022-06-23) ## Platform: x86_64-apple-darwin13.4.0 (64-bit) ## Running under: macOS Big Sur ... 10.16 ##  ## Matrix products: default ## BLAS/LAPACK: /Users/ludviglarsson/miniconda3/envs/R4.2/lib/libopenblasp-r0.3.21.dylib ##  ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ## [1] semla_1.0.0        ggplot2_3.4.1      dplyr_1.1.0        SeuratObject_4.1.3 ## [5] Seurat_4.3.0       ##  ## loaded via a namespace (and not attached): ##   [1] Rtsne_0.16             colorspace_2.0-3       deldir_1.0-6           ##   [4] ellipsis_0.3.2         ggridges_0.5.3         rprojroot_2.0.3        ##   [7] fs_1.5.2               spatstat.data_3.0-0    rstudioapi_0.14        ##  [10] farver_2.1.1           leiden_0.4.2           listenv_0.8.0          ##  [13] ggrepel_0.9.3          fansi_1.0.3            codetools_0.2-18       ##  [16] splines_4.2.1          cachem_1.0.6           knitr_1.39             ##  [19] zeallot_0.1.0          polyclip_1.10-0        jsonlite_1.8.3         ##  [22] ica_1.0-3              cluster_2.1.4          png_0.1-7              ##  [25] uwot_0.1.14            spatstat.sparse_3.0-0  shiny_1.7.4            ##  [28] sctransform_0.3.5      compiler_4.2.1         httr_1.4.4             ##  [31] Matrix_1.5-3           fastmap_1.1.0          lazyeval_0.2.2         ##  [34] cli_3.4.1              later_1.3.0            htmltools_0.5.4        ##  [37] tools_4.2.1            igraph_1.3.4           gtable_0.3.0           ##  [40] glue_1.6.2             RANN_2.6.1             reshape2_1.4.4         ##  [43] Rcpp_1.0.9             scattermore_0.8        jquerylib_0.1.4        ##  [46] pkgdown_2.0.6          vctrs_0.5.2            nlme_3.1-159           ##  [49] spatstat.explore_3.0-5 progressr_0.10.1       lmtest_0.9-40          ##  [52] spatstat.random_3.0-1  xfun_0.32              stringr_1.5.0          ##  [55] globals_0.16.0         mime_0.12              miniUI_0.1.1.1         ##  [58] lifecycle_1.0.3        irlba_2.3.5            goftest_1.2-3          ##  [61] future_1.27.0          MASS_7.3-58.1          zoo_1.8-10             ##  [64] scales_1.2.1           ragg_1.2.2             promises_1.2.0.1       ##  [67] spatstat.utils_3.0-1   parallel_4.2.1         RColorBrewer_1.1-3     ##  [70] yaml_2.3.5             memoise_2.0.1          reticulate_1.26        ##  [73] pbapply_1.5-0          gridExtra_2.3          sass_0.4.2             ##  [76] stringi_1.7.8          highr_0.9              desc_1.4.1             ##  [79] rlang_1.0.6            pkgconfig_2.0.3        systemfonts_1.0.4      ##  [82] matrixStats_0.62.0     evaluate_0.16          lattice_0.20-45        ##  [85] tensor_1.5             ROCR_1.0-11            purrr_1.0.1            ##  [88] labeling_0.4.2         patchwork_1.1.2        htmlwidgets_1.5.4      ##  [91] cowplot_1.1.1          tidyselect_1.2.0       parallelly_1.32.1      ##  [94] RcppAnnoy_0.0.19       plyr_1.8.7             magrittr_2.0.3         ##  [97] R6_2.5.1               magick_2.7.3           generics_0.1.3         ## [100] DBI_1.1.3              withr_2.5.0            pillar_1.8.1           ## [103] fitdistrplus_1.1-8     abind_1.4-5            survival_3.4-0         ## [106] sp_1.5-1               tibble_3.1.8           future.apply_1.9.0     ## [109] crayon_1.5.1           KernSmooth_2.23-20     utf8_1.2.2             ## [112] spatstat.geom_3.0-3    plotly_4.10.0          rmarkdown_2.15         ## [115] grid_4.2.1             data.table_1.14.2      forcats_0.5.2          ## [118] digest_0.6.29          xtable_1.8-4           dbscan_1.1-10          ## [121] tidyr_1.3.0            httpuv_1.6.5           textshaping_0.3.6      ## [124] munsell_0.5.0          viridisLite_0.4.1      bslib_0.4.0            ## [127] shinyjs_2.1.0"},{"path":"https://ludvigla.github.io/semla/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Ludvig Larsson. Author, maintainer. Lovisa Franzen. Author. . Funder.","code":""},{"path":"https://ludvigla.github.io/semla/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Larsson L, Franzen L (2023). semla: Process, analyze visualize Spatially Resolved Transcriptomics data. R package version 1.0.0, https://ludvigla.github.io/semla/.","code":"@Manual{,   title = {semla: Process, analyze and visualize Spatially Resolved Transcriptomics data},   author = {Ludvig Larsson and Lovisa Franzen},   year = {2023},   note = {R package version 1.0.0},   url = {https://ludvigla.github.io/semla/}, }"},{"path":"https://ludvigla.github.io/semla/index.html","id":"semla-","dir":"","previous_headings":"","what":"semla - analysis of SRT data","title":"semla - analysis of SRT data","text":"semla R package collects useful tools Spatially Resolved Transcriptomics data analysis visualization. visiting Github page, please find information package website can find documentation functions together examples use , well tutorials showing use semla analysis 10x Visium data.","code":""},{"path":"https://ludvigla.github.io/semla/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"semla - analysis of SRT data","text":"","code":"remotes::install_github(\"ludvigla/semla\")"},{"path":"https://ludvigla.github.io/semla/index.html","id":"setting-up-a-conda-environment","dir":"","previous_headings":"","what":"Setting up a conda environment","title":"semla - analysis of SRT data","text":"First, need make sure anaconda installed. suggest using miniconda ’s one R package might cause issues configured properly, namely magick. suggest installing conda within environment: Now activate environment can open RStudio environment. make sure RStudio uses R version packages located conda environment. Mac OS, can open RStudio running something like: RStudio opened, check R version higher v4.1.","code":"conda create -n r-semla r-essentials r-base conda install -c conda-forge r-magick conda activate r-semla /Applications/RStudio.app/Contents/MacOS/RStudio"},{"path":"https://ludvigla.github.io/semla/index.html","id":"what-is-semla","dir":"","previous_headings":"","what":"What is semla?","title":"semla - analysis of SRT data","text":"semla delicious pastry, traditionally consumed around specific day, “Semmeldagen” “Fettisdagen” (“Fat Tuesday”), Sweden. made light cardamom flavored wheat bun, fluffy whipped cream, sweet crunchy almond paste, topped dusted icing sugar. ’s reason enough us name package fantastic creation, let’s also say semla abbreviation “Spatially rEsolved transcriptoMics tooLs Analysis”.","code":""},{"path":"https://ludvigla.github.io/semla/reference/AdjustTissueCoordinates.html","id":null,"dir":"Reference","previous_headings":"","what":"Adjust tissue coordinates for digital unrolling — AdjustTissueCoordinates","title":"Adjust tissue coordinates for digital unrolling — AdjustTissueCoordinates","text":"function takes `tbl_graph` object input generated CutSpatialNetwork attempts calculate unrolled tissue coordinates.","code":""},{"path":"https://ludvigla.github.io/semla/reference/AdjustTissueCoordinates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adjust tissue coordinates for digital unrolling — AdjustTissueCoordinates","text":"","code":"AdjustTissueCoordinates(full_graph, verbose = TRUE)"},{"path":"https://ludvigla.github.io/semla/reference/AdjustTissueCoordinates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adjust tissue coordinates for digital unrolling — AdjustTissueCoordinates","text":"full_graph `tbl_graph` object generated CutSpatialNetwork verbose Print messages","code":""},{"path":"https://ludvigla.github.io/semla/reference/AdjustTissueCoordinates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Adjust tissue coordinates for digital unrolling — AdjustTissueCoordinates","text":"`tibble` \"unrolled\" tissue coordinates","code":""},{"path":"https://ludvigla.github.io/semla/reference/AdjustTissueCoordinates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Adjust tissue coordinates for digital unrolling — AdjustTissueCoordinates","text":"algorithm described briefly : First, end point graph identified. outermost end point assumed starting point point center roll assumed end point. , algorithm tries find geodesic two end points, forming band nodes represents shortest path starting point end point. order shortest represents distances along x axis new coordinate system geodesics nodes used distances y axis new coordinate system. using information location nodes relative position shortest path nodes, algorithm also tries adjust y axis ensure non-negative values. NB: graph fully connected. multiple sub graphs found, largest graph kept. crucial edges cut properly CutSpatialNetwork, otherwise results inaccurate. See package website examples.","code":""},{"path":"https://ludvigla.github.io/semla/reference/AnglePlot.html","id":null,"dir":"Reference","previous_headings":"","what":"Angle plot — AnglePlot","title":"Angle plot — AnglePlot","text":"Draws angle plot top selected region. plot meant help defining angle intervals computing radial distances RadialDistance.","code":""},{"path":"https://ludvigla.github.io/semla/reference/AnglePlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Angle plot — AnglePlot","text":"","code":"AnglePlot(   object,   column_name,   selected_group,   radius = 0.3,   nbreaks = 9,   centroid_size = 8,   image_use = NULL,   coords_use = \"raw\",   crop_area = NULL,   pt_size = 1,   pt_alpha = 1,   pt_stroke = 0,   section_number = NULL,   label_by = NULL,   ncol = NULL,   colors = NULL,   override_plot_dims = FALSE,   drop_na = FALSE,   ... )"},{"path":"https://ludvigla.github.io/semla/reference/AnglePlot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Angle plot — AnglePlot","text":"object object class Seurat column_name character specifying meta data column holding categorical feature vector. selected_group label defining group spots found column meta data slot specified column_name radius numeric value 0.1 1 specifying size \"angle plot\" overlaid spatial plot. nbreaks Number intervals cut angles centroid_size Size centroid spot image_use character specifying image type use. coords_use character specifying coordinate type use. crop_area numeric vector length 4 specifying rectangular area crop plots . numbers within 0-1. x-axis goes left=0 right=1 y axis goes top=0 bottom=1. order values specified follows: crop_area = c(left, top, right, bottom). crop area used tissue sections set section individually. using crop areas different sizes different sections can lead unwanted side effects point sizes remain constant. case better generate separate plots different tissue sections. pt_size numeric value specifying point size passed geom_point pt_alpha numeric value 0 1 specifying point opacity passed geom_point. value 0 make points completely transparent value 1 make points completely opaque. pt_stroke numeric specifying point stroke width section_number integer select tissue section number subset data label_by character specifying column name object labels can used provide title subplot. column 1 label per tissue section. can useful need provide detailed information tissue sections. ncol integer value specifying number columns output patchwork. colors character vector colors use color scale. number colors match number labels present. override_plot_dims logical specifying whether image dimensions used define plot area. Setting override_plot_dims can useful situations tissue section covers small fraction capture area, create lot white space plots. effect can achieved crop_area crop area instead determined directly data. drop_na logical specifying NA values dropped ... Arguments passed methods","code":""},{"path":"https://ludvigla.github.io/semla/reference/AnglePlot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Angle plot — AnglePlot","text":"object class patchwork","code":""},{"path":"https://ludvigla.github.io/semla/reference/AnglePlot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Angle plot — AnglePlot","text":"region interest selected selected_group group categorical variable selected column_name stored meta data input Seurat object. selected region spatially connected.","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/reference/AnglePlot.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Angle plot — AnglePlot","text":"Ludvig Larsson","code":""},{"path":"https://ludvigla.github.io/semla/reference/AnglePlot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Angle plot — AnglePlot","text":"","code":"library(semla)  se_mcolon <- readRDS(system.file(\"extdata/mousecolon\", \"se_mcolon\", package = \"semla\")) se_mcolon <- DisconnectRegions(se_mcolon, column_name = \"selection\", selected_groups = \"GALT\") #> ℹ Extracting disconnected components for group 'GALT' #> ℹ Detecting disconnected regions for 106 spots #> Loading required namespace: tidygraph #> ℹ Found 8 disconnected graph(s) in data #> ℹ Sorting disconnected regions by decreasing size #> ℹ Found 12 singletons in data #> →   These will be labeled as 'singletons' se_mcolon <- LoadImages(se_mcolon) #>  #> ── Loading H&E images ── #>  #> ℹ Loading image from /private/var/folders/zb/1fj07x_5343fvs_k28gnm1z80002xs/T/RtmpFJGwBj/temp_libpath502354c29e9d/semla/extdata/mousecolon/spatial/tissue_hires_image.jpg #> ℹ Scaled image from 1804x2000 to 400x443 pixels #> ℹ Saving loaded H&E images as 'rasters' in Seurat object AnglePlot(se_mcolon, column_name = \"GALT_split\", selected_group = \"S1_region1\", pt_size = 2,         image_use = \"raw\", crop_area = c(0.4, 0.5, 0.7, 0.8), radius = 0.4, nbreaks = 12)"},{"path":"https://ludvigla.github.io/semla/reference/CoordAndImageTransform.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply transformation to paired image and coordinates — CoordAndImageTransform","title":"Apply transformation to paired image and coordinates — CoordAndImageTransform","text":"SRT data generated Visium consists H&E image gene expression matrix. columns gene expression matrix correspond spots can mapped H&E image using set pixel coordinates. function takes image corresponding set spot coordinates input applies transformation image spot coordinates simultaneously.","code":""},{"path":"https://ludvigla.github.io/semla/reference/CoordAndImageTransform.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply transformation to paired image and coordinates — CoordAndImageTransform","text":"","code":"CoordAndImageTransform(   im,   xy_coords,   mirror_x = FALSE,   mirror_y = FALSE,   angle = 0,   scalefactor = 1,   imcenter = NULL,   xy_offset_image = c(0, 0),   xy_offset_spots = NULL )"},{"path":"https://ludvigla.github.io/semla/reference/CoordAndImageTransform.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply transformation to paired image and coordinates — CoordAndImageTransform","text":"im Image class `magick-image`, `StoredSpatialImage`, `raster` path external image file. xy_coords matrix, data.frame tibble object numeric x, y coordinates. mirror_x, mirror_y Logical specifying image spots mirrored along x- /y-axis angle Numeric value specifying degree rotation. Use negative angles counter-clockwise rotation. value needs range (-360, 360) scalefactor numeric value specifying scaling factor (0, 3) imcenter numeric vector length 2 specifying image center. required spot coordinates already aligned H&E image. xy_offset_image numeric vector length 2 specifying translations along x-dn y-axes image xy_offset_spots numeric vector length 2 specifying translations along x- y-axes spots. xy_offset_image NULL, xy_offset_spots set xy_offset_image assumed spots matched image.","code":""},{"path":"https://ludvigla.github.io/semla/reference/CoordAndImageTransform.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply transformation to paired image and coordinates — CoordAndImageTransform","text":"list two elements: \"im_transf\": object class `magick-image` representing transformed image \"xy_transf\": object class `tbl` representing transformed coordinates","code":""},{"path":"https://ludvigla.github.io/semla/reference/CoordAndImageTransform.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Apply transformation to paired image and coordinates — CoordAndImageTransform","text":"Mirroring prioritized applied image applying rotations translations.","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/reference/CoordAndImageTransform.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Apply transformation to paired image and coordinates — CoordAndImageTransform","text":"Ludvig Larsson","code":""},{"path":"https://ludvigla.github.io/semla/reference/CoordAndImageTransform.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply transformation to paired image and coordinates — CoordAndImageTransform","text":"","code":"library(semla) library(ggplot2) library(patchwork) library(magick) #> Linking to ImageMagick 6.9.12.45 #> Enabled features: fontconfig, freetype, ghostscript, lcms, webp #> Disabled features: cairo, fftw, heic, pango, raw, rsvg, x11 library(dplyr)  # get example coordinate file coordinatefile <- system.file(\"extdata\",                               \"mousebrain/spatial/tissue_positions_list.csv\",                               package = \"semla\")  # Load coordinates xy <- LoadSpatialCoordinates(coordinatefiles = coordinatefile) #> ℹ Loading coordinates: #> →   Finished loading coordinates for sample 1 #> ℹ Collected coordinates for 2560 spots. xy #> # A tibble: 2,560 × 7 #>    barcode            selected     y     x pxl_row_in_fullres pxl_col_…¹ sampl…² #>    <chr>                 <int> <int> <int>              <int>      <int>   <int> #>  1 CATACAAAGCCGAACC-1        1    13    35               4117       6086       1 #>  2 CTGAGCAAGTAACAAG-1        1    15    25               4472       5062       1 #>  3 GGGTACCCACGGTCCT-1        1    14    26               4294       5164       1 #>  4 ACGGAATTTAGCAAAT-1        1    15    27               4472       5266       1 #>  5 GGGCGGTCCTATTGTC-1        1    14    28               4294       5369       1 #>  6 ATGTTACGAGCAATAC-1        1    15    29               4472       5471       1 #>  7 AACCATGGGATCGCTA-1        1    14    30               4294       5574       1 #>  8 TCGCATCCCTAAGTGT-1        1    15    31               4473       5676       1 #>  9 ACTTAGTACGACAAGA-1        1    14    32               4295       5778       1 #> 10 GAGCTCTCGGACCTAA-1        1    15    33               4473       5881       1 #> # … with 2,550 more rows, and abbreviated variable names ¹​pxl_col_in_fullres, #> #   ²​sampleID  # Load image lowresimagefile <- system.file(\"extdata/mousebrain/spatial\",                                \"tissue_lowres_image.jpg\",                                package = \"semla\") im <- image_read(lowresimagefile)  # read scalefactors scalefactorfile <- system.file(\"extdata/mousebrain/spatial\",                                \"scalefactors_json.json\",                                package = \"semla\") scalefactors <- jsonlite::read_json(scalefactorfile) scalefactors #> $spot_diameter_fullres #> [1] 143.3171 #>  #> $tissue_hires_scalef #> [1] 0.1039393 #>  #> $fiducial_diameter_fullres #> [1] 214.9757 #>  #> $tissue_lowres_scalef #> [1] 0.03118179 #>   # Convert coordinates using appropriate scalefactor, in this # case the scalefactor for tissue_image_lowres xy <- xy |>   mutate(across(pxl_col_in_fullres:pxl_row_in_fullres,                 ~ .x*scalefactors$tissue_lowres_scalef))  # Note that the y axis needs to be reversed and you need to # specify the axis limits uisng the dimensions of the image ggplot(xy, aes(pxl_col_in_fullres, pxl_row_in_fullres)) +   geom_point(color = \"red\", alpha = 0.5) +   scale_x_continuous(limits = c(0, image_info(im)$width), expand = c(0, 0)) +   scale_y_reverse(limits = c(image_info(im)$height, 0), expand = c(0, 0)) +   labs(x = expression(\"x\"[\"original\"]),        y = expression(\"y\"[\"original\"]),        title = \"Original image and coordinates\") +   theme_void() +   theme(axis.text = element_text(),         axis.title.x = element_text(),         axis.title.y = element_text(angle = 90)) +   coord_fixed() +   # Insert H&E image   inset_element(p = as.raster(im),                 left = 0, bottom = 0,                 right = 1, top = 1,                 on_top = FALSE)   # Select coordinates for transformation xy_coords <- xy |>   select(pxl_col_in_fullres, pxl_row_in_fullres)  # Apply transformations transf_res <- CoordAndImageTransform(im, xy_coords, angle = 45, xy_offset_image = c(100, 100))  # Add selected to transf_res$xy_transf transf_res$xy_transf$selected <- xy$selected  # Note that the y axis needs to be reversed and you need to # specify the axis limits uisng the dimensions of the image ggplot(transf_res$xy_transf, aes(tr_x, tr_y)) +   geom_point(color = \"red\", alpha = 0.5) +   scale_x_continuous(limits = c(0, image_info(im)$width), expand = c(0, 0)) +   scale_y_reverse(limits = c(image_info(im)$height, 0), expand = c(0, 0)) +   labs(x = expression(\"x\"[\"transformed\"]),        y = expression(\"y\"[\"transformed\"]),        title = \"Transformed image and coordinates\") +   theme_void() +   theme(axis.text = element_text(),         axis.title.x = element_text(),         axis.title.y = element_text(angle = 90)) +   coord_fixed() +   # Insert H&E image   inset_element(p = as.raster(transf_res$im_transf),                 left = 0, bottom = 0,                 right = 1, top = 1,                 on_top = FALSE)"},{"path":"https://ludvigla.github.io/semla/reference/CoordMirror.html","id":null,"dir":"Reference","previous_headings":"","what":"Mirror coordinates — CoordMirror","title":"Mirror coordinates — CoordMirror","text":"Mirror coordinates","code":""},{"path":"https://ludvigla.github.io/semla/reference/CoordMirror.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mirror coordinates — CoordMirror","text":"","code":"CoordMirror(xy_coords, mirror.x = FALSE, mirror.y = FALSE, center = NULL)"},{"path":"https://ludvigla.github.io/semla/reference/CoordMirror.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mirror coordinates — CoordMirror","text":"xy_coords matrix, data.frame tibble object numeric x, y coordinates. mirror.x, mirror.y Logical specifying whether coordinates reflected along x-axis, y-axis . center Optional point (x, y) specifying center reflection.","code":""},{"path":"https://ludvigla.github.io/semla/reference/CoordMirror.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mirror coordinates — CoordMirror","text":"tbl object transformed coordinates","code":""},{"path":"https://ludvigla.github.io/semla/reference/CoordMirror.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Mirror coordinates — CoordMirror","text":"coordinate system xy_coords match dimensions image. words, coordinates map spots tissue section H&E image. 3x3 transformation matrix constructed combining following matrices: \\(T(-x, -y)\\): Translate coordinates origin, .e. (0, 0) becomes new center \\(M_{x}\\): Reflect coordinates along x-axis \\(M_{y}\\): Reflect coordinates along y-axis \\(T(x, y)\\): Translate coordinates back center , matrices combined form final transformation matrix: \\(T_{final} = T(x, y)*M_{y}*M_{x}*T(-x, -y)\\) can used transform input coordinates: \\(xy_{} = T_{final}*xy_{}\\)","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/reference/CoordMirror.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Mirror coordinates — CoordMirror","text":"Ludvig Larsson","code":""},{"path":"https://ludvigla.github.io/semla/reference/CoordMirror.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mirror coordinates — CoordMirror","text":"","code":"library(ggplot2)  # Create a data.frame with x, y coordinates xy <- data.frame(x = 1:20, y = 1:20)  # Reflect coordinates along x axis xy_mx <- CoordMirror(xy, mirror.x = TRUE) |> setNames(nm = c(\"x\", \"y\"))  # Reflect along both x, and y axes xy_mxy <- CoordMirror(xy, mirror.x = TRUE, mirror.y = TRUE) |> setNames(nm = c(\"x\", \"y\"))  # Combine all coordinates xy_all <- do.call(rbind, list(cbind(xy, type = \"original\", ord = 1:20),                     cbind(xy_mx, type = \"mirror_x\", ord = 1:20),                     cbind(xy_mxy, type = \"mirror_x_and_y\", ord = 1:20))) xy_all$type <- factor(xy_all$type, levels = c(\"original\", \"mirror_x\", \"mirror_x_and_y\"))  # Now we can see the effects of mirroring # Mirror x flips the coordinates along the x axis while mirror_x and mirror_y # effectively inverts the coordinates, thus changing the order of the points ggplot(xy_all, aes(x, y)) +   geom_point(color = \"steelblue\", size = 7, alpha = 0.5) +   geom_text(aes(label = ord)) +   facet_grid(~type) +   geom_vline(xintercept = 10.5, linetype = \"dashed\", color = \"red\") +   geom_hline(yintercept = 10.5, linetype = \"dashed\", color = \"green\")"},{"path":"https://ludvigla.github.io/semla/reference/CoordTransform.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply transformations to a set of x, y coordinates — CoordTransform","title":"Apply transformations to a set of x, y coordinates — CoordTransform","text":"Apply transformations set x, y coordinates","code":""},{"path":"https://ludvigla.github.io/semla/reference/CoordTransform.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply transformations to a set of x, y coordinates — CoordTransform","text":"","code":"CoordTransform(   xy_coords,   angle = 0,   center = NULL,   xy_offset = c(0, 0),   scalefactor = 1 )"},{"path":"https://ludvigla.github.io/semla/reference/CoordTransform.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply transformations to a set of x, y coordinates — CoordTransform","text":"xy_coords matrix, data.frame tibble object numeric x, y coordinates. angle Numeric value specifying degree rotation. Use negative angles counter-clockwise rotation. value needs range (-360, 360) center Optional point (x, y) specifying center rotation. xy_offset Optional point (x, y) specifying translation. scalefactor numeric value specifying scaling factor (0, 3)","code":""},{"path":"https://ludvigla.github.io/semla/reference/CoordTransform.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply transformations to a set of x, y coordinates — CoordTransform","text":"tbl object transformed coordinates","code":""},{"path":"https://ludvigla.github.io/semla/reference/CoordTransform.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Apply transformations to a set of x, y coordinates — CoordTransform","text":"coordinate system xy_coords match dimensions image. words, coordinates map spots tissue section H&E image. Translations rotations done multiplying xy_coords following transformation matrix \\(T_{final}\\) described : \\(T(-x, -y)\\): Translate coordinates origin, .e. (0, 0) becomes new center \\(R\\): Rotate coordinates around origin \\(T(x, y)\\): Translate coordinates back center, optionally center + xy_offset , matrices combined form final transformation matrix: \\(T_{final} = T(x, y)*R*T(-x, -y)\\) can used transform input coordinates: \\(xy_{} = T_{final}*xy_{}\\) scaling handled separated translations rotations.","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/reference/CoordTransform.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Apply transformations to a set of x, y coordinates — CoordTransform","text":"Ludvig Larsson","code":""},{"path":"https://ludvigla.github.io/semla/reference/CoordTransform.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply transformations to a set of x, y coordinates — CoordTransform","text":"","code":"# Create a data.frame with x, y coordinates xy <- data.frame(x = 1:20, y = 1:20)  # Rotate coordinates 45 degrees clockwise around the center xy_rotated <- CoordTransform(xy, angle = 45) plot(xy) points(xy_rotated, col = \"red\")"},{"path":"https://ludvigla.github.io/semla/reference/CreateStaffliObject.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Staffli object — CreateStaffliObject","title":"Create a Staffli object — CreateStaffliObject","text":"Create Staffli object set images associated spot coordinates","code":""},{"path":"https://ludvigla.github.io/semla/reference/CreateStaffliObject.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Staffli object — CreateStaffliObject","text":"","code":"CreateStaffliObject(   imgs = NULL,   meta_data,   image_height = 400,   image_info,   scalefactors )"},{"path":"https://ludvigla.github.io/semla/reference/CreateStaffliObject.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Staffli object — CreateStaffliObject","text":"imgs Character vector specifying paths images JPG, PNG TIF format meta_data Spot-level metadata add Staffli object. tbl required columns 'barcode' representing spot IDs, 'pxl_col_in_fullres' 'pxl_row_in_fullres' specifies 10x Visium array coordinates 'sampleID' column sample IDs image_height Specifies height scaled images pixels [default: 400 pixels] image_info tibble image information scalefactors tibble scalefactors sued transform coordinates original image space downscaled images","code":""},{"path":"https://ludvigla.github.io/semla/reference/CreateStaffliObject.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Staffli object — CreateStaffliObject","text":"Staffli object","code":""},{"path":"https://ludvigla.github.io/semla/reference/CreateStaffliObject.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a Staffli object — CreateStaffliObject","text":"Ludvig Larsson","code":""},{"path":"https://ludvigla.github.io/semla/reference/CreateStaffliObject.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Staffli object — CreateStaffliObject","text":"","code":"library(semla) library(magick) library(jsonlite) library(tibble)  # Multiple samples # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% # Create an object with multiple samples he_imgs <- c(system.file(\"extdata/mousebrain\",                           \"spatial/tissue_hires_image.jpg\",                            package = \"semla\"),              system.file(\"extdata/mousecolon\",                           \"spatial/tissue_hires_image.jpg\",                           package = \"semla\")) spotfiles <- c(system.file(\"extdata/mousebrain\",                             \"spatial/tissue_positions_list.csv\",                             package = \"semla\"),                system.file(\"extdata/mousecolon\",                             \"spatial/tissue_positions_list.csv\",                             package = \"semla\")) jsonfiles <- c(system.file(\"extdata/mousebrain\",                             \"spatial/scalefactors_json.json\",                             package = \"semla\"),                system.file(\"extdata/mousecolon\",                             \"spatial/scalefactors_json.json\",                             package = \"semla\"))  # Read coordinates coordinates <- do.call(bind_rows, lapply(seq_along(spotfiles), function(i) {   sample_coords <- read.csv(spotfiles[i], header = FALSE) |>      as_tibble() |>     setNames(nm = c(\"barcode\", \"selected\", \"y\", \"x\", \"pxl_row_in_fullres\", \"pxl_col_in_fullres\")) |>      mutate(sampleID = i) |> # Add a unique sampleID     filter(selected == 1) |>      select(barcode, pxl_col_in_fullres, pxl_row_in_fullres, sampleID) |>      mutate(barcode = gsub(pattern = \"-\\\\d*\", # Replace barcode suffix with sampleID                           replacement = paste0(\"-\", i),                            x = barcode))   return(sample_coords) }))  # Create image_info image_info <- do.call(bind_rows, lapply(seq_along(he_imgs), function(i) {   he_imgs[i] |>      image_read() |>      image_info() |>      mutate(sampleID = paste0(i)) }))  # Read scalefactors scalefactors <- do.call(bind_rows, lapply(seq_along(jsonfiles), function(i) {   jsonlite::read_json(jsonfiles[i]) |>      as_tibble() |>      mutate(sampleID = paste0(i)) }))  # Add additional columns to image_info using scalefactors image_info <- image_info |>    mutate(full_width = width/scalefactors$tissue_hires_scalef[row_number()],          full_height = height/scalefactors$tissue_hires_scalef[row_number()]) |>    mutate(type = \"tissue_hires\") |>    select(format, width, height, full_width, full_height,           colorspace, filesize, density, sampleID, type)  # Create Staffli object staffli_object <- CreateStaffliObject(imgs = he_imgs,                                        meta_data = coordinates,                                        image_info = image_info,                                        scalefactors = scalefactors) staffli_object #> An object of class Staffli  #> 5164 spots across 2 samples."},{"path":"https://ludvigla.github.io/semla/reference/CutSpatialNetwork.html","id":null,"dir":"Reference","previous_headings":"","what":"Cut spatial networks in folded tissues — CutSpatialNetwork","title":"Cut spatial networks in folded tissues — CutSpatialNetwork","text":"Opens interactive viewer spatial network visualized top H&E image.","code":""},{"path":"https://ludvigla.github.io/semla/reference/CutSpatialNetwork.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cut spatial networks in folded tissues — CutSpatialNetwork","text":"","code":"CutSpatialNetwork(   object,   datadir = NULL,   sampleID = 1,   host = \"127.0.0.1\",   port = 8080L,   container_width = \"800px\",   container_height = \"800px\",   overwrite_network_json = TRUE,   verbose = TRUE )"},{"path":"https://ludvigla.github.io/semla/reference/CutSpatialNetwork.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cut spatial networks in folded tissues — CutSpatialNetwork","text":"object Seurat object created semla datadir directory containing network data image tiles sampleID integer specifying tissue section Seurat object host string valid IPv4 IPv6 address listen , Defaults localhost \"127.0.0.1\" port integer indicates port listen . container_width, container_height Set height width container overwrite_network_json Logical specifying JSON file containing spatial network overwritten completion verbose Print messages","code":""},{"path":"https://ludvigla.github.io/semla/reference/CutSpatialNetwork.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cut spatial networks in folded tissues — CutSpatialNetwork","text":"tbl_graph object ","code":""},{"path":"https://ludvigla.github.io/semla/reference/CutSpatialNetwork.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cut spatial networks in folded tissues — CutSpatialNetwork","text":"spot connected adjacent neighbors edges edges can cut holding SHIFT key moving cursor across . Cut edges can mended holding CTRL key moving cursor across . aim cut edges spots located separate layers. output tbl_graph object representing spatial network can processed AdjustTissueCoordinates perform \"digital unrolling\".","code":""},{"path":"https://ludvigla.github.io/semla/reference/CutSpatialNetwork.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cut spatial networks in folded tissues — CutSpatialNetwork","text":"tutorial can found [package website](https://ludvigla.github.io/semla/). Got tutorials -> Digital unrolling","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/reference/CutSpatialNetwork.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Cut spatial networks in folded tissues — CutSpatialNetwork","text":"Ludvig Larsson","code":""},{"path":"https://ludvigla.github.io/semla/reference/ExportDataForViewer.html","id":null,"dir":"Reference","previous_headings":"","what":"Export data for FeatureViewer — ExportDataForViewer","title":"Export data for FeatureViewer — ExportDataForViewer","text":"utility function used export data required FeatureViewer.","code":""},{"path":"https://ludvigla.github.io/semla/reference/ExportDataForViewer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Export data for FeatureViewer — ExportDataForViewer","text":"","code":"ExportDataForViewer(   object,   sampleIDs = NULL,   outdir = \"./\",   overwrite = FALSE,   verbose = TRUE )"},{"path":"https://ludvigla.github.io/semla/reference/ExportDataForViewer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Export data for FeatureViewer — ExportDataForViewer","text":"object Seurat object created semla sampleIDs integer vector specifying sampleIDs datasets export. default, samples exported. outdir character vector specifying path existing directory permission read write files. overwrite Overwrite files already exists verbose Print messages","code":""},{"path":"https://ludvigla.github.io/semla/reference/ExportDataForViewer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Export data for FeatureViewer — ExportDataForViewer","text":"path directory data saved","code":""},{"path":"https://ludvigla.github.io/semla/reference/ExportDataForViewer.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Export data for FeatureViewer — ExportDataForViewer","text":"FeatureViewer automatically attempt export files every time run. ExportDataForViewer, export files can provide output data path FeatureViewer look required files directory.","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/reference/ExportDataForViewer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Export data for FeatureViewer — ExportDataForViewer","text":"","code":"if (FALSE) { libary(semla)  se_mbrain <- readRDS(system.file(\"extdata/mousebrain\",                                  \"se_mbrain\",                                  package = \"semla\"))  # Export viewer files to current working directory ExportDataForViewer(se_mbrain, outdir = \"./\") }"},{"path":"https://ludvigla.github.io/semla/reference/FeatureViewer.html","id":null,"dir":"Reference","previous_headings":"","what":"Interactive spatial feature viewer — FeatureViewer","title":"Interactive spatial feature viewer — FeatureViewer","text":"FeatureViewer opens interactive shiny application one can zoom pan H&E image overlaying color selected features. also possible add new categorical features modify existing categorical features lasso tool.","code":""},{"path":"https://ludvigla.github.io/semla/reference/FeatureViewer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interactive spatial feature viewer — FeatureViewer","text":"","code":"FeatureViewer(   object,   slot = \"data\",   datadir = NULL,   selected_features = NULL,   sampleIDs = NULL,   host = \"127.0.0.1\",   port = 8080L,   custom_color_palettes = NULL,   categorical_colors = NULL,   container_width = 800,   container_height = 800,   verbose = TRUE )"},{"path":"https://ludvigla.github.io/semla/reference/FeatureViewer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interactive spatial feature viewer — FeatureViewer","text":"object Seurat object slot slot use Assay data datadir directory spatial data image tiles selected_features character vector features select viewer sampleIDs integer vector section IDs use viewer. sections used default. host string valid IPv4 IPv6 address listen , Defaults localhost \"127.0.0.1\" port integer indicates port listen . custom_color_palettes names list color vectors use custom color palettes categorical_colors named list character vectors color names. name character vector correspond categorical variable meta.data slot Seurat object. character vector named name corresponds label category. container_width, container_height Set height width container verbose Print messages","code":""},{"path":"https://ludvigla.github.io/semla/reference/FeatureViewer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interactive spatial feature viewer — FeatureViewer","text":"Seurat object","code":""},{"path":"https://ludvigla.github.io/semla/reference/FeatureViewer.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Interactive spatial feature viewer — FeatureViewer","text":"viewer requires tiled H&E image along additional image data work. default, function try create files export temporary directory, also possible export files running app provide path data directory datadir (see ExportDataForViewer). detailed tutorial can found semla website. can also get detailed instructions pressing help icon app.","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/reference/FeatureViewer.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Interactive spatial feature viewer — FeatureViewer","text":"Ludvig Larsson","code":""},{"path":"https://ludvigla.github.io/semla/reference/GetImages.html","id":null,"dir":"Reference","previous_headings":"","what":"Method to extract images from a Staffli object — GetImages","title":"Method to extract images from a Staffli object — GetImages","text":"Method extract images Staffli object","code":""},{"path":"https://ludvigla.github.io/semla/reference/GetImages.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method to extract images from a Staffli object — GetImages","text":"","code":"GetImages(object, type = \"raw\")  # S4 method for Staffli GetImages(object, type = \"raw\")  # S4 method for Seurat GetImages(object, type = \"raw\")"},{"path":"https://ludvigla.github.io/semla/reference/GetImages.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method to extract images from a Staffli object — GetImages","text":"object Staffli Seurat object type string specifying image type get","code":""},{"path":"https://ludvigla.github.io/semla/reference/GetImages.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Method to extract images from a Staffli object — GetImages","text":"","code":"# Load example data se_mbrain <- readRDS(system.file(\"extdata/mousebrain\", \"se_mbrain\", package = \"semla\")) |>     LoadImages() #>  #> ── Loading H&E images ── #>  #> ℹ Loading image from /private/var/folders/zb/1fj07x_5343fvs_k28gnm1z80002xs/T/RtmpFJGwBj/temp_libpath502354c29e9d/semla/extdata/mousebrain/spatial/tissue_hires_image.jpg #> ℹ Scaled image from 2000x1882 to 400x376 pixels #> ℹ Saving loaded H&E images as 'rasters' in Seurat object  # Fetch Staffli object staffli_object <- GetStaffli(se_mbrain)  # Fetch images from a Staffli object images <- GetImages(staffli_object)   # Load example data se_mbrain <- readRDS(system.file(\"extdata/mousebrain\", \"se_mbrain\", package = \"semla\")) |>     LoadImages() #>  #> ── Loading H&E images ── #>  #> ℹ Loading image from /private/var/folders/zb/1fj07x_5343fvs_k28gnm1z80002xs/T/RtmpFJGwBj/temp_libpath502354c29e9d/semla/extdata/mousebrain/spatial/tissue_hires_image.jpg #> ℹ Scaled image from 2000x1882 to 400x376 pixels #> ℹ Saving loaded H&E images as 'rasters' in Seurat object  # Fetch images from a Seurat object images <- GetImages(se_mbrain)"},{"path":"https://ludvigla.github.io/semla/reference/GetStaffli.html","id":null,"dir":"Reference","previous_headings":"","what":"Method used to extract a Staffli object from the tools slot of a\nStaffli object — GetStaffli","title":"Method used to extract a Staffli object from the tools slot of a\nStaffli object — GetStaffli","text":"Method used extract Staffli object tools slot Staffli object","code":""},{"path":"https://ludvigla.github.io/semla/reference/GetStaffli.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method used to extract a Staffli object from the tools slot of a\nStaffli object — GetStaffli","text":"","code":"GetStaffli(object)  # S4 method for Seurat GetStaffli(object)"},{"path":"https://ludvigla.github.io/semla/reference/GetStaffli.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method used to extract a Staffli object from the tools slot of a\nStaffli object — GetStaffli","text":"object Seurat object","code":""},{"path":"https://ludvigla.github.io/semla/reference/GetStaffli.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Method used to extract a Staffli object from the tools slot of a\nStaffli object — GetStaffli","text":"","code":"# Load example data se_mbrain <- readRDS(system.file(\"extdata/mousebrain\", \"se_mbrain\", package = \"semla\")) |>     LoadImages() #>  #> ── Loading H&E images ── #>  #> ℹ Loading image from /private/var/folders/zb/1fj07x_5343fvs_k28gnm1z80002xs/T/RtmpFJGwBj/temp_libpath502354c29e9d/semla/extdata/mousebrain/spatial/tissue_hires_image.jpg #> ℹ Scaled image from 2000x1882 to 400x376 pixels #> ℹ Saving loaded H&E images as 'rasters' in Seurat object  # Fetch Staffli object from a Seurat object staffli_object <- GetStaffli(se_mbrain)"},{"path":"https://ludvigla.github.io/semla/reference/ImageInfo.html","id":null,"dir":"Reference","previous_headings":"","what":"Method for extracting the raw H&E image information from a Staffli object — ImageInfo","title":"Method for extracting the raw H&E image information from a Staffli object — ImageInfo","text":"Method extracting raw H&E image information Staffli object","code":""},{"path":"https://ludvigla.github.io/semla/reference/ImageInfo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method for extracting the raw H&E image information from a Staffli object — ImageInfo","text":"","code":"ImageInfo(object)  # S4 method for Staffli ImageInfo(object)"},{"path":"https://ludvigla.github.io/semla/reference/ImageInfo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method for extracting the raw H&E image information from a Staffli object — ImageInfo","text":"object Staffli object","code":""},{"path":"https://ludvigla.github.io/semla/reference/ImageInfo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Method for extracting the raw H&E image information from a Staffli object — ImageInfo","text":"","code":"# Load example data se_mbrain <- readRDS(system.file(\"extdata/mousebrain\", \"se_mbrain\", package = \"semla\")) |>     LoadImages() #>  #> ── Loading H&E images ── #>  #> ℹ Loading image from /private/var/folders/zb/1fj07x_5343fvs_k28gnm1z80002xs/T/RtmpFJGwBj/temp_libpath502354c29e9d/semla/extdata/mousebrain/spatial/tissue_hires_image.jpg #> ℹ Scaled image from 2000x1882 to 400x376 pixels #> ℹ Saving loaded H&E images as 'rasters' in Seurat object  # Fetch Staffli object staffli_object <- GetStaffli(se_mbrain)  # Fetch image info image_info <- ImageInfo(staffli_object) image_info #> # A tibble: 1 × 10 #>   format width height full_width full_he…¹ color…² files…³ density sampl…⁴ type  #>   <chr>  <int>  <int>      <dbl>     <dbl> <chr>     <int> <chr>   <chr>   <chr> #> 1 JPEG    1882   2000     18107.    19242. sRGB    1030876 72x72   1       tiss… #> # … with abbreviated variable names ¹​full_height, ²​colorspace, ³​filesize, #> #   ⁴​sampleID"},{"path":"https://ludvigla.github.io/semla/reference/ImagePlot.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot H&E images — ImagePlot","title":"Plot H&E images — ImagePlot","text":"images loaded Seurat object LoadImages, function can used quickly plot images grid. applied transformations images, e.g. RigidTransformImages, can specify image_use = \"transformed\" plot transformed images instead.","code":""},{"path":"https://ludvigla.github.io/semla/reference/ImagePlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot H&E images — ImagePlot","text":"","code":"ImagePlot(   object,   label_by = NULL,   image_use = c(\"raw\", \"transformed\"),   crop_area = NULL,   sampleIDs = NULL,   ncol = NULL,   mar = c(1, 1, 1, 1),   return_as_gg = FALSE )"},{"path":"https://ludvigla.github.io/semla/reference/ImagePlot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot H&E images — ImagePlot","text":"object Seurat object label_by string specifying meta data column label plots . needs character factor multiple labels section allowed. image_use String specifying image type use, either 'raw' 'transformed' crop_area numeric vector length 4 specifying rectangular area crop plots . numbers within 0-1. x-axis goes left=0 right=1 y axis goes top=0 bottom=1. order values specified follows: crop_area = c(left, top, right, bottom). crop area used tissue sections set section individually. using crop areas different sizes different sections can lead unwanted side effects point sizes remain constant. case better generate separate plots different tissue sections. sampleIDs integer vector section numbers plot ncol integer value specifying number columns plot grid mar Margins around plot. See par details return_as_gg plot returned ggplot object?","code":""},{"path":"https://ludvigla.github.io/semla/reference/ImagePlot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot H&E images — ImagePlot","text":"Draws plot H&E images alternatively, returns patchwork composed ggplot objects","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/reference/ImagePlot.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plot H&E images — ImagePlot","text":"Ludvig Larsson","code":""},{"path":"https://ludvigla.github.io/semla/reference/ImagePlot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot H&E images — ImagePlot","text":"","code":"library(semla)  # Load example Visium data se_mbrain <- readRDS(system.file(\"extdata/mousebrain\", \"se_mbrain\", package = \"semla\")) se_mcolon <- readRDS(system.file(\"extdata/mousecolon\", \"se_mcolon\", package = \"semla\")) se_merged <- MergeSTData(se_mbrain, se_mcolon)  # ImagePlot will throw an error if no images are loaded if (FALSE) { ImagePlot(se_merged) }  # Load images se_merged <- LoadImages(se_merged) #>  #> ── Loading H&E images ── #>  #> ℹ Loading image from /private/var/folders/zb/1fj07x_5343fvs_k28gnm1z80002xs/T/RtmpFJGwBj/temp_libpath502354c29e9d/semla/extdata/mousebrain/spatial/tissue_hires_image.jpg #> ℹ Scaled image from 2000x1882 to 400x376 pixels #> ℹ Loading image from /private/var/folders/zb/1fj07x_5343fvs_k28gnm1z80002xs/T/RtmpFJGwBj/temp_libpath502354c29e9d/semla/extdata/mousecolon/spatial/tissue_hires_image.jpg #> ℹ Scaled image from 1804x2000 to 400x443 pixels #> ℹ Saving loaded H&E images as 'rasters' in Seurat object ImagePlot(se_merged)   # Plot only selected tissue sections ImagePlot(se_merged, sampleIDs = 1)   # Change order of plot ImagePlot(se_merged, sampleIDs = 2:1)   # Add a sample_id column and label plots se_merged$sample_id <- ifelse(GetStaffli(se_merged)@meta_data$sampleID == 1, \"brain\", \"colon\") ImagePlot(se_merged, label_by = \"sample_id\")   # Reload images in higher resolution, crop image and remove margins se_merged <- LoadImages(se_merged, image_height = 1e3) #>  #> ── Loading H&E images ── #>  #> ℹ Loading image from /private/var/folders/zb/1fj07x_5343fvs_k28gnm1z80002xs/T/RtmpFJGwBj/temp_libpath502354c29e9d/semla/extdata/mousebrain/spatial/tissue_hires_image.jpg #> ℹ Scaled image from 2000x1882 to 1000x941 pixels #> ℹ Loading image from /private/var/folders/zb/1fj07x_5343fvs_k28gnm1z80002xs/T/RtmpFJGwBj/temp_libpath502354c29e9d/semla/extdata/mousecolon/spatial/tissue_hires_image.jpg #> ℹ Scaled image from 1804x2000 to 1000x1109 pixels #> ℹ Saving loaded H&E images as 'rasters' in Seurat object se_merged <- LoadImages(se_merged, image_height = 1.5e3) #>  #> ── Loading H&E images ── #>  #> ℹ Loading image from /private/var/folders/zb/1fj07x_5343fvs_k28gnm1z80002xs/T/RtmpFJGwBj/temp_libpath502354c29e9d/semla/extdata/mousebrain/spatial/tissue_hires_image.jpg #> ℹ Scaled image from 2000x1882 to 1500x1412 pixels #> ℹ Loading image from /private/var/folders/zb/1fj07x_5343fvs_k28gnm1z80002xs/T/RtmpFJGwBj/temp_libpath502354c29e9d/semla/extdata/mousecolon/spatial/tissue_hires_image.jpg #> ℹ Scaled image from 1804x2000 to 1500x1663 pixels #> ℹ Saving loaded H&E images as 'rasters' in Seurat object ImagePlot(se_merged, crop_area = c(0.4, 0.4, 0.7, 0.7), sampleIDs = 1, mar = c(0, 0, 0, 0))  ImagePlot(se_merged, crop_area = c(0.45, 0.55, 0.65, 0.7), sampleIDs = 2, mar = c(0, 0, 0, 0))"},{"path":"https://ludvigla.github.io/semla/reference/ImageTransform.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply rotations and translations to an image — ImageTransform","title":"Apply rotations and translations to an image — ImageTransform","text":"function takes `magick-image` object input applies translations defined angle xy_offset arguments. output image dimensions remain input image dimensions, meaning transformation might result cropping image. want behavior, use `image_rotate` `magick` R package instead.","code":""},{"path":"https://ludvigla.github.io/semla/reference/ImageTransform.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply rotations and translations to an image — ImageTransform","text":"","code":"ImageTransform(im, angle = 0, xy_offset = c(0, 0), scalefactor = 1)"},{"path":"https://ludvigla.github.io/semla/reference/ImageTransform.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply rotations and translations to an image — ImageTransform","text":"im image class `magick-image` angle integer value specifying rotation angle [-360, 360] xy_offset numeric vector length 2 providing offsets along x- y-axis given pixels. values exceed image dimensions. scalefactor numeric value specifying scaling factor [0, 3]","code":""},{"path":"https://ludvigla.github.io/semla/reference/ImageTransform.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply rotations and translations to an image — ImageTransform","text":"object class `magick-image`","code":""},{"path":"https://ludvigla.github.io/semla/reference/ImageTransform.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Apply rotations and translations to an image — ImageTransform","text":"Ludvig Larsson","code":""},{"path":"https://ludvigla.github.io/semla/reference/ImageTransform.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply rotations and translations to an image — ImageTransform","text":"","code":"library(magick) library(semla) lowresimagefile <- system.file(\"extdata/mousebrain/spatial\",                                \"tissue_lowres_image.jpg\",                                package = \"semla\") im <- image_read(lowresimagefile)  # rotate image 45 degrees clockwise, move image 100 pixels to the right and 100 pixels down im_transformed <- ImageTransform(im, angle = 45, xy_offset = c(100, 100)) im_transformed #> # A tibble: 1 × 7 #>   format width height colorspace matte filesize density #>   <chr>  <int>  <int> <chr>      <lgl>    <int> <chr>   #> 1 png      565    600 sRGB       TRUE         0 72x72    # rotate image 45 degrees counter-clockwise, move image 100 pixels to the left and 20 pixels up im_transformed <- ImageTransform(im, angle = -45, xy_offset = c(-100, 20)) im_transformed #> # A tibble: 1 × 7 #>   format width height colorspace matte filesize density #>   <chr>  <int>  <int> <chr>      <lgl>    <int> <chr>   #> 1 png      565    600 sRGB       TRUE         0 72x72    # shrink image to helf width/height im_transformed <- ImageTransform(im, scalefactor = 0.5) im_transformed #> # A tibble: 1 × 7 #>   format width height colorspace matte filesize density #>   <chr>  <int>  <int> <chr>      <lgl>    <int> <chr>   #> 1 png      565    600 sRGB       FALSE        0 72x72"},{"path":"https://ludvigla.github.io/semla/reference/ImageTranslate.html","id":null,"dir":"Reference","previous_headings":"","what":"Function used to apply translations to an image object of class `magick-image` — ImageTranslate","title":"Function used to apply translations to an image object of class `magick-image` — ImageTranslate","text":"function takes `magick-image` object input applies translations  defined xy_offset argument. output image dimensions remain  input image dimensions, meaning transformation might result cropping  image.","code":""},{"path":"https://ludvigla.github.io/semla/reference/ImageTranslate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function used to apply translations to an image object of class `magick-image` — ImageTranslate","text":"","code":"ImageTranslate(im, xy_offset = NULL)"},{"path":"https://ludvigla.github.io/semla/reference/ImageTranslate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function used to apply translations to an image object of class `magick-image` — ImageTranslate","text":"im image class `magick-image` xy_offset numeric vector length 2 providing offsets along x- y-axis given pixels. values exceed image dimensions.","code":""},{"path":"https://ludvigla.github.io/semla/reference/ImageTranslate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function used to apply translations to an image object of class `magick-image` — ImageTranslate","text":"object class `magick-image`","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/reference/ImageTranslate.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Function used to apply translations to an image object of class `magick-image` — ImageTranslate","text":"Ludvig Larsson","code":""},{"path":"https://ludvigla.github.io/semla/reference/ImageTranslate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function used to apply translations to an image object of class `magick-image` — ImageTranslate","text":"","code":"library(magick) library(semla) lowresimagefile <- system.file(\"extdata/mousebrain/spatial\",                                \"tissue_lowres_image.jpg\",                                package = \"semla\") im <- image_read(lowresimagefile)  # move image 100 pixels to the right and 100 pixels down im_transformed <- ImageTranslate(im, xy_offset = c(100, 100)) im_transformed #> # A tibble: 1 × 7 #>   format width height colorspace matte filesize density #>   <chr>  <int>  <int> <chr>      <lgl>    <int> <chr>   #> 1 png      565    600 sRGB       TRUE         0 72x72    # move image 100 pixels to the left and 20 pixels up im_transformed <- ImageTranslate(im, xy_offset = c(-100, 20)) im_transformed #> # A tibble: 1 × 7 #>   format width height colorspace matte filesize density #>   <chr>  <int>  <int> <chr>      <lgl>    <int> <chr>   #> 1 png      565    600 sRGB       TRUE         0 72x72"},{"path":"https://ludvigla.github.io/semla/reference/LoadAndMergeMatrices.html","id":null,"dir":"Reference","previous_headings":"","what":"Load and merge multiple gene expression matrices — LoadAndMergeMatrices","title":"Load and merge multiple gene expression matrices — LoadAndMergeMatrices","text":"Gene expression matrices features rows spots columns.","code":""},{"path":"https://ludvigla.github.io/semla/reference/LoadAndMergeMatrices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Load and merge multiple gene expression matrices — LoadAndMergeMatrices","text":"","code":"LoadAndMergeMatrices(samplefiles, verbose = TRUE)"},{"path":"https://ludvigla.github.io/semla/reference/LoadAndMergeMatrices.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Load and merge multiple gene expression matrices — LoadAndMergeMatrices","text":"samplefiles Character vector file/directory paths. Paths specify .h5 .tsv/.tsv.gz files. Alternatively, paths specify directories including barcodes.tsv, features.tsv matrix.mtx files. verbose Print messages","code":""},{"path":"https://ludvigla.github.io/semla/reference/LoadAndMergeMatrices.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Load and merge multiple gene expression matrices — LoadAndMergeMatrices","text":"sparse matrix class dgCMatrix","code":""},{"path":"https://ludvigla.github.io/semla/reference/LoadAndMergeMatrices.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Load and merge multiple gene expression matrices — LoadAndMergeMatrices","text":"merging process makes sure genes detected present merged output. means gene missing certain dataset, spots dataset assigned 0 expression. Spot IDs renamed unique. Usually, spots named something similar : \"ACGCCTGACACGCGCT-1\", \"TACCGATCCAACACTT-1\" Since spot barcodes shared across datasets, risk spot IDs duplicated merging. avoid , prefix (e.g. \"-1\") replaced unique prefix loaded matrix: \"-1\", \"-2\", \"-3\", ...","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/reference/LoadAndMergeMatrices.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Load and merge multiple gene expression matrices — LoadAndMergeMatrices","text":"","code":"# Load and merge two gene expression matrices samples <-   c(     system.file(       \"extdata/mousebrain\",       \"filtered_feature_bc_matrix.h5\",       package = \"semla\"     ),     system.file(       \"extdata/mousecolon\",       \"filtered_feature_bc_matrix.h5\",       package = \"semla\"     )   ) mergedMatrix <- LoadAndMergeMatrices(samples) #> ℹ Loading matrices: #> →   Finished loading expression matrix 1 #> →   Finished loading expression matrix 2 #> ! There are only 188 gene shared across all matrices: #> →   Are you sure that the matrices share the same gene IDs? #> →   Are the datasets from the same species? #>  #> ℹ Merging matrices: #> ✔ There are 188 features and 5164 spots in the merged matrix."},{"path":"https://ludvigla.github.io/semla/reference/LoadSpatialCoordinates.html","id":null,"dir":"Reference","previous_headings":"","what":"Load and merge multiple coordinate tables — LoadSpatialCoordinates","title":"Load and merge multiple coordinate tables — LoadSpatialCoordinates","text":"Load coordinates 'tissue_positions_list.csv' files merge tibble.","code":""},{"path":"https://ludvigla.github.io/semla/reference/LoadSpatialCoordinates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Load and merge multiple coordinate tables — LoadSpatialCoordinates","text":"","code":"LoadSpatialCoordinates(   coordinatefiles,   remove_spots_outside_tissue = TRUE,   verbose = TRUE )"},{"path":"https://ludvigla.github.io/semla/reference/LoadSpatialCoordinates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Load and merge multiple coordinate tables — LoadSpatialCoordinates","text":"coordinatefiles Character vector file paths. Paths specify .csv files output spaceranger remove_spots_outside_tissue spots outside tissue removed? verbose Print messages","code":""},{"path":"https://ludvigla.github.io/semla/reference/LoadSpatialCoordinates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Load and merge multiple coordinate tables — LoadSpatialCoordinates","text":"object class tbl","code":""},{"path":"https://ludvigla.github.io/semla/reference/LoadSpatialCoordinates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Load and merge multiple coordinate tables — LoadSpatialCoordinates","text":"merging process makes sure genes detected present merged output. means gene missing certain dataset, spots dataset assigned 0 expression.","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/reference/LoadSpatialCoordinates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Load and merge multiple coordinate tables — LoadSpatialCoordinates","text":"","code":"library(semla)  # Load and merge coordinates from two samples coordinatefiles <-   c(system.file(\"extdata/mousebrain/spatial\",                 \"tissue_positions_list.csv\",                 package = \"semla\"),     system.file(\"extdata/mousecolon/spatial\",                 \"tissue_positions_list.csv\",                 package = \"semla\")) coordinates <- LoadSpatialCoordinates(coordinatefiles) #> ℹ Loading coordinates: #> →   Finished loading coordinates for sample 1 #> →   Finished loading coordinates for sample 2 #> ℹ Collected coordinates for 5164 spots."},{"path":"https://ludvigla.github.io/semla/reference/MapFeaturesSummary.html","id":null,"dir":"Reference","previous_headings":"","what":"Map features spatially and add a summary plot next to it — MapFeaturesSummary","title":"Map features spatially and add a summary plot next to it — MapFeaturesSummary","text":"function wrapped MapFeatures allows add boxplot, histogram, violin plot density histogram showing distribution selected feature next spatial feature plot.","code":""},{"path":"https://ludvigla.github.io/semla/reference/MapFeaturesSummary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map features spatially and add a summary plot next to it — MapFeaturesSummary","text":"","code":"MapFeaturesSummary(   object,   features,   slot = \"data\",   subplot_type = c(\"box\", \"violin\", \"histogram\", \"density\"),   image_use = NULL,   coords_use = \"raw\",   crop_area = NULL,   pt_size = 1,   pt_alpha = 1,   pt_stroke = 0,   scale_alpha = FALSE,   section_number = NULL,   label_by = NULL,   ncol = NULL,   colors = RColorBrewer::brewer.pal(n = 9, name = \"Reds\"),   fill_color = NULL,   scale = c(\"shared\", \"free\"),   override_plot_dims = FALSE,   max_cutoff = NULL,   min_cutoff = NULL,   ... )"},{"path":"https://ludvigla.github.io/semla/reference/MapFeaturesSummary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Map features spatially and add a summary plot next to it — MapFeaturesSummary","text":"object object features character vector features plot. features need fetchable link{FetchData} slot Slot pull features values subplot_type Select summary plot place next spatial plot: \"box\" : boxplot \"violin\" : violin plot \"histogram\" : histogram \"density\" : density histogram image_use character specifying image type use coords_use character specifying coordinate type use crop_area numeric vector length 4 specifying rectangular area crop plots . numbers within 0-1. x-axis goes left=0 right=1 y axis goes top=0 bottom=1. order values specified follows: crop_area = c(left, top, right, bottom). crop area used tissue sections set section individually. using crop areas different sizes different sections can lead unwanted side effects point sizes remain constant. case better generate separate plots different tissue sections. pt_size numeric value specifying point size passed geom_point pt_alpha numeric value 0 1 specifying point opacity passed geom_point. value 0 make points completely transparent value 1 make points completely opaque. pt_stroke numeric specifying point stroke width scale_alpha Logical specifying spot colors scaled together feature values. can useful want highlight regions higher feature values making background tissue visible. section_number integer select tissue section number subset data label_by Character length 1 providing column name object labels can used provide title subplot. column 1 label per tissue section. can useful need provide detailed information tissue sections. ncol Integer value specifying number columns output patchwork. parameter effect number features provided 1. Otherwise, patchwork arranged based arrange_features parameter. colors character vector colors use color scale. colors preferably consist set colors scientific color palette designed sequential data. useful palettes available RColorBrewer, viridis scico R packages. fill_color Fill color summary plot scale character vector length 1 specifying one \"shared\" \"free\" determine color bars structured. scale set \"shared\", color bars feature values shared across samples. scale set \"free\", color bars independent. override_plot_dims logical specifying whether image dimensions used define plot area. Setting override_plot_dims can useful situations tissue section covers small fraction capture area, create lot white space plots. min_cutoff, max_cutoff numeric value 0-1 specifying either lower (min_cutoff) upper (max_cutoff) limit data using quantile. arguments can useful make sure color map get dominated outliers. ... Arguments passed methods","code":""},{"path":"https://ludvigla.github.io/semla/reference/MapFeaturesSummary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Map features spatially and add a summary plot next to it — MapFeaturesSummary","text":"`patchwork` object","code":""},{"path":"https://ludvigla.github.io/semla/reference/MapFeaturesSummary.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Map features spatially and add a summary plot next to it — MapFeaturesSummary","text":"Note currently, 1 feature can selected","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/reference/MapFeaturesSummary.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Map features spatially and add a summary plot next to it — MapFeaturesSummary","text":"Lovisa Franzen","code":""},{"path":"https://ludvigla.github.io/semla/reference/MapFeaturesSummary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Map features spatially and add a summary plot next to it — MapFeaturesSummary","text":"","code":"# Prepare Seurat object se <- readRDS(system.file(\"extdata/mousebrain\",                           \"se_mbrain\",                            package = \"semla\"))  se <- se |>   NormalizeData()  # Add boxplot MapFeaturesSummary(se, features = \"Nrgn\", subplot_type = \"box\")   # Add violin plot MapFeaturesSummary(se, features = \"Nrgn\", subplot_type = \"violin\")   # Add histogram MapFeaturesSummary(se, features = \"Nrgn\", subplot_type = \"histogram\")   # Add density histogram MapFeaturesSummary(se, features = \"Nrgn\", subplot_type = \"density\")"},{"path":"https://ludvigla.github.io/semla/reference/MapLabelsSummary.html","id":null,"dir":"Reference","previous_headings":"","what":"Map features spatially and add a summary plot next to it — MapLabelsSummary","title":"Map features spatially and add a summary plot next to it — MapLabelsSummary","text":"function wrapped MapLabels adds stacked bar plot showing sample's proportions category selected column next spatial feature plot.","code":""},{"path":"https://ludvigla.github.io/semla/reference/MapLabelsSummary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map features spatially and add a summary plot next to it — MapLabelsSummary","text":"","code":"MapLabelsSummary(   object,   column_name,   bar_display = \"percent\",   bar_width = 1.2,   bar_label_size = 3,   image_use = NULL,   coords_use = \"raw\",   crop_area = NULL,   pt_size = 1,   pt_alpha = 1,   pt_stroke = 0,   hide_legend = TRUE,   section_number = NULL,   label_by = NULL,   ncol = NULL,   colors = NULL,   override_plot_dims = FALSE,   return_plot_list = FALSE,   drop_na = FALSE,   ... )"},{"path":"https://ludvigla.github.io/semla/reference/MapLabelsSummary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Map features spatially and add a summary plot next to it — MapLabelsSummary","text":"object object column_name character specifying meta data column holding categorical feature vector. bar_display character vector length 1 specifying one \"percent\" \"count\" bar plot display. Default set \"percent\". bar_width numeric value specifying width bar plot. Default set 1.2. bar_label_size numeric value specifying text size bar plot labels. Default set 3. image_use character specifying image type use. coords_use character specifying coordinate type use. crop_area numeric vector length 4 specifying rectangular area crop plots . numbers within 0-1. x-axis goes left=0 right=1 y axis goes top=0 bottom=1. order values specified follows: crop_area = c(left, top, right, bottom). crop area used tissue sections set section individually. using crop areas different sizes different sections can lead unwanted side effects point sizes remain constant. case better generate separate plots different tissue sections. pt_size numeric value specifying point size passed geom_point pt_alpha numeric value 0 1 specifying point opacity passed geom_point. value 0 make points completely transparent value 1 make points completely opaque. pt_stroke numeric specifying point stroke width hide_legend logical specifying whether hide label legend spatial plot. Set (TRUE) default. section_number integer select tissue section number subset data label_by character specifying column name object labels can used provide title subplot. column 1 label per tissue section. can useful need provide detailed information tissue sections. ncol integer value specifying number columns output patchwork. colors character vector colors use color scale. number colors match number labels present. override_plot_dims logical specifying whether image dimensions used define plot area. Setting override_plot_dims can useful situations tissue section covers small fraction capture area, create lot white space plots. effect can achieved crop_area crop area instead determined directly data. return_plot_list logical specifying whether plots return list `ggplot` objects. return_plot_list = FALSE (default), plots arranged `patchwork` drop_na logical specifying NA values dropped ... Arguments passed methods","code":""},{"path":"https://ludvigla.github.io/semla/reference/MapLabelsSummary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Map features spatially and add a summary plot next to it — MapLabelsSummary","text":"`patchwork` object","code":""},{"path":"https://ludvigla.github.io/semla/reference/MapLabelsSummary.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Map features spatially and add a summary plot next to it — MapLabelsSummary","text":"Note currently, 1 label can selected","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/reference/MapLabelsSummary.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Map features spatially and add a summary plot next to it — MapLabelsSummary","text":"Lovisa Franzen","code":""},{"path":"https://ludvigla.github.io/semla/reference/MapLabelsSummary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Map features spatially and add a summary plot next to it — MapLabelsSummary","text":"","code":"# Prepare Seurat object se <- readRDS(system.file(\"extdata/mousebrain\",                           \"se_mbrain\",                            package = \"semla\"))  se <- se |>   NormalizeData()  |>   ScaleData() |>   FindVariableFeatures() |>   RunPCA() |>   FindNeighbors(reduction = \"pca\", dims = 1:10) |>   FindClusters(resolution = 0.2) #> Centering and scaling data matrix #> PC_ 1  #> Positive:  Nrgn, Olfm1, Cck, Nptxr, Rtn1, Snca, Nov, Tmsb4x, Lamp5, Egr1  #> \t   Crym, Cpne6, Coro1a, Arc, Hpca, Sst, Nr4a1, Npy, Chgb, Neurod6  #> \t   Snap25, Myh7, Uchl1, Eef1a2, Cort, Grp, Stmn2, Rprm, Spink8, Mfge8  #> Negative:  Mbp, Plp1, Apod, Mobp, Ptgds, Mog, Mal, Mag, Cnp, Aldh1a1  #> \t   Opalin, Tcf7l2, Ddc, Lhx1os, Slc6a3, Ret, Th, Slc18a2, Sncg, Drd2  #> \t   Chrna6, Slc10a4, Spp1, En1, Dlk1, Calb2, Hbb-bs, Pvalb, Col1a2, Tnnt1  #> PC_ 2  #> Positive:  Myoc, Gfap, Col1a2, Fmod, Slc13a4, Hba-a1, Hbb-bt, Slc6a20a, Hba-a2, Hbb-bs  #> \t   Acta2, Tagln, Mgp, Ogn, Vtn, H2-Aa, Lyz2, Cd74, Myl9, Dcn  #> \t   Myh11, Ptgds, Cytl1, H2-Eb1, Hmgcs2, Clu, Mfge8, Emp1, Npy, Cnn1  #> Negative:  Th, Uchl1, Slc18a2, En1, Slc10a4, Slc6a3, Chrna6, Stmn2, Ret, Snap25  #> \t   Drd2, Dlk1, Ddc, Scg2, Sncg, Eef1a2, Rtn1, Chga, Pcp4, Calb2  #> \t   Mobp, Mbp, Chgb, Fabp5, Plp1, Pvalb, Mog, Mal, Mag, Snca  #> PC_ 3  #> Positive:  Trbc2, Arc, Egr1, Myl4, Nr4a1, Mbp, Mobp, Pvalb, Plp1, Opalin  #> \t   Mog, Mal, Cnp, Mag, Snap25, Lamp5, Ighm, Tcf7l2, Cplx3, Tgm3  #> \t   Ighg2c, Pcp4, Hpca, Ly6d, Eef1a2, Tnnt1, Chga, Neurod6, Prph, Ctgf  #> Negative:  Nnat, Slc18a2, Dlk1, Slc6a3, Slc10a4, En1, Th, Chrna6, Dcn, Sncg  #> \t   Cpne7, Drd2, Ddc, Ret, Hpcal1, Ecel1, Cpne6, Col1a2, Trh, Calb2  #> \t   Cd24a, Fmod, Mgp, Snca, Lypd1, Slc13a4, Fibcd1, Crym, Spink8, Slc6a20a  #> PC_ 4  #> Positive:  Nr4a1, Arc, Lamp5, Egr1, Myl4, Trbc2, Chrna6, Tagln, En1, Snap25  #> \t   Th, Slc18a2, Acta2, Col1a2, Myh11, Fmod, Hba-a2, Slc10a4, Slc6a3, Slc13a4  #> \t   Ret, Tgm3, Hbb-bt, Slc6a20a, Ighm, Hbb-bs, Hba-a1, Vtn, Mgp, Drd2  #> Negative:  Spink8, Fibcd1, Tmsb4x, Nnat, Lefty1, Crym, Cpne7, Nos1, Dcn, Cpne6  #> \t   Grp, Homer3, Htr3a, Tac1, Fabp5, C1ql2, Trh, Opalin, Mog, Plp1  #> \t   Mag, Calb2, Ecel1, Gfap, Cnp, Tcf7l2, Lypd1, Vgll3, Hpcal1, Mal  #> PC_ 5  #> Positive:  En1, Chrna6, Th, Slc18a2, Slc10a4, Ddc, Lefty1, Arc, Slc6a3, Neurod6  #> \t   Grp, Nov, Lamp5, Fibcd1, Nr4a1, Drd2, Spink8, Vip, Myl4, Ret  #> \t   Egr1, Dlk1, Nrgn, Gfap, Trbc2, Tgm3, Myh7, Tac2, Sncg, Npy  #> Negative:  Pcp4, Tcf7l2, Snap25, Uchl1, Eef1a2, Chga, Stmn2, Lhx1os, Calb2, Scg2  #> \t   Fabp5, Bok, Prkcd, Pvalb, Cartpt, Chgb, Tnnt1, Gpx3, Slc20a1, Rtn1  #> \t   C1ql2, Spp1, Hpcal1, Ptgds, Pitx2, Lypd1, Aldh1a1, Ecel1, Vtn, Nme7  #> Computing nearest neighbor graph #> Computing SNN #> Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck #>  #> Number of nodes: 2560 #> Number of edges: 85218 #>  #> Running Louvain algorithm... #> Maximum modularity in 10 random starts: 0.9096 #> Number of communities: 6 #> Elapsed time: 0 seconds  # Plot clusters MapLabelsSummary(se, column_name = \"seurat_clusters\", override_plot_dims = TRUE)"},{"path":"https://ludvigla.github.io/semla/reference/ModifyPatchworkTitles.html","id":null,"dir":"Reference","previous_headings":"","what":"Modify patchwork titles — ModifyPatchworkTitles","title":"Modify patchwork titles — ModifyPatchworkTitles","text":"Takes patchwork object input produced MapFeatures MapLabels moves legends right side.","code":""},{"path":"https://ludvigla.github.io/semla/reference/ModifyPatchworkTitles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Modify patchwork titles — ModifyPatchworkTitles","text":"","code":"ModifyPatchworkTitles(p, titles)"},{"path":"https://ludvigla.github.io/semla/reference/ModifyPatchworkTitles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Modify patchwork titles — ModifyPatchworkTitles","text":"p patchwork object titles character vector matching number patches p","code":""},{"path":"https://ludvigla.github.io/semla/reference/ModifyPatchworkTitles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Modify patchwork titles — ModifyPatchworkTitles","text":"patchwork object","code":""},{"path":"https://ludvigla.github.io/semla/reference/ModifyPatchworkTitles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Modify patchwork titles — ModifyPatchworkTitles","text":"","code":"library(semla)  se_mbrain <- readRDS(system.file(\"extdata/mousebrain\",                                   \"se_mbrain\",                                   package = \"semla\"))                                   # With MapFeatures p <- MapFeatures(se_mbrain, c(\"nFeature_Spatial\", \"nCount_Spatial\")) ModifyPatchworkTitles(p, titles = c(\"First\", \"Second\"))   # With MapLabels p <- MapLabels(se_mbrain, c(\"sample_id\")) ModifyPatchworkTitles(p, titles = \"My title\")"},{"path":"https://ludvigla.github.io/semla/reference/PlotFeatureLoadings.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot feature loadings for dimensional reduction data — PlotFeatureLoadings","title":"Plot feature loadings for dimensional reduction data — PlotFeatureLoadings","text":"function can used visualize relative contribution features (e.g. genes) dimensionality reduction vectors. function provides three modes draw bar plot, dot plot heatmap.","code":""},{"path":"https://ludvigla.github.io/semla/reference/PlotFeatureLoadings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot feature loadings for dimensional reduction data — PlotFeatureLoadings","text":"","code":"PlotFeatureLoadings(   object,   dims = 1,   reduction = \"pca\",   nfeatures = 30,   mode = c(\"dotplot\", \"barplot\", \"heatmap\"),   type = c(\"positive\", \"negative\", \"centered\"),   fill = \"lightgrey\",   color = \"black\",   bar_width = 0.9,   pt_size = 4,   pt_stroke = 0.5,   linetype = \"dashed\",   color_by_loadings = FALSE,   gradient_colors = RColorBrewer::brewer.pal(n = 9, name = \"Reds\"),   ncols = NULL )"},{"path":"https://ludvigla.github.io/semla/reference/PlotFeatureLoadings.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot feature loadings for dimensional reduction data — PlotFeatureLoadings","text":"object object class Seurat dims integer vector dimensions plot feature loadings reduction character specifying dimensionality reduction use nfeatures Number features show mode Plot mode. One \"barplot\", \"dotplot\" \"heatmap\" type Mode used select features: \"positive\" : select features highest loadings \"negative\" : select features lowest loadings \"centered\" : split selection features include top bottom loadings fill Fill color barplot dotplot color Border color barplot dotplot bar_width barplot provided proportion pt_size Size points dotplot pt_stroke Width border points dotplot linetype Select line type used dotplot, e.g. \"solid\", \"longdash\" \"blank\" color_by_loadings fill color barplot points reflect feature loadings? gradient_colors Colors use gradient color_by_loadings=TRUE ncols Number columns used final patchwork","code":""},{"path":"https://ludvigla.github.io/semla/reference/PlotFeatureLoadings.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot feature loadings for dimensional reduction data — PlotFeatureLoadings","text":"object class patchwork","code":""},{"path":"https://ludvigla.github.io/semla/reference/PlotFeatureLoadings.html","id":"select-type","dir":"Reference","previous_headings":"","what":"Select type","title":"Plot feature loadings for dimensional reduction data — PlotFeatureLoadings","text":"centered dimensionality reduction vectors, principal components, best select features highest lowest loadings. types dimensionality reduction results, likely better select features highest loadings, case type=\"positive\" appropriate choice.","code":""},{"path":"https://ludvigla.github.io/semla/reference/PlotFeatureLoadings.html","id":"select-mode","dir":"Reference","previous_headings":"","what":"Select mode","title":"Plot feature loadings for dimensional reduction data — PlotFeatureLoadings","text":"barplots dotplots can used get detailed information loadings individual factors whereas heatmap useful summarize loadings multiple factors. heatmap option override type options select top features. heatmap mode, values data also scaled within dimensionality reduction vectors range 0 1.","code":""},{"path":"https://ludvigla.github.io/semla/reference/PlotFeatureLoadings.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot feature loadings for dimensional reduction data — PlotFeatureLoadings","text":"","code":"{ library(semla)  se_mbrain <- readRDS(system.file(\"extdata/mousebrain\", \"se_mbrain\", package = \"semla\"))  # Run PCA se_mbrain <- se_mbrain |>                 ScaleData() |>                 RunPCA()  # Plot feature loadings for PC_1 as a dotplot PlotFeatureLoadings(se_mbrain, reduction = \"pca\", dims = 1,                     mode = \"dotplot\", type = \"centered\")  # Plot feature loadings for PC_1 and PC_2 as barplots PlotFeatureLoadings(se_mbrain, reduction = \"pca\", dims = 1:2,                     mode = \"barplot\", type = \"centered\")  # Plot feature loadings for PC_1 and color bars by loading PlotFeatureLoadings(se_mbrain, reduction = \"pca\", dims = 1:2,                     mode = \"barplot\", type = \"centered\",                     color_by_loadings = TRUE,                     gradient_colors = RColorBrewer::brewer.pal(n = 11, name = \"RdBu\") |> rev()) } #> Centering and scaling data matrix #> PC_ 1  #> Positive:  Nrgn, Olfm1, Cck, Nptxr, Rtn1, Snca, Nov, Tmsb4x, Lamp5, Egr1  #> \t   Crym, Cpne6, Coro1a, Arc, Hpca, Sst, Nr4a1, Npy, Chgb, Neurod6  #> \t   Snap25, Myh7, Uchl1, Eef1a2, Cort, Grp, Stmn2, Rprm, Spink8, Mfge8  #> Negative:  Mbp, Plp1, Apod, Mobp, Ptgds, Mog, Mal, Mag, Cnp, Aldh1a1  #> \t   Opalin, Tcf7l2, Ddc, Lhx1os, Slc6a3, Ret, Th, Slc18a2, Sncg, Drd2  #> \t   Chrna6, Slc10a4, Spp1, En1, Dlk1, Calb2, Hbb-bs, Pvalb, Col1a2, Tnnt1  #> PC_ 2  #> Positive:  Myoc, Gfap, Col1a2, Fmod, Slc13a4, Hba-a1, Hbb-bt, Slc6a20a, Hba-a2, Hbb-bs  #> \t   Acta2, Tagln, Mgp, Ogn, Vtn, H2-Aa, Lyz2, Cd74, Myl9, Dcn  #> \t   Myh11, Ptgds, Cytl1, H2-Eb1, Hmgcs2, Clu, Mfge8, Emp1, Npy, Cnn1  #> Negative:  Th, Uchl1, Slc18a2, En1, Slc10a4, Slc6a3, Chrna6, Stmn2, Ret, Snap25  #> \t   Drd2, Dlk1, Ddc, Scg2, Sncg, Eef1a2, Rtn1, Chga, Pcp4, Calb2  #> \t   Mobp, Mbp, Chgb, Fabp5, Plp1, Pvalb, Mog, Mal, Mag, Snca  #> PC_ 3  #> Positive:  Trbc2, Arc, Egr1, Myl4, Nr4a1, Mbp, Mobp, Pvalb, Plp1, Opalin  #> \t   Mog, Mal, Cnp, Mag, Snap25, Lamp5, Ighm, Tcf7l2, Cplx3, Tgm3  #> \t   Ighg2c, Pcp4, Hpca, Ly6d, Eef1a2, Tnnt1, Chga, Neurod6, Prph, Ctgf  #> Negative:  Nnat, Slc18a2, Dlk1, Slc6a3, Slc10a4, En1, Th, Chrna6, Dcn, Sncg  #> \t   Cpne7, Drd2, Ddc, Ret, Hpcal1, Ecel1, Cpne6, Col1a2, Trh, Calb2  #> \t   Cd24a, Fmod, Mgp, Snca, Lypd1, Slc13a4, Fibcd1, Crym, Spink8, Slc6a20a  #> PC_ 4  #> Positive:  Nr4a1, Arc, Lamp5, Egr1, Myl4, Trbc2, Chrna6, Tagln, En1, Snap25  #> \t   Th, Slc18a2, Acta2, Col1a2, Myh11, Fmod, Hba-a2, Slc10a4, Slc6a3, Slc13a4  #> \t   Ret, Tgm3, Hbb-bt, Slc6a20a, Ighm, Hbb-bs, Hba-a1, Vtn, Mgp, Drd2  #> Negative:  Spink8, Fibcd1, Tmsb4x, Nnat, Lefty1, Crym, Cpne7, Nos1, Dcn, Cpne6  #> \t   Grp, Homer3, Htr3a, Tac1, Fabp5, C1ql2, Trh, Opalin, Mog, Plp1  #> \t   Mag, Calb2, Ecel1, Gfap, Cnp, Tcf7l2, Lypd1, Vgll3, Hpcal1, Mal  #> PC_ 5  #> Positive:  En1, Chrna6, Th, Slc18a2, Slc10a4, Ddc, Lefty1, Arc, Slc6a3, Neurod6  #> \t   Grp, Nov, Lamp5, Fibcd1, Nr4a1, Drd2, Spink8, Vip, Myl4, Ret  #> \t   Egr1, Dlk1, Nrgn, Gfap, Trbc2, Tgm3, Myh7, Tac2, Sncg, Npy  #> Negative:  Pcp4, Tcf7l2, Snap25, Uchl1, Eef1a2, Chga, Stmn2, Lhx1os, Calb2, Scg2  #> \t   Fabp5, Bok, Prkcd, Pvalb, Cartpt, Chgb, Tnnt1, Gpx3, Slc20a1, Rtn1  #> \t   C1ql2, Spp1, Hpcal1, Ptgds, Pitx2, Lypd1, Aldh1a1, Ecel1, Vtn, Nme7"},{"path":"https://ludvigla.github.io/semla/reference/ReadVisiumData.html","id":null,"dir":"Reference","previous_headings":"","what":"Read spaceranger output files — ReadVisiumData","title":"Read spaceranger output files — ReadVisiumData","text":"function serves wrapper LoadAndMergeMatrices LoadSpatialCoordinates load spaceranger output files create Seurat object. spatial information, .e. images spot coordinates, stored inside tools slot Seurat object Staffli object.","code":""},{"path":"https://ludvigla.github.io/semla/reference/ReadVisiumData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read spaceranger output files — ReadVisiumData","text":"","code":"ReadVisiumData(   infoTable,   assay = \"Spatial\",   remove_spots_outside_HE = FALSE,   remove_spots_outside_tissue = TRUE,   verbose = TRUE,   ... )"},{"path":"https://ludvigla.github.io/semla/reference/ReadVisiumData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read spaceranger output files — ReadVisiumData","text":"infoTable data.frame tbl paths spaceranger output files assay Assay name (default = \"Spatial\") remove_spots_outside_HE spots outside H&E removed? option can useful CytAssist data H&E image cover smaller part entire tissue section. remove_spots_outside_tissue spots outside tissue removed? verbose Print messages ... Parameters passed CreateSeuratObject","code":""},{"path":"https://ludvigla.github.io/semla/reference/ReadVisiumData.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read spaceranger output files — ReadVisiumData","text":"Seurat object additional spatial information stored Staffli object","code":""},{"path":"https://ludvigla.github.io/semla/reference/ReadVisiumData.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read spaceranger output files — ReadVisiumData","text":"ReadVisiumData takes data.frame like table input hold certain spaceranger output file paths. table consist four columns: \"samples\", \"imgs\", \"spotfiles\" \"json\". \"samples\" : file paths expression matrices, e.g. filtered_bc_matrix.h5 \"imgs\" : file paths images, e.g. tissue_hires_image.jpg \"spotfiles\" : file paths spot coordinate CSV files tissue_positions_list.csv \"json\" : file paths scale factor JSON files, e.g. scalefactors_json.json.     also possible provide custom scale factors (info ).","code":""},{"path":"https://ludvigla.github.io/semla/reference/ReadVisiumData.html","id":"custom-scale-factors","dir":"Reference","previous_headings":"","what":"Custom scale factors","title":"Read spaceranger output files — ReadVisiumData","text":"can provide additional column named 'scalefactor' custom scale factor values. values 0 1, 1 correspond original H&E image used input spaceranger. instance, image scaled height 30,000 pixels height 3,000 pixels (aspect ratio), scalefactor 0.1.","code":""},{"path":"https://ludvigla.github.io/semla/reference/ReadVisiumData.html","id":"load-data-outside-tissue-section","dir":"Reference","previous_headings":"","what":"Load data outside tissue section","title":"Read spaceranger output files — ReadVisiumData","text":"Sometimes can useful load data spots 10x Visium dataset, need explore transcripts captured outside tissue. case, can provide paths raw_feature_bc_matrix.h5 files spaceranger output folders set remove_spots_outside_tissue = FALSE.","code":""},{"path":"https://ludvigla.github.io/semla/reference/ReadVisiumData.html","id":"filter-data","dir":"Reference","previous_headings":"","what":"Filter data","title":"Read spaceranger output files — ReadVisiumData","text":"want filter spots features, can pass min.cells min.features parameters (see CreateSeuratObject details); however, recommended use SubsetSTData function filtering object created.","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/reference/ReadVisiumData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read spaceranger output files — ReadVisiumData","text":"","code":"# Assemble spaceranger output files samples <-   Sys.glob(paths = paste0(system.file(\"extdata\", package = \"semla\"),                           \"/*/filtered_feature_bc_matrix.h5\")) imgs <-   Sys.glob(paths = paste0(system.file(\"extdata\", package = \"semla\"),                           \"/*/spatial/tissue_hires_image.jpg\")) spotfiles <-   Sys.glob(paths = paste0(system.file(\"extdata\", package = \"semla\"),                           \"/*/spatial/tissue_positions_list.csv\")) json <-   Sys.glob(paths = paste0(system.file(\"extdata\", package = \"semla\"),                           \"/*/spatial/scalefactors_json.json\"))  # Create a tibble/data.frame with file paths library(tibble) infoTable <- tibble(samples, imgs, spotfiles, json, sample_id = c(\"mousebrain\", \"mousecolon\"))  # Create Seurat object se <- ReadVisiumData(infoTable = infoTable) #>  #> ── Reading 10x Visium data ── #>  #> ℹ Loading matrices: #> →   Finished loading expression matrix 1 #> →   Finished loading expression matrix 2 #> ! There are only 188 gene shared across all matrices: #> →   Are you sure that the matrices share the same gene IDs? #> →   Are the datasets from the same species? #>  #> ℹ Merging matrices: #> ✔ There are 188 features and 5164 spots in the merged matrix. #> ℹ Loading coordinates: #> →   Finished loading coordinates for sample 1 #> →   Finished loading coordinates for sample 2 #> ℹ Collected coordinates for 5164 spots. #>  #> ── Creating `Seurat` object  #> ✔ Expression matrices and coordinates are compatible #> ℹ Created `Seurat` object #> ℹ Created `Staffli` object #> ✔ Returning a `Seurat` object with 188 features and 5164 spots se #> An object of class Seurat  #> 188 features across 5164 samples within 1 assay  #> Active assay: Spatial (188 features, 0 variable features)"},{"path":"https://ludvigla.github.io/semla/reference/STUtility2-package.html","id":null,"dir":"Reference","previous_headings":"","what":"STUtility2: Process, analyze and visualize Spatially Resolved Transcriptomcis data — STUtility2-package","title":"STUtility2: Process, analyze and visualize Spatially Resolved Transcriptomcis data — STUtility2-package","text":"STUtility2 collects useful tools Spatially Resolved Transcriptomics data analysis visualization.","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/reference/STUtility2-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"STUtility2: Process, analyze and visualize Spatially Resolved Transcriptomcis data — STUtility2-package","text":"Maintainer: Ludvig Larsson ludvig.larsson@scilifelab.se (ORCID) Authors: Lovisa Franzen lovisa.franzen@scilifelab.se (ORCID)","code":""},{"path":"https://ludvigla.github.io/semla/reference/Staffli-class.html","id":null,"dir":"Reference","previous_headings":"","what":"The Staffli Class — Staffli-class","title":"The Staffli Class — Staffli-class","text":"Staffli object designed hold information spatial data generated 10x Visium SRT experiment. includes paths images, spot coordinates well loaded images `raster` format additional information images.","code":""},{"path":"https://ludvigla.github.io/semla/reference/Staffli-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"The Staffli Class — Staffli-class","text":"imgs character vector paths raw images rasterlists list lists containing images 'raster' format meta_data tibble spot coordinates additional meta data image_height height scaled images pixels image_info tibble information raw images scalefactors tibble information scalefactors used convert coordinates original image -scaled representations \"tissue_lowres_image.jpg\" pixels_per_um Numeric vector specifying number pixels raw images corresponds 1 micrometer version Package version.","code":""},{"path":"https://ludvigla.github.io/semla/reference/Staffli-class.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"The Staffli Class — Staffli-class","text":"Ludvig Larsson","code":""},{"path":"https://ludvigla.github.io/semla/reference/Staffli-get-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Method used to get meta data from a Staffli object — [[,Staffli,ANY,ANY-method","title":"Method used to get meta data from a Staffli object — [[,Staffli,ANY,ANY-method","text":"Method used get meta data Staffli object","code":""},{"path":"https://ludvigla.github.io/semla/reference/Staffli-get-methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method used to get meta data from a Staffli object — [[,Staffli,ANY,ANY-method","text":"","code":"# S4 method for Staffli,ANY,ANY [[(x, i, j, drop = F)"},{"path":"https://ludvigla.github.io/semla/reference/Staffli-get-methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method used to get meta data from a Staffli object — [[,Staffli,ANY,ANY-method","text":"x object extract element(s). row indices specifying elements extract. j column indices specifying elements extract. drop TRUE result coerced lowest possible dimension. works extracting elements, replacement.","code":""},{"path":"https://ludvigla.github.io/semla/reference/Staffli-get-methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Method used to get meta data from a Staffli object — [[,Staffli,ANY,ANY-method","text":"","code":"# Load example data se_mbrain <- readRDS(system.file(\"extdata/mousebrain\", \"se_mbrain\", package = \"semla\")) |>     LoadImages() #>  #> ── Loading H&E images ── #>  #> ℹ Loading image from /private/var/folders/zb/1fj07x_5343fvs_k28gnm1z80002xs/T/RtmpFJGwBj/temp_libpath502354c29e9d/semla/extdata/mousebrain/spatial/tissue_hires_image.jpg #> ℹ Scaled image from 2000x1882 to 400x376 pixels #> ℹ Saving loaded H&E images as 'rasters' in Seurat object  # Fetch Staffli object staffli_object <- GetStaffli(se_mbrain)  # Get meta_data from a staffli object meta_data <- staffli_object[[]]"},{"path":"https://ludvigla.github.io/semla/reference/Staffli-set-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Method used to set meta data in a Staffli object — [[<-,Staffli,ANY,ANY,ANY-method","title":"Method used to set meta data in a Staffli object — [[<-,Staffli,ANY,ANY,ANY-method","text":"Method used set meta data Staffli object","code":""},{"path":"https://ludvigla.github.io/semla/reference/Staffli-set-methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method used to set meta data in a Staffli object — [[<-,Staffli,ANY,ANY,ANY-method","text":"","code":"# S4 method for Staffli,ANY,ANY,ANY [[(x, i, j, ...) <- value"},{"path":"https://ludvigla.github.io/semla/reference/Staffli-set-methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method used to set meta data in a Staffli object — [[<-,Staffli,ANY,ANY,ANY-method","text":"x object replace element(s). row indices specifying elements replace. j column indices specifying elements replace. ... additional parameters value Data add meta data data.frame.","code":""},{"path":"https://ludvigla.github.io/semla/reference/ThemeClean.html","id":null,"dir":"Reference","previous_headings":"","what":"Clean theme — ThemeClean","title":"Clean theme — ThemeClean","text":"Removes titles, subtitles legends patchwork object","code":""},{"path":"https://ludvigla.github.io/semla/reference/ThemeClean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clean theme — ThemeClean","text":"","code":"ThemeClean()"},{"path":"https://ludvigla.github.io/semla/reference/ThemeClean.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clean theme — ThemeClean","text":"theme object","code":""},{"path":"https://ludvigla.github.io/semla/reference/ThemeClean.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Clean theme — ThemeClean","text":"","code":"library(semla)  se_mbrain <- readRDS(system.file(\"extdata/mousebrain\",                                   \"se_mbrain\",                                   package = \"semla\"))                                   # With MapFeatures MapFeatures(se_mbrain, c(\"nFeature_Spatial\", \"nCount_Spatial\")) &    ThemeClean()"},{"path":"https://ludvigla.github.io/semla/reference/ThemeLegendRight.html","id":null,"dir":"Reference","previous_headings":"","what":"Move legend to right side — ThemeLegendRight","title":"Move legend to right side — ThemeLegendRight","text":"Move legends patchwork object right hand side plots","code":""},{"path":"https://ludvigla.github.io/semla/reference/ThemeLegendRight.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Move legend to right side — ThemeLegendRight","text":"","code":"ThemeLegendRight()"},{"path":"https://ludvigla.github.io/semla/reference/ThemeLegendRight.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Move legend to right side — ThemeLegendRight","text":"theme object","code":""},{"path":"https://ludvigla.github.io/semla/reference/ThemeLegendRight.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Move legend to right side — ThemeLegendRight","text":"","code":"library(semla)  se_mbrain <- readRDS(system.file(\"extdata/mousebrain\",                                   \"se_mbrain\",                                   package = \"semla\"))                                   # With MapFeatures MapFeatures(se_mbrain, c(\"nFeature_Spatial\", \"nCount_Spatial\")) &    ThemeLegendRight()"},{"path":"https://ludvigla.github.io/semla/reference/TileImage.html","id":null,"dir":"Reference","previous_headings":"","what":"Tile an H&E image — TileImage","title":"Tile an H&E image — TileImage","text":"function takes image class `magick-image` create tile map. size tile 256x256 pixels number zoom levels determined automatically.","code":""},{"path":"https://ludvigla.github.io/semla/reference/TileImage.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tile an H&E image — TileImage","text":"","code":"TileImage(   im,   sampleID = 1,   outpath = NULL,   maxZoomLevel = 4,   maxImgWidth = 10000,   nCores = detectCores() - 1,   overwrite = FALSE,   verbose = TRUE )"},{"path":"https://ludvigla.github.io/semla/reference/TileImage.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tile an H&E image — TileImage","text":"im image class `magick-image` sampleID section number use. number appended output files names outpath string specifying output directory save tiled image . provided, temporary directory created maxZoomLevel Max zoom level maxImgWidth Safety threshold make sure zoom level get deep. nCores Number cores use threading overwrite folder '<outpath>/viwer_data' already exists, overwritten. verbose Print messages","code":""},{"path":"https://ludvigla.github.io/semla/reference/TileImage.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tile an H&E image — TileImage","text":"Path tiles","code":""},{"path":"https://ludvigla.github.io/semla/reference/TileImage.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Tile an H&E image — TileImage","text":"Ludvig Larsson","code":""},{"path":"https://ludvigla.github.io/semla/reference/TileImage.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tile an H&E image — TileImage","text":"","code":"if (FALSE) { if (!requireNamespace(\"shiny\"))   install.packages(\"shiny\") if (!requireNamespace(\"leaflet\"))   install.packages(\"leaflet\") library(magick) library(shiny) library(leaflet)  # Load H&E image with magick imfile <-   system.file(\"extdata/mousecolon/spatial\",               \"tissue_hires_image.jpg\",               package = \"semla\") im <- image_read(imfile)  # tile image and return path to tiles tile_res <- TileImage(im, nCores = 2)  # Create a simple viewer with leaflet ui <- fluidPage(   leafletOutput(\"map\", height = 512, width = 512), )  server <- function(input, output, session) {   addResourcePath(\"mytiles\", tile_res$tilepath)   output$map <- renderLeaflet({     leaflet(options = leafletOptions(preferCanvas = TRUE)) %>%       addTiles(urlTemplate = \"/mytiles/{z}/{x}_{y}.jpg\",                options = tileOptions(continuousWorld = TRUE,                                      tileSize = \"256\",                                      minZoom = 1,                                      maxZoom = 3))   }) } shinyApp(ui, server) }"},{"path":"https://ludvigla.github.io/semla/reference/UpdateSTUtilityV1Object.html","id":null,"dir":"Reference","previous_headings":"","what":"Update an STUtility v1 object to work with `semla` — UpdateSTUtilityV1Object","title":"Update an STUtility v1 object to work with `semla` — UpdateSTUtilityV1Object","text":"features longer available updating STUtility v1 object. STUtility v1 objects store information scaling factors convert pixels real distances set limitations visualization methods spatial functions. mitigate issues, can either reload data raw space ranger output files manually add missing information stored \"scalefactors_json.json\" files.","code":""},{"path":"https://ludvigla.github.io/semla/reference/UpdateSTUtilityV1Object.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update an STUtility v1 object to work with `semla` — UpdateSTUtilityV1Object","text":"","code":"UpdateSTUtilityV1Object(object, verbose = TRUE)"},{"path":"https://ludvigla.github.io/semla/reference/UpdateSTUtilityV1Object.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update an STUtility v1 object to work with `semla` — UpdateSTUtilityV1Object","text":"object `Seurat` object created STUtility v1 verbose Print messages","code":""},{"path":"https://ludvigla.github.io/semla/reference/UpdateSTUtilityV1Object.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update an STUtility v1 object to work with `semla` — UpdateSTUtilityV1Object","text":"`Seurat` object compatible semla","code":""},{"path":"https://ludvigla.github.io/semla/reference/UpdateSTUtilityV1Object.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Update an STUtility v1 object to work with `semla` — UpdateSTUtilityV1Object","text":"Ludvig Larsson","code":""},{"path":"https://ludvigla.github.io/semla/reference/celltype-prediction-mixed.html","id":null,"dir":"Reference","previous_headings":"","what":"Mixed cell type prediction with NNLS (experimental) — RunMixedNNLS","title":"Mixed cell type prediction with NNLS (experimental) — RunMixedNNLS","text":"function can used obtain proportion estimates mixture cell types unknown factors. input spatial expression matrix first deconvolved using Non-negative Matrix Factorization (NMF) rank set number cell types + k additional factors. estimated factor expression profiles compared cell type expression profiles computing pairwise correlation scores. Factor expression profiles lowest correlation scores kept combined cell type expression profiles predict proportions directly spatial data using Non-negative Least Squares (NNLS).","code":""},{"path":"https://ludvigla.github.io/semla/reference/celltype-prediction-mixed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mixed cell type prediction with NNLS (experimental) — RunMixedNNLS","text":"","code":"RunMixedNNLS(object, ...)  # S3 method for default RunMixedNNLS(   object,   singlecell_matrix,   groups,   k = 10L,   nCells_per_group = 50L,   minCells_per_celltype = 10L,   min_prop = 0.01,   L1 = 0.01,   seed = 1337L,   return_expression_profiles = FALSE,   verbose = TRUE,   ... )  # S3 method for Seurat RunMixedNNLS(   object,   singlecell_object,   groups = NULL,   k = 10L,   features = NULL,   singlecell_assay = \"RNA\",   spatial_assay = \"Spatial\",   slot = \"data\",   min_prop = 0.01,   nCells_per_group = 50L,   minCells_per_celltype = 10L,   assay_name = \"celltypepropsmixed\",   dimred_name = \"nnlsmixed\",   return_as_dimred = FALSE,   L1 = 0.01,   seed = 1337L,   verbose = TRUE,   ... )"},{"path":"https://ludvigla.github.io/semla/reference/celltype-prediction-mixed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mixed cell type prediction with NNLS (experimental) — RunMixedNNLS","text":"object matrix-like object 10x Visium data ... Arguments passed methods singlecell_matrix matrix-like object scRNA-seq data groups character vector length ncol(singlecell_matrix) cell type labels. `Seurat` objects, one can omit groups case current identity used instead. Alternatively, string can provided specifying column use `singlecell_object` meta.data slot. k integer specifying number factors compute nCells_per_group cell type sampled number computing cell type expression profiles. mainly used speed computation. Note cell type fewer nCells_per_group cells, cells sampled replacement obtain nCells_per_group cells. minCells_per_celltype Minimum number cells allowed per cell type min_prop Minimum proportion allowed. proportion values lower threshold removed remaining proportions rescaled. L1 lasso penalty seed integer set seed reproducibility return_expression_profiles Logical specifying expression profile matrix also returned verbose Print messages singlecell_object Seurat object single-cell gene expression data features Features use computation. features provided, intersection variable features sc_object st_object used. Note intersect can quite small, case can increase number variable features rerunning FindVariableFeatures increase number nfeatures argument. singlecell_assay Assay single cell data object use deconvolution spatial_assay Assay Visium data object use deconvolution slot Name slot singlecell_assay spatial_assay use deconvolution assay_name Sets name returned Assay object. active return..dimred = FALSE. dimred_name Sets name  returned DimReduc object. active return..dimred = TRUE. return_as_dimred default, results returned Assay named \"celltypeprops\", feature named cell type IDs. Alternatively, can return results DimReduc object. also provide cell gene loadings cell type. However, proportions instead named \"factor_1\", \"factor_2\", ...","code":""},{"path":"https://ludvigla.github.io/semla/reference/celltype-prediction-mixed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mixed cell type prediction with NNLS (experimental) — RunMixedNNLS","text":"object mixed cell type factor proportion estimates object cell type proportion estimates","code":""},{"path":"https://ludvigla.github.io/semla/reference/celltype-prediction-mixed.html","id":"default-method","dir":"Reference","previous_headings":"","what":"default method","title":"Mixed cell type prediction with NNLS (experimental) — RunMixedNNLS","text":"Input `object` matrix-like object 10x Visium data. function returns matrix estimated proportions dimensions (nCellTypes + k) x nSpots, nCellTypes number cell types, k number factors nSpots number spots. `return_expression_profiles=TRUE`, returned object list estimated proportions `prop` cell type/factor expression profile matrix `W`.","code":""},{"path":"https://ludvigla.github.io/semla/reference/celltype-prediction-mixed.html","id":"seurat-method","dir":"Reference","previous_headings":"","what":"Seurat method","title":"Mixed cell type prediction with NNLS (experimental) — RunMixedNNLS","text":"Input object Seurat object 10x Visium data. function returns Seurat object either new Assay DimReduc object containing estimated proportions cell types additional factors.","code":""},{"path":"https://ludvigla.github.io/semla/reference/celltype-prediction.html","id":null,"dir":"Reference","previous_headings":"","what":"Cell type prediction with NNLS — RunNNLS","title":"Cell type prediction with NNLS — RunNNLS","text":"function can used project cell type expression profiles onto 10x Visium gene expression matrix obtain cell type proportion estimates.","code":""},{"path":"https://ludvigla.github.io/semla/reference/celltype-prediction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cell type prediction with NNLS — RunNNLS","text":"","code":"RunNNLS(object, ...)  # S3 method for default RunNNLS(   object,   singlecell_matrix,   groups,   nCells_per_group = 50L,   minCells_per_celltype = 10L,   min_prop = 0.01,   L1 = 0.01,   seed = 1337L,   return_expression_profiles = FALSE,   verbose = TRUE,   ... )  # S3 method for Seurat RunNNLS(   object,   singlecell_object,   groups = NULL,   features = NULL,   singlecell_assay = \"RNA\",   spatial_assay = \"Spatial\",   slot = \"data\",   min_prop = 0.01,   nCells_per_group = 50L,   minCells_per_celltype = 10L,   assay_name = \"celltypeprops\",   dimred_name = \"nnls\",   return_as_dimred = FALSE,   L1 = 0.01,   seed = 1337L,   verbose = TRUE,   ... )"},{"path":"https://ludvigla.github.io/semla/reference/celltype-prediction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cell type prediction with NNLS — RunNNLS","text":"object matrix-like object 10x Visium data ... Arguments passed methods singlecell_matrix matrix-like object scRNA-seq data groups character vector length ncol(singlecell_matrix) cell type labels. Seurat objects, one can omit groups case current identity used instead. Alternatively, string can provided specifying column use singlecell_object meta.data slot. nCells_per_group cell type sampled number computing cell type expression profiles. mainly used speed computation. Note cell type fewer nCells_per_group cells, cells sampled replacement obtain nCells_per_group cells. minCells_per_celltype Minimum number cells allowed per cell type min_prop Minimum proportion allowed. proportion values lower threshold removed remaining proportions rescaled. L1 lasso penalty seed integer set seed reproducibility return_expression_profiles Logical specifying expression profile matrix also returned verbose Print messages singlecell_object Seurat object single-cell gene expression data features Features use computation. features provided, intersection variable features sc_object st_object used. Note intersect can quite small, case can increase number variable features rerunning FindVariableFeatures increase number nfeatures argument. singlecell_assay Assay single cell data object use deconvolution spatial_assay Assay Visium data object use deconvolution slot Name slot singlecell_assay spatial_assay use deconvolution assay_name Sets name returned Assay object. active return..dimred = FALSE. dimred_name Sets name  returned DimReduc object. active return..dimred = TRUE. return_as_dimred default, results returned Assay named \"celltypeprops\", feature named cell type IDs. Alternatively, can return results DimReduc object. also provide cell gene loadings cell type. However, proportions instead named \"factor_1\", \"factor_2\", ...","code":""},{"path":"https://ludvigla.github.io/semla/reference/celltype-prediction.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cell type prediction with NNLS — RunNNLS","text":"object cell type proportion estimates","code":""},{"path":"https://ludvigla.github.io/semla/reference/celltype-prediction.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cell type prediction with NNLS — RunNNLS","text":"method suitable paired 10x Visium scRNA-seq data. words, scRNA-seq data represent cell types present 10x Visium spatial transcriptomics data. Redundant cell types (.e. cells present scRNA-seq data data 10x Visium) missing cell types (.e. cells present 10x Visium data data scRNA-seq data) might affect results. Preferably, scRNA-seq data composed cell types tissue section(s) processed 10x Visium collected tissue specimen. method intended used fast cell type mapping useful data driven exploration. encourage users explore alternative methods stereoscope, cell2location RCTD. method uses NNLS implementation RcppML R package developed Zachary DeBruine.","code":""},{"path":"https://ludvigla.github.io/semla/reference/celltype-prediction.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cell type prediction with NNLS — RunNNLS","text":"tutorial can found package website. Got tutorials -> Cell type mapping","code":""},{"path":"https://ludvigla.github.io/semla/reference/celltype-prediction.html","id":"default-method","dir":"Reference","previous_headings":"","what":"default method","title":"Cell type prediction with NNLS — RunNNLS","text":"Input object matrix-like object 10x Visium data. function returns matrix estimated cell type proportions dimensions nCellTypes x nSpots, nCellTypes number cell types nSpots number spots. return_expression_profiles=TRUE, returned object list estimated proportions prop cell type expression profile matrix W.","code":""},{"path":"https://ludvigla.github.io/semla/reference/celltype-prediction.html","id":"seurat-method","dir":"Reference","previous_headings":"","what":"Seurat method","title":"Cell type prediction with NNLS — RunNNLS","text":"Input object Seurat object 10x Visium data. function returns Seurat object either new Assay DimReduc object containing estimated cell type proportions.","code":""},{"path":"https://ludvigla.github.io/semla/reference/celltype-prediction.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cell type prediction with NNLS — RunNNLS","text":"RcppML RcppML GitHub page","code":""},{"path":"https://ludvigla.github.io/semla/reference/celltype-prediction.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Cell type prediction with NNLS — RunNNLS","text":"Ludvig Larsson","code":""},{"path":"https://ludvigla.github.io/semla/reference/centroid_angles_plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw a centroid angle plot — centroid_angles_plot","title":"Draw a centroid angle plot — centroid_angles_plot","text":"Draw centroid angle plot","code":""},{"path":"https://ludvigla.github.io/semla/reference/centroid_angles_plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw a centroid angle plot — centroid_angles_plot","text":"","code":"centroid_angles_plot(nbreaks = 9, centroid_size = 8)"},{"path":"https://ludvigla.github.io/semla/reference/centroid_angles_plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw a centroid angle plot — centroid_angles_plot","text":"nbreaks Number intervals cut angles centroid_size Size centroid spot","code":""},{"path":"https://ludvigla.github.io/semla/reference/centroid_angles_plot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draw a centroid angle plot — centroid_angles_plot","text":"ggplot object","code":""},{"path":"https://ludvigla.github.io/semla/reference/centroid_angles_plot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Draw a centroid angle plot — centroid_angles_plot","text":"","code":"# Draw a plot centroid_angles_plot(9)"},{"path":"https://ludvigla.github.io/semla/reference/cor-features.html","id":null,"dir":"Reference","previous_headings":"","what":"Find features with high spatial autocorrelation — CorSpatialFeatures","title":"Find features with high spatial autocorrelation — CorSpatialFeatures","text":"function can used find genes high spatial autocorrelation SRT data. detailed description algorithm outlined .","code":""},{"path":"https://ludvigla.github.io/semla/reference/cor-features.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find features with high spatial autocorrelation — CorSpatialFeatures","text":"","code":"CorSpatialFeatures(object, ...)  # S3 method for default CorSpatialFeatures(   object,   spatnet,   across_all = FALSE,   nCores = NULL,   verbose = TRUE,   ... )  # S3 method for Seurat CorSpatialFeatures(   object,   features = NULL,   assay_use = NULL,   slot_use = \"data\",   across_all = FALSE,   nCores = NULL,   verbose = TRUE,   ... )"},{"path":"https://ludvigla.github.io/semla/reference/cor-features.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find features with high spatial autocorrelation — CorSpatialFeatures","text":"object object (see details) ... Arguments passed methods spatnet list spatial networks created GetSpatialNetwork. spots networks match spots feature matrix. across_all autocorrelation scores calculated across samples? nCores Number cores use spatial autocorrelation calculation verbose Print messages features character vector features present Seurat object. features need accessible FetchData assay_use Select assay use computation. specified, default assay used. slot_use Select slot use assay object.","code":""},{"path":"https://ludvigla.github.io/semla/reference/cor-features.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find features with high spatial autocorrelation — CorSpatialFeatures","text":"Either list tibbles tibble feature names correlation scores","code":""},{"path":"https://ludvigla.github.io/semla/reference/cor-features.html","id":"spatial-autocorrelation","dir":"Reference","previous_headings":"","what":"Spatial autocorrelation","title":"Find features with high spatial autocorrelation — CorSpatialFeatures","text":"Spatial autocorrelation term used describe presence systematic spatial variation. Positive spatial autocorrelation feature tendency regions close together space similar values feature. simple example anatomical structure tissue type spans across multiple neighboring spots SRT experiment, example gland, immune infiltrate region brain. Inside structures, might find expression levels certain genes (features) highly similar hence genes positive spatial autocorrelation. method provided semla works follows. feature spot, expression averaged across neighboring spots (typically 6 closest neighbors) produce lag expression vector. Since vector represents average surrounding spots, can use test expression spots similar center spot. One simple strategy calculate pearson correlation genes' lag vector original expression vector typically captures spatial autocorrelation well.","code":""},{"path":"https://ludvigla.github.io/semla/reference/cor-features.html","id":"method-steps","dir":"Reference","previous_headings":"","what":"Method steps","title":"Find features with high spatial autocorrelation — CorSpatialFeatures","text":"Load matrix features rows spots columns: \\(X_{expr}\\) Convert corresponding spatial network wide format construct nearest neighbor matrix \\(N_{neighbors}\\) neighboring spots value 1 remaining spots value 0 \\(N_{neighbors}\\) multiplied \\(X_{expr}\\) calculate lag vector feature:  \\(X_{lagexpr} = (N_{neighbors}*X_{expr})/n_{neighbors}\\)  \\(n_{neighbors}\\) number neighbors spot. spatial autocorrelation score feature 'pearson' correlation lag vector initial expression vector:  \\(spatcor_{feature} = cor(X_{lagexpr}[feature, ], X_{expr}[feature, ])\\)","code":""},{"path":"https://ludvigla.github.io/semla/reference/cor-features.html","id":"default-method","dir":"Reference","previous_headings":"","what":"Default method","title":"Find features with high spatial autocorrelation — CorSpatialFeatures","text":"default method expects matrix-like object features columns spots rows list spatial networks generated GetSpatialNetwork.","code":""},{"path":"https://ludvigla.github.io/semla/reference/cor-features.html","id":"mode","dir":"Reference","previous_headings":"","what":"Mode","title":"Find features with high spatial autocorrelation — CorSpatialFeatures","text":"across_all set TRUE, spatial autocorrelation scores computed across samples. Otherwise, scores calculated sample separately, returns list one tibble per sample.","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/reference/cor-features.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Find features with high spatial autocorrelation — CorSpatialFeatures","text":"Ludvig Larsson","code":""},{"path":"https://ludvigla.github.io/semla/reference/cor-features.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find features with high spatial autocorrelation — CorSpatialFeatures","text":"","code":"if (FALSE) { se_mbrain <- readRDS(system.file(\"extdata/mousebrain\",                                  \"se_mbrain\",                                  package = \"semla\")) featureMat <- FetchData(se_mbrain, vars = VariableFeatures(se_mbrain)[1:100])  coordfile <-   system.file(\"extdata/mousebrain/spatial\",               \"tissue_positions_list.csv\",               package = \"semla\")  # Load coordinate data into a tibble xys <- setNames(read.csv(coordfile, header = FALSE),                 nm = c(\"barcode\", \"selection\", \"grid_y\", \"grid_x\", \"y\", \"x\")) xys$sample <- paste0(1) xys <- xys |>   dplyr::mutate(barcode = paste0(barcode, \"_\", 1)) |>   dplyr::filter(selection == 1) |>   dplyr::select(barcode, x, y, sample) |>   tibble::as_tibble()  # Create spatial networks spatnet <- GetSpatialNetwork(xys) spatgenes <- CorSpatialFeatures(featureMat, spatnet, nCores = 1)  # Check genes with highest spatial autocorrelation head(spatgenes[[1]]) }   se_mbrain <- readRDS(system.file(\"extdata/mousebrain\",                                  \"se_mbrain\",                                  package = \"semla\")) se_mbrain <- se_mbrain |>   ScaleData() |>   RunPCA() #> Centering and scaling data matrix #> PC_ 1  #> Positive:  Nrgn, Olfm1, Cck, Nptxr, Rtn1, Snca, Nov, Tmsb4x, Lamp5, Egr1  #> \t   Crym, Cpne6, Coro1a, Arc, Hpca, Sst, Nr4a1, Npy, Chgb, Neurod6  #> \t   Snap25, Myh7, Uchl1, Eef1a2, Cort, Grp, Stmn2, Rprm, Spink8, Mfge8  #> Negative:  Mbp, Plp1, Apod, Mobp, Ptgds, Mog, Mal, Mag, Cnp, Aldh1a1  #> \t   Opalin, Tcf7l2, Ddc, Lhx1os, Slc6a3, Ret, Th, Slc18a2, Sncg, Drd2  #> \t   Chrna6, Slc10a4, Spp1, En1, Dlk1, Calb2, Hbb-bs, Pvalb, Col1a2, Tnnt1  #> PC_ 2  #> Positive:  Myoc, Gfap, Col1a2, Fmod, Slc13a4, Hba-a1, Hbb-bt, Slc6a20a, Hba-a2, Hbb-bs  #> \t   Acta2, Tagln, Mgp, Ogn, Vtn, H2-Aa, Lyz2, Cd74, Myl9, Dcn  #> \t   Myh11, Ptgds, Cytl1, H2-Eb1, Hmgcs2, Clu, Mfge8, Emp1, Npy, Cnn1  #> Negative:  Th, Uchl1, Slc18a2, En1, Slc10a4, Slc6a3, Chrna6, Stmn2, Ret, Snap25  #> \t   Drd2, Dlk1, Ddc, Scg2, Sncg, Eef1a2, Rtn1, Chga, Pcp4, Calb2  #> \t   Mobp, Mbp, Chgb, Fabp5, Plp1, Pvalb, Mog, Mal, Mag, Snca  #> PC_ 3  #> Positive:  Trbc2, Arc, Egr1, Myl4, Nr4a1, Mbp, Mobp, Pvalb, Plp1, Opalin  #> \t   Mog, Mal, Cnp, Mag, Snap25, Lamp5, Ighm, Tcf7l2, Cplx3, Tgm3  #> \t   Ighg2c, Pcp4, Hpca, Ly6d, Eef1a2, Tnnt1, Chga, Neurod6, Prph, Ctgf  #> Negative:  Nnat, Slc18a2, Dlk1, Slc6a3, Slc10a4, En1, Th, Chrna6, Dcn, Sncg  #> \t   Cpne7, Drd2, Ddc, Ret, Hpcal1, Ecel1, Cpne6, Col1a2, Trh, Calb2  #> \t   Cd24a, Fmod, Mgp, Snca, Lypd1, Slc13a4, Fibcd1, Crym, Spink8, Slc6a20a  #> PC_ 4  #> Positive:  Nr4a1, Arc, Lamp5, Egr1, Myl4, Trbc2, Chrna6, Tagln, En1, Snap25  #> \t   Th, Slc18a2, Acta2, Col1a2, Myh11, Fmod, Hba-a2, Slc10a4, Slc6a3, Slc13a4  #> \t   Ret, Tgm3, Hbb-bt, Slc6a20a, Ighm, Hbb-bs, Hba-a1, Vtn, Mgp, Drd2  #> Negative:  Spink8, Fibcd1, Tmsb4x, Nnat, Lefty1, Crym, Cpne7, Nos1, Dcn, Cpne6  #> \t   Grp, Homer3, Htr3a, Tac1, Fabp5, C1ql2, Trh, Opalin, Mog, Plp1  #> \t   Mag, Calb2, Ecel1, Gfap, Cnp, Tcf7l2, Lypd1, Vgll3, Hpcal1, Mal  #> PC_ 5  #> Positive:  En1, Chrna6, Th, Slc18a2, Slc10a4, Ddc, Lefty1, Arc, Slc6a3, Neurod6  #> \t   Grp, Nov, Lamp5, Fibcd1, Nr4a1, Drd2, Spink8, Vip, Myl4, Ret  #> \t   Egr1, Dlk1, Nrgn, Gfap, Trbc2, Tgm3, Myh7, Tac2, Sncg, Npy  #> Negative:  Pcp4, Tcf7l2, Snap25, Uchl1, Eef1a2, Chga, Stmn2, Lhx1os, Calb2, Scg2  #> \t   Fabp5, Bok, Prkcd, Pvalb, Cartpt, Chgb, Tnnt1, Gpx3, Slc20a1, Rtn1  #> \t   C1ql2, Spp1, Hpcal1, Ptgds, Pitx2, Lypd1, Aldh1a1, Ecel1, Vtn, Nme7   # Compute spatial autocorrelation for variable features spatgenes <- CorSpatialFeatures(se_mbrain,                                 features = VariableFeatures(se_mbrain),                                 nCores = 1) #>  #> ── Computing spatial autocorrelation ── #>  #> ℹ Sample 1: #> →   Cleaned out spots with 0 adjacent neighbors #> →   Computed feature lag expression #> →   Computed feature spatial autocorrelation scores #> ✔   Returning results  # Check genes with highest spatial autocorrelation head(spatgenes[[1]]) #> # A tibble: 6 × 2 #>   gene     cor #>   <chr>  <dbl> #> 1 Mbp    0.870 #> 2 Nrgn   0.857 #> 3 Cck    0.813 #> 4 Olfm1  0.798 #> 5 Slc6a3 0.798 #> 6 Trh    0.770  # Note that the top variable genes are blood related (hemoglobin genes) # These genes have lower spatial autocorrelation since blood vessels # typically only cover a few spots and more randomly dispersed throughput the tissue head(VariableFeatures(se_mbrain)) #> [1] \"Hbb-bs\" \"Hba-a1\" \"Hba-a2\" \"Hbb-bt\" \"Slc6a3\" \"Th\"      # The same principle can be used to estimate spatial autocorrelation for other features, # for example dimensionality reduction vectors spatpcs <- CorSpatialFeatures(se_mbrain,                              features = paste0(\"PC_\", 1:10),                              nCores = 1) #>  #> ── Computing spatial autocorrelation ── #>  #> ℹ Sample 1: #> →   Cleaned out spots with 0 adjacent neighbors #> →   Computed feature lag expression #> →   Computed feature spatial autocorrelation scores #> ✔   Returning results  # Calculate spatial autocorrelation scores for principal components head(spatpcs[[1]]) #> # A tibble: 6 × 2 #>   gene    cor #>   <chr> <dbl> #> 1 PC_1  0.934 #> 2 PC_3  0.890 #> 3 PC_4  0.843 #> 4 PC_2  0.822 #> 5 PC_7  0.768 #> 6 PC_5  0.739  # Compute spatial autocorrelation scores for multiple datasets se_mcolon <- readRDS(system.file(\"extdata/mousecolon\",                                  \"se_mcolon\",                                  package = \"semla\")) se_merged <- MergeSTData(se_mbrain, se_mcolon) |>   FindVariableFeatures()  spatgenes <- CorSpatialFeatures(se_merged,                                 features = VariableFeatures(se_merged),                                 nCores = 1) #>  #> ── Computing spatial autocorrelation ── #>  #> ℹ Sample 1: #> →   Cleaned out spots with 0 adjacent neighbors #> →   Computed feature lag expression #> →   Computed feature spatial autocorrelation scores #> ℹ Sample 2: #> →   Cleaned out spots with 0 adjacent neighbors #> →   Computed feature lag expression #> →   Computed feature spatial autocorrelation scores #> ✔   Returning results  # Check spatial autocorrelation scores mouse brain data head(spatgenes[[1]]) #> # A tibble: 6 × 2 #>   gene     cor #>   <chr>  <dbl> #> 1 Mbp    0.870 #> 2 Nrgn   0.857 #> 3 Cck    0.813 #> 4 Olfm1  0.798 #> 5 Slc6a3 0.798 #> 6 Trh    0.770 # Check spatial autocorrelation scores mouse colon data head(spatgenes[[2]]) #> # A tibble: 6 × 2 #>   gene    cor #>   <chr> <dbl> #> 1 Prdx6 0.701 #> 2 Car1  0.616 #> 3 Cnn1  0.562 #> 4 Tgm3  0.556 #> 5 Acta2 0.536 #> 6 Tagln 0.530"},{"path":"https://ludvigla.github.io/semla/reference/disconnect-regions.html","id":null,"dir":"Reference","previous_headings":"","what":"Disconnect regions — DisconnectRegions","title":"Disconnect regions — DisconnectRegions","text":"function allows split spatially disconnected regions belonging category. cases certain tissue type create isolated \"islands\" tissue section, islands can separated. common example tertiary lymphoid structures (TLS) typically dispersed across tissue section.","code":""},{"path":"https://ludvigla.github.io/semla/reference/disconnect-regions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Disconnect regions — DisconnectRegions","text":"","code":"DisconnectRegions(object, ...)  # S3 method for default DisconnectRegions(object, spots, verbose = TRUE, ...)  # S3 method for Seurat DisconnectRegions(   object,   column_name,   selected_groups = NULL,   verbose = TRUE,   ... )"},{"path":"https://ludvigla.github.io/semla/reference/disconnect-regions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Disconnect regions — DisconnectRegions","text":"object object ... Arguments passed methods spots character vector spot IDs present object verbose Print messages column_name character specifying name column meta data slot `Seurat`  object contains categorical data, e.g. clusters manual selections selected_groups character vector select specific groups column_name . groups selected default, common use case select region interest.","code":""},{"path":"https://ludvigla.github.io/semla/reference/disconnect-regions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Disconnect regions — DisconnectRegions","text":"object disconnected regions","code":""},{"path":"https://ludvigla.github.io/semla/reference/disconnect-regions.html","id":"default-method","dir":"Reference","previous_headings":"","what":"default method","title":"Disconnect regions — DisconnectRegions","text":"Takes tibble set spot IDs returns named character vector new labels. names vector corresponds input spot IDs.","code":""},{"path":"https://ludvigla.github.io/semla/reference/disconnect-regions.html","id":"seurat","dir":"Reference","previous_headings":"","what":"Seurat","title":"Disconnect regions — DisconnectRegions","text":"categorical variable selected Seurat object meta data slot using column_name. column, one can specify groups disconnect selected_groups. selected_groups specified, groups selected_groups disconnected separately. function returns Seurat object additional columns meta data slot, one group selected_groups. suffix columns \"_split\", group selected_groups called \"tissue\" get column called \"tissue_split\" new labels spatially disconnected region.","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/reference/disconnect-regions.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Disconnect regions — DisconnectRegions","text":"Ludvig Larsson","code":""},{"path":"https://ludvigla.github.io/semla/reference/disconnect-regions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Disconnect regions — DisconnectRegions","text":"","code":"library(semla) library(dplyr) library(ggplot2) library(patchwork)  galt_spots_file <- system.file(\"extdata/mousecolon\",                                \"galt_spots.csv\",                                 package = \"semla\") galt_spots <- read.csv(galt_spots_file) |>   as_tibble()  # read coordinates coordfile <- system.file(\"extdata/mousecolon/spatial\",                          \"tissue_positions_list.csv\",                          package = \"semla\") coords <- read.csv(coordfile, header = FALSE) |>   filter(V2 == 1) |>   select(V1, V6, V5) |>   setNames(nm = c(\"barcode\", \"x\", \"y\")) |>   bind_cols(sampleID = 1) |>   as_tibble()  # Select spots spots <- galt_spots$barcode[galt_spots$selection == \"GALT\"] head(spots) #> [1] \"AAACTGCTGGCTCCAA-1\" \"AACCTTTAAATACGGT-1\" \"AACGATAATGCCGTAG-1\" #> [4] \"AACGTCAGACTAGTGG-1\" \"AACTAGGCTTGGGTGT-1\" \"AAGCATACTCTCCTGA-1\"  # Find disconnected regions in GALT spots disconnected_spot_labels <- DisconnectRegions(coords, spots) #> ℹ Detecting disconnected regions for 106 spots #> ℹ Found 8 disconnected graph(s) in data #> ℹ Sorting disconnected regions by decreasing size #> ℹ Found 12 singletons in data #> →   These will be labeled as 'singletons'  # Add information to coords and plot gg <- coords |>   mutate(galt = NA, galt_disconnected = NA) gg$galt[match(spots, gg$barcode)] <- \"galt\" gg$galt_disconnected[match(names(disconnected_spot_labels), gg$barcode)] <- disconnected_spot_labels  p1 <- ggplot(gg, aes(x, y, color = galt)) p2 <- ggplot(gg, aes(x, y, color = galt_disconnected)) p <- p1 + p2 &   geom_point() &   theme_void() &   coord_fixed() p    library(semla) library(ggplot2) library(patchwork)  se_mcolon <- readRDS(system.file(\"extdata/mousecolon\", \"se_mcolon\", package = \"semla\"))  # Plot selected variable MapLabels(se_mcolon, column_name = \"selection\",           pt_size = 3, override_plot_dims = TRUE)   # Disconnect regions se_mcolon <- DisconnectRegions(se_mcolon, column_name = \"selection\", selected_groups = \"GALT\") #> ℹ Extracting disconnected components for group 'GALT' #> ℹ Detecting disconnected regions for 106 spots #> ℹ Found 8 disconnected graph(s) in data #> ℹ Sorting disconnected regions by decreasing size #> ℹ Found 12 singletons in data #> →   These will be labeled as 'singletons'  # Plot split regions MapLabels(se_mcolon, column_name = \"GALT_split\",           pt_size = 3, override_plot_dims = TRUE)   # Note that if multiple sections are present, each section will be given # it's own prefix in the disconnected groups. se_merged <- MergeSTData(se_mcolon, se_mcolon)  # Plot selected variable MapLabels(se_merged, column_name = \"selection\",           pt_size = 3, override_plot_dims = TRUE) +   plot_layout(guides = \"collect\") &   theme(legend.position = \"top\")   # Disconnect regions se_merged <- DisconnectRegions(se_merged, column_name = \"selection\", selected_groups = \"GALT\") #> ℹ Extracting disconnected components for group 'GALT' #> ℹ Detecting disconnected regions for 212 spots #> ℹ Found 16 disconnected graph(s) in data #> ℹ Sorting disconnected regions by decreasing size #> ℹ Found 24 singletons in data #> →   These will be labeled as 'singletons'  # Plot split regions MapLabels(se_merged, column_name = \"GALT_split\",           pt_size = 3, override_plot_dims = TRUE) +   plot_layout(guides = \"collect\") &   theme(legend.position = \"top\")"},{"path":"https://ludvigla.github.io/semla/reference/export_coordinates.html","id":null,"dir":"Reference","previous_headings":"","what":"Export spatial coordinates to a JSON file — export_coordinates","title":"Export spatial coordinates to a JSON file — export_coordinates","text":"Utility function prepare data FeatureViewer. exported JSON file exported directory H&E image tiles generated TileImage","code":""},{"path":"https://ludvigla.github.io/semla/reference/export_coordinates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Export spatial coordinates to a JSON file — export_coordinates","text":"","code":"export_coordinates(   object,   sampleNumber = 1L,   outdir,   overwrite = FALSE,   verbose = TRUE )"},{"path":"https://ludvigla.github.io/semla/reference/export_coordinates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Export spatial coordinates to a JSON file — export_coordinates","text":"object Seurat object created semla sampleNumber integer specifying sample ID export spatial network outdir Name directory export JSON file overwrite existing coordinate file overwritten? verbose Print messages","code":""},{"path":"https://ludvigla.github.io/semla/reference/export_coordinates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Export spatial coordinates to a JSON file — export_coordinates","text":"Writes coordinates file","code":""},{"path":"https://ludvigla.github.io/semla/reference/export_coordinates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Export spatial coordinates to a JSON file — export_coordinates","text":"Coordinates located outside H&E images shown viewer.","code":""},{"path":"https://ludvigla.github.io/semla/reference/export_coordinates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Export spatial coordinates to a JSON file — export_coordinates","text":"","code":"if (FALSE) { libary(semla)  se_mbrain <- readRDS(system.file(\"extdata/mousebrain\",                                  \"se_mbrain\",                                  package = \"semla\"))  export_coordinates(se_mbrain, outdir = \"./\") }"},{"path":"https://ludvigla.github.io/semla/reference/export_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Export a spatial graph to a JSON file — export_graph","title":"Export a spatial graph to a JSON file — export_graph","text":"Utility function prepare data CutSpatialNetwork. exported JSON file exported directory H&E image tiles generated TileImage","code":""},{"path":"https://ludvigla.github.io/semla/reference/export_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Export a spatial graph to a JSON file — export_graph","text":"","code":"export_graph(object, sampleID = 1L, outdir, verbose = TRUE)"},{"path":"https://ludvigla.github.io/semla/reference/export_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Export a spatial graph to a JSON file — export_graph","text":"object `Seurat` object created `semla` sampleID integer specifying sample ID export spatial network outdir Name directory export JSON file verbose Print messages","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/reference/export_graph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Export a spatial graph to a JSON file — export_graph","text":"","code":"if (FALSE) { library(semla) library(magick)  se_mbrain <- readRDS(system.file(\"extdata/mousebrain\", \"se_mbrain\", package = \"semla\"))  # Fetch a spatial network spatnet <- GetSpatialNetwork(se_mcolon)[[1]]  # Export graph as a JSON file to the current working directory export_graph(se_mbrain, sampleID = 1, outdir = \".\") }"},{"path":"https://ludvigla.github.io/semla/reference/file_server.html","id":null,"dir":"Reference","previous_headings":"","what":"Host a file server — file_server","title":"Host a file server — file_server","text":"Hosts file server specified directory. See [beakr](https://github.com/MazamaScience/beakr) information.","code":""},{"path":"https://ludvigla.github.io/semla/reference/file_server.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Host a file server — file_server","text":"","code":"file_server(hostDir, host = \"127.0.0.1\", port = 8080)"},{"path":"https://ludvigla.github.io/semla/reference/file_server.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Host a file server — file_server","text":"hostDir directory host files host string valid IPv4 IPv6 address listen , Defaults localhost \"127.0.0.1\" port integer indicates port listen .","code":""},{"path":"https://ludvigla.github.io/semla/reference/file_server.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Host a file server — file_server","text":"beakr server active instance","code":""},{"path":"https://ludvigla.github.io/semla/reference/file_server.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Host a file server — file_server","text":"","code":"# \\donttest{  # Host files in current directory fs <- file_server(hostDir = \"./\") #> Loading required namespace: beakr  # Stop server beakr::stopServer(fs)  # Or stop all servers beakr::stopAllServers() # }"},{"path":"https://ludvigla.github.io/semla/reference/ftrviewer-shiny.html","id":null,"dir":"Reference","previous_headings":"","what":"Shiny bindings for ftrviewer — ftrviewer-shiny","title":"Shiny bindings for ftrviewer — ftrviewer-shiny","text":"Output render functions using ftrviewer within Shiny applications interactive Rmd documents.","code":""},{"path":"https://ludvigla.github.io/semla/reference/ftrviewer-shiny.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shiny bindings for ftrviewer — ftrviewer-shiny","text":"","code":"ftrviewerOutput(outputId, width = \"100%\", height = \"400px\")  renderFtrviewer(expr, env = parent.frame(), quoted = FALSE)"},{"path":"https://ludvigla.github.io/semla/reference/ftrviewer-shiny.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shiny bindings for ftrviewer — ftrviewer-shiny","text":"outputId output variable read width, height Must valid CSS unit (like '100%', '400px', 'auto') number, coerced string 'px' appended. expr expression generates ftrviewer env environment evaluate expr. quoted expr quoted expression (quote())? useful want save expression variable.","code":""},{"path":"https://ludvigla.github.io/semla/reference/ftrviewer.html","id":null,"dir":"Reference","previous_headings":"","what":"Open a feature viewer react application — ftrviewer","title":"Open a feature viewer react application — ftrviewer","text":"function open react application listens can used interactively visualize categorical numeric features spatial maps. application run properly, relevant data needs available via file server. function intended used within shiny app","code":""},{"path":"https://ludvigla.github.io/semla/reference/ftrviewer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Open a feature viewer react application — ftrviewer","text":"","code":"ftrviewer(   host = \"127.0.0.1\",   port = \"8080\",   sampleID = 1,   values,   opacities,   opacity = 1,   range,   scaleByOpacity = FALSE,   isNumeric = TRUE,   useLasso = FALSE,   levels = character(),   categories = character(),   colors = rev(RColorBrewer::brewer.pal(n = 9, name = \"Spectral\")),   container_width = 800,   container_height = 800,   elementId = NULL )"},{"path":"https://ludvigla.github.io/semla/reference/ftrviewer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Open a feature viewer react application — ftrviewer","text":"host host address. Defaults localhost \"127.0.0.1\" port number valid port sampleID section number values vector numeric categorical values opacities numeric vector opacity values opacity integer length 1 specifying fixed opacity value range numeric vector length 2 specifying range values (color domain) scaleByOpacity logical specifying opacity set opacities opacity isNumeric logical specifying input numeric useLasso logical specifying lasso selection tool activated levels Category levels coloring values categories character vector categories available colors character vector colors container_width, container_height Container width/height pixels elementId id viewer element","code":""},{"path":"https://ludvigla.github.io/semla/reference/ftrviewer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Open a feature viewer react application — ftrviewer","text":"","code":"if (FALSE) {  library(semla) se_mbrain <- readRDS(system.file(\"extdata/mousebrain\", \"se_mbrain\", package = \"semla\")) se_mbrain <- LoadImages(se_mbrain)  datapath <- ExportDataForViewer(se_mbrain, outdir = \".\")  # Start file server file_server(datapath)  # Run feature viewer widget ftrviewer(values = as.numeric(se_mbrain$nFeature_Spatial),           opacities = rep(1, ncol(se_mbrain)), isNumeric = TRUE,           range = range(se_mbrain$nFeature_Spatial))  # Stop file server beakr::stopAllServers()  }"},{"path":"https://ludvigla.github.io/semla/reference/generate_rigid_transform.html","id":null,"dir":"Reference","previous_headings":"","what":"Utility function to generate a tibble with image transformations — generate_rigid_transform","title":"Utility function to generate a tibble with image transformations — generate_rigid_transform","text":"Utility function generate tibble image transformations","code":""},{"path":"https://ludvigla.github.io/semla/reference/generate_rigid_transform.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Utility function to generate a tibble with image transformations — generate_rigid_transform","text":"","code":"generate_rigid_transform(   sampleID = 1,   mirror_x = FALSE,   mirror_y = FALSE,   angle = 0,   tr_x = 0,   tr_y = 0,   scalefactor = 1 )"},{"path":"https://ludvigla.github.io/semla/reference/generate_rigid_transform.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Utility function to generate a tibble with image transformations — generate_rigid_transform","text":"sampleID integer specifying sample ID mirror_x, mirror_y Logical specifying image spots mirrored along x- /y-axis angle Numeric value specifying degree rotation. Use negative angles counter-clockwise rotation. value needs range (-360, 360) tr_x, tr_y Integer values translations along x- y-axis scalefactor numeric value specifying scaling factor (0, 3)","code":""},{"path":"https://ludvigla.github.io/semla/reference/generate_rigid_transform.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Utility function to generate a tibble with image transformations — generate_rigid_transform","text":"tibble image transformations","code":""},{"path":"https://ludvigla.github.io/semla/reference/generate_rigid_transform.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Utility function to generate a tibble with image transformations — generate_rigid_transform","text":"","code":"# Flip along x axis and rotate 45 degrees generate_rigid_transform(sampleID = 1, mirror_x = TRUE, angle = 45) #> # A tibble: 1 × 7 #>   sampleID mirror_x mirror_y angle  tr_x  tr_y scalefactor #>      <dbl> <lgl>    <lgl>    <dbl> <dbl> <dbl>       <dbl> #> 1        1 TRUE     FALSE       45     0     0           1  # Move image 100 pixels along x and y axes generate_rigid_transform(sampleID = 1, tr_x = 100, tr_y = 100) #> # A tibble: 1 × 7 #>   sampleID mirror_x mirror_y angle  tr_x  tr_y scalefactor #>      <dbl> <lgl>    <lgl>    <dbl> <dbl> <dbl>       <dbl> #> 1        1 FALSE    FALSE        0   100   100           1"},{"path":"https://ludvigla.github.io/semla/reference/get-network.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Spatial Networks — GetSpatialNetwork","title":"Create Spatial Networks — GetSpatialNetwork","text":"Create spatial networks spatial coordinates. spatial networks provided long format holds information spot neighbors, center--center distances positions.","code":""},{"path":"https://ludvigla.github.io/semla/reference/get-network.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Spatial Networks — GetSpatialNetwork","text":"","code":"GetSpatialNetwork(object, ...)  # S3 method for default GetSpatialNetwork(object, nNeighbors = 6, maxDist = NULL, minK = 0, ...)  # S3 method for Seurat GetSpatialNetwork(object, nNeighbors = 6, maxDist = NULL, minK = 0, ...)"},{"path":"https://ludvigla.github.io/semla/reference/get-network.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Spatial Networks — GetSpatialNetwork","text":"object object ... Arguments passed methods nNeighbors Number nearest neighbors calculate spot. default number neighbors 6 given hexagonal pattern 10x Visium arrays. maxDist Distance cut-nearest neighbors consider. set NULL (default), maxDist estimated data taking minimum neighbor distance multiplied factor 1.2. minK Minimum nearest neighbors [default: 0]. Spots fewer neighbors discarded. Useful want remove spots neighbors.","code":""},{"path":"https://ludvigla.github.io/semla/reference/get-network.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Spatial Networks — GetSpatialNetwork","text":"list tibbles, containing information nearest neighbors spot. one spot column \"\", nearest neighboring spots provided \"\" column. Distances correspond distances \"\" \"\", usually correspond H&E image pixels. nNeighbors defines number nearest neighbors \"\" spots selected GetSpatialNetwork. \"x_start\", \"y_start\" spatial coordinates \"\" spots \"x_end\", \"y_end\" spatial coordinates neighboring \"\" spots.","code":""},{"path":"https://ludvigla.github.io/semla/reference/get-network.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create Spatial Networks — GetSpatialNetwork","text":"default method expects object class tbl data.frame four columns \"barcode\", \"x\", \"y\" \"sample\" holding coordinates set spots. \"barcode\" column character vector spatial barcodes, \"x\", \"y\" hold numeric values representing spot coordinates \"sample\" character vector unique sample IDs.","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/reference/get-network.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create Spatial Networks — GetSpatialNetwork","text":"Ludvig Larsson","code":""},{"path":"https://ludvigla.github.io/semla/reference/get-network.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Spatial Networks — GetSpatialNetwork","text":"","code":"if (FALSE) { library(ggplot2)  # Create a spatial network from a tibble with barcodes, (x, y) coordinates and sample IDs coordfiles <- c(system.file(\"extdata/mousebrain/spatial\",                             \"tissue_positions_list.csv\",                             package = \"semla\"),                 system.file(\"extdata/mousecolon/spatial\",                             \"tissue_positions_list.csv\",                             package = \"semla\"))  # Load coordinate data into a tibble xys <- do.call(rbind, lapply(seq_along(coordfiles), function(i) {   coords <- setNames(read.csv(coordfiles[i], header = FALSE),                      nm = c(\"barcode\", \"selection\", \"grid_y\", \"grid_x\", \"y\", \"x\"))   coords$sampleID <- i   coords <- coords |>     dplyr::filter(selection == 1) |>     dplyr::select(barcode, x, y, sampleID) |>     tibble::as_tibble()   return(coords) }))  # Create spatial networks from xys coordinates spatnet <- GetSpatialNetwork(xys)  # Plot network p1 <- ggplot(spatnet[[\"1\"]], aes(x = x_start, xend = x_end, y = y_start, yend = y_end)) +   geom_segment() +   scale_y_reverse()  p2 <- ggplot(spatnet[[\"2\"]], aes(x = x_start, xend = x_end, y = y_start, yend = y_end)) +   geom_segment() +   scale_y_reverse()  p1 + p2 }   library(semla)  se_mbrain <- readRDS(system.file(\"extdata/mousebrain\", \"se_mbrain\", package = \"semla\"))  # Get spatial network from a Seurat object spatnet <- GetSpatialNetwork(se_mbrain)  # Plot network ggplot(spatnet[[\"1\"]], aes(x = x_start, xend = x_end, y = y_start, yend = y_end)) +   geom_segment() +   scale_y_reverse()"},{"path":"https://ludvigla.github.io/semla/reference/icp.html","id":null,"dir":"Reference","previous_headings":"","what":"Iterative Closest Point algorithm ICP — icp","title":"Iterative Closest Point algorithm ICP — icp","text":"Aligns two sets unpaired point sets applying rotations translations. point sets can unequal length.","code":""},{"path":"https://ludvigla.github.io/semla/reference/icp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Iterative Closest Point algorithm ICP — icp","text":"","code":"icp(xy_ref, xy_query, iterations = 100)"},{"path":"https://ludvigla.github.io/semla/reference/icp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Iterative Closest Point algorithm ICP — icp","text":"xy_ref m x 2 numeric matrix reference points xy_query n x 2 numeric matrix query points iterations Number iterations run stopping ICP","code":""},{"path":"https://ludvigla.github.io/semla/reference/icp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Iterative Closest Point algorithm ICP — icp","text":"list following objects: y_transf: n x 2 matrix aligned query points rot_mat: 2 x 2 rotation matrix","code":""},{"path":"https://ludvigla.github.io/semla/reference/icp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Iterative Closest Point algorithm ICP — icp","text":"","code":"library(semla) library(dplyr) library(ggplot2)  # Load example mouse brain data se_mbrain <- readRDS(system.file(\"extdata/mousebrain\",                                  \"se_mbrain\",                                  package = \"semla\"))  # Get spatial network spatnet <- GetSpatialNetwork(se_mbrain)  # Keep tissue border points n1 <- spatnet[[1]] |>   filter(nn < 6) ggplot(n1, aes(x_start, y_start)) +   geom_point() +   scale_y_reverse()   # get spot coordinates points xy <- GetStaffli(se_mbrain)@meta_data |>   filter(barcode %in% unique(n1$from)) |>   select(pxl_col_in_fullres, pxl_row_in_fullres) |>   setNames(nm = c(\"x\", \"y\")) |>   bind_cols(type = \"set1\") xy_diff <- CoordTransform(xy_coords = xy[, 1:2],                           angle = 30,                           xy_offset = c(500, 500)) |>   slice_sample(n = nrow(xy) - 100) |>   setNames(nm = c(\"x\", \"y\")) |>   bind_cols(type = \"set2\") xy_orig <- bind_rows(xy, xy_diff)  # Plot point sets ggplot(xy_orig, aes(x, y, color = type)) +   geom_point() +   scale_y_reverse() +   labs(title = \"Original point sets\")   res <- icp(xy_ref = xy[, 1:2], xy_query = xy_diff[, 1:2])  xy_aligned <- xy |>   bind_rows(bind_cols(setNames(res$y_transf|> as_tibble(.name_repair = \"minimal\"),                                nm = c(\"x\", \"y\")),                       type = \"set2_aligned\"))  # Plot aligned point sets ggplot(xy_aligned, aes(x, y, color = type)) +   geom_point() +   scale_y_reverse() +   labs(title = \"Aligned point sets\")   # We can obtain the rotation angle in degrees from # the results atan2(res$rot_mat[2, 1], res$rot_mat[1, 1])*(180/pi) #> [1] -30"},{"path":"https://ludvigla.github.io/semla/reference/kabsch.html","id":null,"dir":"Reference","previous_headings":"","what":"Kabsch Algorithm — kabsch","title":"Kabsch Algorithm — kabsch","text":"Aligns two sets points via rotations translations.","code":""},{"path":"https://ludvigla.github.io/semla/reference/kabsch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Kabsch Algorithm — kabsch","text":"","code":"kabsch(pm, qm)"},{"path":"https://ludvigla.github.io/semla/reference/kabsch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Kabsch Algorithm — kabsch","text":"pm n x 2 matrix points align qm. qm n x 2 matrix reference points.","code":""},{"path":"https://ludvigla.github.io/semla/reference/kabsch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Kabsch Algorithm — kabsch","text":"list rotation matrix \"um\", aligned coordinates \"qm\" target coordinates \"pm\"","code":""},{"path":"https://ludvigla.github.io/semla/reference/kabsch.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Kabsch Algorithm — kabsch","text":"Given two sets points, one specified reference set, set rotated RMSD two minimized. format matrix one row n observations, number columns, d, specifies dimensionality points. point sets must equal size ordering, .e. point one second matrix mapped point one reference matrix, point two second matrix mapped point two reference matrix, .","code":""},{"path":"https://ludvigla.github.io/semla/reference/kabsch.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Kabsch Algorithm — kabsch","text":"original code written James Melville. See references link GitHub gist code taken .","code":""},{"path":"https://ludvigla.github.io/semla/reference/kabsch.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Kabsch Algorithm — kabsch","text":"https://gist.github.com/jlmelville/9b4e5d076e719a7541881e8cbf58a895 https://en.wikipedia.org/wiki/Kabsch_algorithm","code":""},{"path":"https://ludvigla.github.io/semla/reference/label-assortativity.html","id":null,"dir":"Reference","previous_headings":"","what":"Label Assortativity Analysis — RunLabelAssortativityTest","title":"Label Assortativity Analysis — RunLabelAssortativityTest","text":"Performs network assortativity test label, describing whether spots label displays clustered dispersed spatial pattern.","code":""},{"path":"https://ludvigla.github.io/semla/reference/label-assortativity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label Assortativity Analysis — RunLabelAssortativityTest","text":"","code":"RunLabelAssortativityTest(   object,   column_name,   n_permutations = 100,   nCores = parallel::detectCores() - 1,   seed = 123,   verbose = TRUE )"},{"path":"https://ludvigla.github.io/semla/reference/label-assortativity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label Assortativity Analysis — RunLabelAssortativityTest","text":"object Seurat object column_name Column name metadata corresponding label ID spots. n_permutations Integer specifying number iterations labels randomized [default: 100]. Recommended increase number permutations >=100 robust results. lower number permutations result high standard deviations thus unreliable output nCores Number cores [default: parallel::detectCores() - 1] seed seed use reproducibility [default: 123] verbose Print messages [default: TRUE]","code":""},{"path":"https://ludvigla.github.io/semla/reference/label-assortativity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Label Assortativity Analysis — RunLabelAssortativityTest","text":"tibble scores label.","code":""},{"path":"https://ludvigla.github.io/semla/reference/label-assortativity.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Label Assortativity Analysis — RunLabelAssortativityTest","text":"analysis inspired Newman's Assortativity measure looking average degree spots belonging class label (specified column_name). hypothesis want address spots label lie next aggregated fashion, compared randomly dispered throughout tissue. average degree within label may change based total number observations, scale towards maximum average degree (k) possible network (Visium, theoretical max avg k 6) minimum avg k expect see spots randomly dispered. n_permutations argument, can specify number iterations generating mean minimum avg k label. output function tibble table entries label corresponding observed avg k (avg_k), mean randomized avg k (min_avg_k_mean), standard deviation randomized avg k (min_avg_k_sd), scaled avg k (avg_k_scaled), scaled towards network max avg k (k_max) thus goes 0 (completely randomly dispersed) 1 (fully connected).","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/reference/label-assortativity.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Label Assortativity Analysis — RunLabelAssortativityTest","text":"Lovisa Franzén","code":""},{"path":"https://ludvigla.github.io/semla/reference/label-assortativity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label Assortativity Analysis — RunLabelAssortativityTest","text":"","code":"library(semla)  # Read data se <- readRDS(system.file(\"extdata/mousebrain\",                           \"se_mbrain\",                           package = \"semla\"))  # Generate clusters se <- se |>   NormalizeData() |>   ScaleData() |>   FindVariableFeatures() |>   RunPCA() |>   FindNeighbors(reduction = \"pca\", dims = 1:30) |>   FindClusters() #> Centering and scaling data matrix #> PC_ 1  #> Positive:  Nrgn, Olfm1, Cck, Nptxr, Rtn1, Snca, Nov, Tmsb4x, Lamp5, Egr1  #> \t   Crym, Cpne6, Coro1a, Arc, Hpca, Sst, Nr4a1, Npy, Chgb, Neurod6  #> \t   Snap25, Myh7, Uchl1, Eef1a2, Cort, Grp, Stmn2, Rprm, Spink8, Mfge8  #> Negative:  Mbp, Plp1, Apod, Mobp, Ptgds, Mog, Mal, Mag, Cnp, Aldh1a1  #> \t   Opalin, Tcf7l2, Ddc, Lhx1os, Slc6a3, Ret, Th, Slc18a2, Sncg, Drd2  #> \t   Chrna6, Slc10a4, Spp1, En1, Dlk1, Calb2, Hbb-bs, Pvalb, Col1a2, Tnnt1  #> PC_ 2  #> Positive:  Myoc, Gfap, Col1a2, Fmod, Slc13a4, Hba-a1, Hbb-bt, Slc6a20a, Hba-a2, Hbb-bs  #> \t   Acta2, Tagln, Mgp, Ogn, Vtn, H2-Aa, Lyz2, Cd74, Myl9, Dcn  #> \t   Myh11, Ptgds, Cytl1, H2-Eb1, Hmgcs2, Clu, Mfge8, Emp1, Npy, Cnn1  #> Negative:  Th, Uchl1, Slc18a2, En1, Slc10a4, Slc6a3, Chrna6, Stmn2, Ret, Snap25  #> \t   Drd2, Dlk1, Ddc, Scg2, Sncg, Eef1a2, Rtn1, Chga, Pcp4, Calb2  #> \t   Mobp, Mbp, Chgb, Fabp5, Plp1, Pvalb, Mog, Mal, Mag, Snca  #> PC_ 3  #> Positive:  Trbc2, Arc, Egr1, Myl4, Nr4a1, Mbp, Mobp, Pvalb, Plp1, Opalin  #> \t   Mog, Mal, Cnp, Mag, Snap25, Lamp5, Ighm, Tcf7l2, Cplx3, Tgm3  #> \t   Ighg2c, Pcp4, Hpca, Ly6d, Eef1a2, Tnnt1, Chga, Neurod6, Prph, Ctgf  #> Negative:  Nnat, Slc18a2, Dlk1, Slc6a3, Slc10a4, En1, Th, Chrna6, Dcn, Sncg  #> \t   Cpne7, Drd2, Ddc, Ret, Hpcal1, Ecel1, Cpne6, Col1a2, Trh, Calb2  #> \t   Cd24a, Fmod, Mgp, Snca, Lypd1, Slc13a4, Fibcd1, Crym, Spink8, Slc6a20a  #> PC_ 4  #> Positive:  Nr4a1, Arc, Lamp5, Egr1, Myl4, Trbc2, Chrna6, Tagln, En1, Snap25  #> \t   Th, Slc18a2, Acta2, Col1a2, Myh11, Fmod, Hba-a2, Slc10a4, Slc6a3, Slc13a4  #> \t   Ret, Tgm3, Hbb-bt, Slc6a20a, Ighm, Hbb-bs, Hba-a1, Vtn, Mgp, Drd2  #> Negative:  Spink8, Fibcd1, Tmsb4x, Nnat, Lefty1, Crym, Cpne7, Nos1, Dcn, Cpne6  #> \t   Grp, Homer3, Htr3a, Tac1, Fabp5, C1ql2, Trh, Opalin, Mog, Plp1  #> \t   Mag, Calb2, Ecel1, Gfap, Cnp, Tcf7l2, Lypd1, Vgll3, Hpcal1, Mal  #> PC_ 5  #> Positive:  En1, Chrna6, Th, Slc18a2, Slc10a4, Ddc, Lefty1, Arc, Slc6a3, Neurod6  #> \t   Grp, Nov, Lamp5, Fibcd1, Nr4a1, Drd2, Spink8, Vip, Myl4, Ret  #> \t   Egr1, Dlk1, Nrgn, Gfap, Trbc2, Tgm3, Myh7, Tac2, Sncg, Npy  #> Negative:  Pcp4, Tcf7l2, Snap25, Uchl1, Eef1a2, Chga, Stmn2, Lhx1os, Calb2, Scg2  #> \t   Fabp5, Bok, Prkcd, Pvalb, Cartpt, Chgb, Tnnt1, Gpx3, Slc20a1, Rtn1  #> \t   C1ql2, Spp1, Hpcal1, Ptgds, Pitx2, Lypd1, Aldh1a1, Ecel1, Vtn, Nme7  #> Computing nearest neighbor graph #> Computing SNN #> Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck #>  #> Number of nodes: 2560 #> Number of edges: 107827 #>  #> Running Louvain algorithm... #> Maximum modularity in 10 random starts: 0.8228 #> Number of communities: 12 #> Elapsed time: 0 seconds  # Run Label Assortativity Analysis res <- RunLabelAssortativityTest(object = se,                                  column_name = \"seurat_clusters\",                                  n_permutations = 100,                                  nCores = 2) #>  #> ── Running Label Assortativity Test ── #>  #> ℹ Generating neighborhood adjacency data from observed labels in column 'seurat_clusters' #> ✔ Observed label average degree calculations complete #> ℹ Generating neighborhood adjacency data from randomized labels #> ✔ Randomized label adjacency calculations complete from 100 iterations #> ! The standard deviation of some of the permuted results is relatively high (>0.1) which may indicate unreliable results. #> A possible solution could be to increase the number of permutations ('n_permutations'). #> ✔ Scores calculated for each label and returned as output tibble  res |> arrange(desc(avg_k_scaled)) #> # A tibble: 12 × 6 #>    label avg_k min_avg_k_mean min_avg_k_sd k_max avg_k_scaled #>    <fct> <dbl>          <dbl>        <dbl> <dbl>        <dbl> #>  1 0      5.06           1.52       0.0610  5.88        0.814 #>  2 10     4.88           1.05       0.121   5.88        0.793 #>  3 7      4.75           1.10       0.0898  5.88        0.764 #>  4 4      4.68           1.30       0.0650  5.88        0.739 #>  5 11     4.54           1.02       0.100   5.88        0.724 #>  6 2      4.59           1.40       0.0641  5.88        0.712 #>  7 1      4.53           1.44       0.0651  5.88        0.697 #>  8 5      4.18           1.19       0.0624  5.88        0.639 #>  9 3      4.14           1.36       0.0669  5.88        0.615 #> 10 9      3.94           1.06       0.120   5.88        0.598 #> 11 6      2.86           1.16       0.0792  5.88        0.361 #> 12 8      1.95           1.09       0.0888  5.88        0.180"},{"path":"https://ludvigla.github.io/semla/reference/load-images.html","id":null,"dir":"Reference","previous_headings":"","what":"Load images — LoadImages","title":"Load images — LoadImages","text":"Load H&E images (custom images) required visualization methods semla.","code":""},{"path":"https://ludvigla.github.io/semla/reference/load-images.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Load images — LoadImages","text":"","code":"LoadImages(object, ...)  # S3 method for default LoadImages(object, image_height = 400, pad_info = NULL, verbose = TRUE, ...)  # S3 method for Seurat LoadImages(object, image_height = 400, verbose = TRUE, ...)"},{"path":"https://ludvigla.github.io/semla/reference/load-images.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Load images — LoadImages","text":"object object ... Arguments passed methods image_height integer specifying height -scaled images pad_info tibble information image padded verbose print messages","code":""},{"path":"https://ludvigla.github.io/semla/reference/load-images.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Load images — LoadImages","text":"object images raster format","code":""},{"path":"https://ludvigla.github.io/semla/reference/load-images.html","id":"default-method","dir":"Reference","previous_headings":"","what":"default method","title":"Load images — LoadImages","text":"character vector image paths provided, images loaded, -scaled based image_height returned list raster objects. JPEG PNG images supported.","code":""},{"path":"https://ludvigla.github.io/semla/reference/load-images.html","id":"seurat","dir":"Reference","previous_headings":"","what":"Seurat","title":"Load images — LoadImages","text":"Seurat object provided, images loaded raster objects stored inside Staffli object located tools slot.","code":""},{"path":"https://ludvigla.github.io/semla/reference/load-images.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Load images — LoadImages","text":"","code":"library(semla)  # Get paths for example images mousebrain_jpg <- system.file(\"extdata/mousebrain\",                                \"spatial/tissue_hires_image.jpg\",                                package = \"semla\") mousecolon_jpg <- system.file(\"extdata/mousecolon\",                                \"spatial/tissue_hires_image.jpg\",                                package = \"semla\")  rasters <- LoadImages(c(mousebrain_jpg, mousecolon_jpg)) #>  #> ── Loading H&E images ── #>  #> ℹ Loading image from /private/var/folders/zb/1fj07x_5343fvs_k28gnm1z80002xs/T/RtmpFJGwBj/temp_libpath502354c29e9d/semla/extdata/mousebrain/spatial/tissue_hires_image.jpg #> ℹ Scaled image from 2000x1882 to 400x376 pixels #> ℹ Loading image from /private/var/folders/zb/1fj07x_5343fvs_k28gnm1z80002xs/T/RtmpFJGwBj/temp_libpath502354c29e9d/semla/extdata/mousecolon/spatial/tissue_hires_image.jpg #> ℹ Scaled image from 1804x2000 to 400x443 pixels #> ℹ Saving loaded H&E images as 'rasters' in Seurat object  par(mfrow = c(1, 2), mar = c(0, 0, 0, 0)) for (rst in rasters) {   plot(rst) }    #' library(semla)  # Load example Visium data se_mbrain <- readRDS(system.file(\"extdata/mousebrain\", \"se_mbrain\", package = \"semla\")) se_mcolon <- readRDS(system.file(\"extdata/mousecolon\", \"se_mcolon\", package = \"semla\")) se_merged <- MergeSTData(se_mbrain, se_mcolon)  # Load images se_merged <- LoadImages(se_merged) #>  #> ── Loading H&E images ── #>  #> ℹ Loading image from /private/var/folders/zb/1fj07x_5343fvs_k28gnm1z80002xs/T/RtmpFJGwBj/temp_libpath502354c29e9d/semla/extdata/mousebrain/spatial/tissue_hires_image.jpg #> ℹ Scaled image from 2000x1882 to 400x376 pixels #> ℹ Loading image from /private/var/folders/zb/1fj07x_5343fvs_k28gnm1z80002xs/T/RtmpFJGwBj/temp_libpath502354c29e9d/semla/extdata/mousecolon/spatial/tissue_hires_image.jpg #> ℹ Scaled image from 1804x2000 to 400x443 pixels #> ℹ Saving loaded H&E images as 'rasters' in Seurat object"},{"path":"https://ludvigla.github.io/semla/reference/local-G.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate local G statistic — RunLocalG","title":"Calculate local G statistic — RunLocalG","text":"local spatial statistic measures concentration high low values given region. can example used define spatial structures tissue section based values selected features. Furthermore, local G statistic can used high/low clustering data. NB: function calculates G, G star.","code":""},{"path":"https://ludvigla.github.io/semla/reference/local-G.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate local G statistic — RunLocalG","text":"","code":"RunLocalG(object, ...)  # S3 method for default RunLocalG(   object,   spatnet,   alternative = c(\"two.sided\", \"greater\", \"less\"),   return_as_tibble = TRUE,   verbose = TRUE,   ... )  # S3 method for Seurat RunLocalG(   object,   features,   alternative = NULL,   store_in_metadata = TRUE,   assay_name = \"GiScores\",   verbose = TRUE,   ... )"},{"path":"https://ludvigla.github.io/semla/reference/local-G.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate local G statistic — RunLocalG","text":"object object ... Arguments passed methods spatnet list tibbles containing spatial networks generated GetSpatialNetwork alternative string specifying alternative hypothesis: \"two.sided\", \"greater\" \"less\". default, local G scores returned. alternative test specified, function return local G scores p-values. Note p-values adjusted multiple hypothesis testing within feature using \"BH\" correction. want adjust p-values different strategy, can compute p-values directly local G z-scores. return_as_tibble Logical specifying whether results returned object class tbl verbose Print messages features character vector feature names fetchable FetchData store_in_metadata logical specifying results returned meta data slot. set FALSE, results instead returned assay named assay_name. statistical test applied, adjusted p-values returned meta data slot store_in_metadata = TRUE @misc slot assay store_in_metadata = FALSE. assay_name Name assay store_in_metadata=FALSE","code":""},{"path":"https://ludvigla.github.io/semla/reference/local-G.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate local G statistic — RunLocalG","text":"object local G statistics","code":""},{"path":"https://ludvigla.github.io/semla/reference/local-G.html","id":"default-method","dir":"Reference","previous_headings":"","what":"default method","title":"Calculate local G statistic — RunLocalG","text":"Takes matrix-like object one feature per column list spatial networks generated GetSpatialNetwork computes local G scores optionally p-values. G scores prefixed \"Gi\" p-values prefixed one \"Pr(z <!=\", \"Pr(z \" \"Pr(z <\" depending chosen test.","code":""},{"path":"https://ludvigla.github.io/semla/reference/local-G.html","id":"seurat","dir":"Reference","previous_headings":"","what":"Seurat","title":"Calculate local G statistic — RunLocalG","text":"Takes Seurat object input returns local G scores selected number features optionally p-values. G scores prefixed \"Gi\" p-values prefixed one \"Pr(z <!=\", \"Pr(z \" \"Pr(z <\" depending chosen test.","code":""},{"path":"https://ludvigla.github.io/semla/reference/local-G.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate local G statistic — RunLocalG","text":"Ord, J. K. Getis, . 1995 Local spatial autocorrelation statistics: distributional issues application. Geographical Analysis, 27, 286–306 Bivand RS, Wong DWS 2018 Comparing implementations global local indicators spatial association. TEST, 27(3), 716–748 DOI link","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/reference/local-G.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate local G statistic — RunLocalG","text":"Ludvig Larsson","code":""},{"path":"https://ludvigla.github.io/semla/reference/local-G.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate local G statistic — RunLocalG","text":"","code":"library(semla) library(tibble) library(dplyr) library(ggplot2) library(viridis) #> Loading required package: viridisLite  # read coordinates coordfile <- system.file(\"extdata/mousebrain/spatial\",                          \"tissue_positions_list.csv\",                          package = \"semla\") coords <- read.csv(coordfile, header = FALSE) |>   filter(V2 == 1) |>   select(V1, V6, V5) |>   setNames(nm = c(\"barcode\", \"x\", \"y\")) |>   bind_cols(sampleID = 1) |>   as_tibble()  # get spatial network spatnet <- GetSpatialNetwork(coords)  # Load expression data feature_matrix <- system.file(\"extdata/mousebrain\",                               \"filtered_feature_bc_matrix.h5\",                               package = \"semla\") |>   Seurat::Read10X_h5() featureMat <- t(as.matrix(feature_matrix[c(\"Mgp\", \"Th\", \"Nrgn\"), ])) featureMat <- featureMat[coords$barcode, ] head(featureMat) #>                    Mgp Th Nrgn #> CATACAAAGCCGAACC-1   0  0   19 #> CTGAGCAAGTAACAAG-1   0  0  309 #> GGGTACCCACGGTCCT-1   0  0  108 #> ACGGAATTTAGCAAAT-1   0  0  246 #> GGGCGGTCCTATTGTC-1   0  0  190 #> ATGTTACGAGCAATAC-1   0  0  130  # Calculate G scores g_scores <- RunLocalG(log1p(featureMat), spatnet) #> ℹ Setting alternative hypothesis to 'two.sided' #> →   Calculating local G scores for 2559 spots in sample 1 #> ℹ Calculating p-values for local G scores, MH-adjusted within each feature #> ℹ G scores will be named Gi[Ftr] and adjusted p-values will be named Pr(z != E(Gi[Ftr])) head(g_scores) #> # A tibble: 6 × 7 #>   barcode            `Gi[Mgp]` Pr(z != E(Gi[Mg…¹ Gi[Th…² Pr(z …³ Gi[Nr…⁴ Pr(z …⁵ #>   <chr>                  <dbl>             <dbl>   <dbl>   <dbl>   <dbl>   <dbl> #> 1 CATACAAAGCCGAACC-1    -0.893             0.757  -0.377   0.894   0.804  0.509  #> 2 CTGAGCAAGTAACAAG-1    -0.711             0.757  -0.533   0.812   2.40   0.0522 #> 3 GGGTACCCACGGTCCT-1    -1.09              0.608  -0.462   0.856   2.52   0.0413 #> 4 ACGGAATTTAGCAAAT-1    -0.645             0.757  -0.654   0.759   2.78   0.0247 #> 5 GGGCGGTCCTATTGTC-1    -1.26              0.608  -0.533   0.812   2.40   0.0517 #> 6 ATGTTACGAGCAATAC-1    -1.10              0.608  -0.654   0.759   2.65   0.0322 #> # … with abbreviated variable names ¹​`Pr(z != E(Gi[Mgp]))`, ²​`Gi[Th]`, #> #   ³​`Pr(z != E(Gi[Th]))`, ⁴​`Gi[Nrgn]`, ⁵​`Pr(z != E(Gi[Nrgn]))`  # Bind results with coords for plotting gg <- coords |>   bind_cols(log1p(featureMat)) |>   left_join(y = g_scores, by = \"barcode\")  # Plot some results p1 <- ggplot(gg, aes(x, y, color = Th)) + ggtitle(\"Expression\") p2 <- ggplot(gg, aes(x, y, color = `Gi[Th]`)) + ggtitle(\"Local G\") p3 <- ggplot(gg, aes(x, y, color = -log10(`Pr(z != E(Gi[Th]))`))) + ggtitle(\"-log10(p-value)\")  p <- p1 + p2 + p3 &   geom_point() &   theme_void() &   scale_y_reverse() &   coord_fixed() &   scale_colour_gradientn(colours = viridis(n = 9)) p    library(semla) library(dplyr)  # Load Seurat object with mouse bain data se_mbrain <- readRDS(system.file(\"extdata/mousebrain\", \"se_mbrain\", package = \"semla\")) se_mbrain <- se_mbrain |>   ScaleData(verbose = FALSE) |>   FindVariableFeatures(verbose = FALSE) |>   RunPCA(verbose = FALSE)  # Calculate G scores se_mbrain <- RunLocalG(se_mbrain, features = c(\"Th\", \"Mgp\"), alternative = \"greater\") #>  #> ── Calculating local G ── #>  #> ℹ Got 2 feature(s) #> ℹ Setting alternative hypothesis to 'greater' #> →   Calculating local G scores for 2559 spots in sample 1 #> ℹ Calculating p-values for local G scores, MH-adjusted within each feature #> ℹ G scores will be named Gi[Ftr] and adjusted p-values will be named Pr(z > E(Gi[Ftr])) #> ℹ Placing results in 'Seurat' object meta.data slot #> ✔ Returning results  # Plot G scores MapFeatures(se_mbrain, features = \"Gi[Th]\")   # high/low clustering se_mbrain$cluster <- se_mbrain[[]] |>   mutate(cluster = case_when(     `Pr(z > E(Gi[Th]))` > 0.05 ~ \"Not Significant\",     `Pr(z > E(Gi[Th]))` <= 0.05 & `Gi[Th]` > 0 ~ \"High\"   )) |> pull(cluster) MapLabels(se_mbrain, column_name = \"cluster\")"},{"path":"https://ludvigla.github.io/semla/reference/manual-transform-images.html","id":null,"dir":"Reference","previous_headings":"","what":"Manually apply rigid transformations to images — RunAlignment","title":"Manually apply rigid transformations to images — RunAlignment","text":"Opens interactive viewer images interactive objects can rotated, moved, scaled mirrored. often difficult automate image registration H&E images, particular tissue sections damaged, distorted folded. situations, manual registration can useful.","code":""},{"path":"https://ludvigla.github.io/semla/reference/manual-transform-images.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Manually apply rigid transformations to images — RunAlignment","text":"","code":"RunAlignment(object, ...)  # S3 method for default RunAlignment(   object,   container_width = \"800px\",   container_height = \"650px\",   launch_browser = TRUE,   ... )  # S3 method for Seurat RunAlignment(   object,   image_height = 400,   container_width = \"800px\",   container_height = \"650px\",   launch_browser = TRUE,   verbose = TRUE,   ... )"},{"path":"https://ludvigla.github.io/semla/reference/manual-transform-images.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Manually apply rigid transformations to images — RunAlignment","text":"object object ... Arguments passed methods container_width, container_height Width height paper widget given pixels. launch_browser app opened default browser? Default TRUE. Set launch_browser = getOption(\"shiny.launch.browser\", interactive()) use RStudio  built-browser. image_height integer used rescaling images verbose Print messages","code":""},{"path":"https://ludvigla.github.io/semla/reference/manual-transform-images.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Manually apply rigid transformations to images — RunAlignment","text":"object aligned images","code":""},{"path":"https://ludvigla.github.io/semla/reference/manual-transform-images.html","id":"default-method","dir":"Reference","previous_headings":"","what":"default method","title":"Manually apply rigid transformations to images — RunAlignment","text":"Takes list images prepared prep_image function send interactive application. application stops (clicking \"quit & save\") tibble returned information rigid transformations applied images.","code":""},{"path":"https://ludvigla.github.io/semla/reference/manual-transform-images.html","id":"seurat-method","dir":"Reference","previous_headings":"","what":"Seurat method","title":"Manually apply rigid transformations to images — RunAlignment","text":"Takes Seurat object least 2 tissue sections opens interactive shiny application rigid transformations can applied images. application stops (clicking \"quit & save\"), transformations  applied images using RigidTransformImages  Seurat object returned. transformations supplied, function return input Seurat object unmodified.","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/reference/manual-transform-images.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Manually apply rigid transformations to images — RunAlignment","text":"Ludvig Larsson","code":""},{"path":"https://ludvigla.github.io/semla/reference/manual-transform-images.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Manually apply rigid transformations to images — RunAlignment","text":"","code":"if (FALSE) {  library(semla) library(magick)  im_mbrain <- system.file(\"extdata/mousebrain/spatial\",                          \"tissue_hires_image.jpg\",                          package = \"semla\")  img1 <- prep_image(im_mbrain |>                    image_read(),                    height = 512) img2 <- prep_image(im_mbrain |>                    image_read() |>                    image_flip(),                    height = 512)  transforms <- RunAlignment(object = list(img1, img2))  }  if (FALSE) { library(semla)  se_mbrain <- readRDS(system.file(\"extdata/mousebrain\", \"se_mbrain\", package = \"semla\")) se_mcolon <- readRDS(system.file(\"extdata/mousecolon\", \"se_mcolon\", package = \"semla\")) se_merged <- MergeSTData(se_mbrain, se_mcolon) |>    LoadImages()  # Run alignment application se_merged <- RunAlignment(se_merged) }"},{"path":"https://ludvigla.github.io/semla/reference/mask-images.html","id":null,"dir":"Reference","previous_headings":"","what":"Mask images — MaskImages","title":"Mask images — MaskImages","text":"Image masking can sometimes useful want remove background H&E image. usually relevant creating figures. function provides simple image masking technique based blob extraction. Since image masking challenging task, guaranteed work H&E images. Certain artefacts can particularly difficult remove, example bubbles tissue stain removed properly. Even artefacts detected algorithm, can provide set spot coordinates used try filter artefacts covered spots. Note method useful H&E images. stains image types (e.g. immunofluorescence images) likely work.","code":""},{"path":"https://ludvigla.github.io/semla/reference/mask-images.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mask images — MaskImages","text":"","code":"MaskImages(object, ...)  # S3 method for default MaskImages(   object,   xy_coords = NULL,   method = c(\"magentaSeg\", \"blurSeg\"),   custom_method = NULL,   minPixels = 100,   verbose = TRUE,   ... )  # S3 method for Seurat MaskImages(   object,   section_numbers = NULL,   method = c(\"magentaSeg\", \"blurSeg\"),   custom_method = NULL,   minPixels = 100,   verbose = TRUE,   ... )"},{"path":"https://ludvigla.github.io/semla/reference/mask-images.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mask images — MaskImages","text":"object object ... Arguments passed methods xy_coords Optional tibble spot coordinates matching input image method Segmentation method use. Choose one \"magentaSeg\" \"blurSeg\" custom_method function takes \"magick-image\" object input returns  segmented \"magick-image\" output. See section \"custom masking\" details. minPixels Minimum area blobs used remove small artefacts given pixels. verbose Print messages section_numbers integer vector specifying samples mask","code":""},{"path":"https://ludvigla.github.io/semla/reference/mask-images.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mask images — MaskImages","text":"object masked images","code":""},{"path":"https://ludvigla.github.io/semla/reference/mask-images.html","id":"default-method","dir":"Reference","previous_headings":"","what":"default method","title":"Mask images — MaskImages","text":"returns masked 'magick-image' object","code":""},{"path":"https://ludvigla.github.io/semla/reference/mask-images.html","id":"seurat","dir":"Reference","previous_headings":"","what":"Seurat","title":"Mask images — MaskImages","text":"Returns Seurat object masked images","code":""},{"path":"https://ludvigla.github.io/semla/reference/mask-images.html","id":"custom-masking","dir":"Reference","previous_headings":"","what":"Custom masking","title":"Mask images — MaskImages","text":"masking fails, can write masking function magick.  function needs take object class \"magick-image\" input  return object class. image needs segmented  blob-extraction work properly. Visit magick R package  [website](https://cran.r-project.org/web/packages/magick/vignettes/intro.html) information apply magick methods segmentation. can find basic  example visit semla website detailed instructions.","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/reference/mask-images.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Mask images — MaskImages","text":"Ludvig Larsson","code":""},{"path":"https://ludvigla.github.io/semla/reference/mask-images.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mask images — MaskImages","text":"","code":"library(semla) library(magick) library(dplyr)  # Load image lowresimagefile <- system.file(\"extdata/mousebrain/spatial\",                                \"tissue_lowres_image.jpg\",                                package = \"semla\") im <- image_read(lowresimagefile)  # Load coordinates coordinatesfile <- system.file(\"extdata/mousebrain/spatial\",                                \"tissue_positions_list.csv\",                                package = \"semla\") xy <- LoadSpatialCoordinates(coordinatefiles = coordinatesfile) #> ℹ Loading coordinates: #> →   Finished loading coordinates for sample 1 #> ℹ Collected coordinates for 2560 spots.  # Load scalefactors json <- system.file(\"extdata/mousebrain/spatial\",                     \"scalefactors_json.json\",                     package = \"semla\") scalefactors <- jsonlite::read_json(path = json) xy <- xy |>   mutate(across(pxl_row_in_fullres:pxl_col_in_fullres,                 ~ round(.x*scalefactors$tissue_lowres_scalef))) |>   select(pxl_row_in_fullres:pxl_col_in_fullres)  im_masked <- MaskImages(im, xy_coords = xy) #> ℹ Segmenting image using blob extraction #> ℹ Using method 'magentaSeg' #> ℹ Filtering out blobs with fewer than 100 pixels #> ℹ Filtering out blobs that do not overlap with provided coordinates #> ✔ Composed masked image from selected blobs  par(mfrow = c(1, 2), mar = c(0, 0, 0, 0)) im |> as.raster() |> plot() im_masked |> as.raster() |> plot()    library(semla)  # Load example Visium data se_mbrain <- readRDS(system.file(\"extdata/mousebrain\", \"se_mbrain\", package = \"semla\")) se_mcolon <- readRDS(system.file(\"extdata/mousecolon\", \"se_mcolon\", package = \"semla\")) se_merged <- MergeSTData(se_mbrain, se_mcolon) |> LoadImages() #>  #> ── Loading H&E images ── #>  #> ℹ Loading image from /private/var/folders/zb/1fj07x_5343fvs_k28gnm1z80002xs/T/RtmpFJGwBj/temp_libpath502354c29e9d/semla/extdata/mousebrain/spatial/tissue_hires_image.jpg #> ℹ Scaled image from 2000x1882 to 400x376 pixels #> ℹ Loading image from /private/var/folders/zb/1fj07x_5343fvs_k28gnm1z80002xs/T/RtmpFJGwBj/temp_libpath502354c29e9d/semla/extdata/mousecolon/spatial/tissue_hires_image.jpg #> ℹ Scaled image from 1804x2000 to 400x443 pixels #> ℹ Saving loaded H&E images as 'rasters' in Seurat object se_merged <- se_merged |> MaskImages() #>  #> ── Masking image(s) ── #>  #> ℹ Found 2 samples #> ℹ Fetched images #> ℹ Fetched spot coordinates #> ℹ Processing sample 1 #> ℹ Segmenting image using blob extraction #> ℹ Using method 'magentaSeg' #> ℹ Filtering out blobs with fewer than 100 pixels #> ℹ Filtering out blobs that do not overlap with provided coordinates #> ✔ Composed masked image from selected blobs #> ℹ Processing sample 2 #> ℹ Segmenting image using blob extraction #> ℹ Using method 'magentaSeg' #> ℹ Filtering out blobs with fewer than 100 pixels #> ℹ Filtering out blobs that do not overlap with provided coordinates #> ✔ Composed masked image from selected blobs #> ✔ Returning Seurat object with masked images  # Plot masked images ImagePlot(se_merged)   # Using a custom method custom_fkn <- function(object) {   object |>     image_convert(colorspace = \"cmyk\") |>      image_channel(channel = \"Magenta\") |>      image_threshold(threshold = \"7%\") |>      image_threshold(threshold = \"7%\", type = \"white\") |>     image_connect(connectivity = 1) }  se_mbrain <- se_mbrain |> LoadImages() #>  #> ── Loading H&E images ── #>  #> ℹ Loading image from /private/var/folders/zb/1fj07x_5343fvs_k28gnm1z80002xs/T/RtmpFJGwBj/temp_libpath502354c29e9d/semla/extdata/mousebrain/spatial/tissue_hires_image.jpg #> ℹ Scaled image from 2000x1882 to 400x376 pixels #> ℹ Saving loaded H&E images as 'rasters' in Seurat object se_mbrain <- MaskImages(se_mbrain, custom_method = custom_fkn) #>  #> ── Masking image(s) ── #>  #> ℹ Found 1 samples #> ℹ Fetched images #> ℹ Fetched spot coordinates #> ℹ Processing sample 1 #> ℹ Segmenting image using blob extraction #> ℹ Using custom method #> ℹ Filtering out blobs with fewer than 100 pixels #> ℹ Filtering out blobs that do not overlap with provided coordinates #> ✔ Composed masked image from selected blobs #> ✔ Returning Seurat object with masked images  ImagePlot(se_mbrain)"},{"path":"https://ludvigla.github.io/semla/reference/mbrain_dataset.html","id":null,"dir":"Reference","previous_headings":"","what":"Visium mouse brain dataset — mbrain_dataset","title":"Visium mouse brain dataset — mbrain_dataset","text":"Visium dataset obtained coronal tissue section mouse brain. mousebrain/filtered_feature_bc_matrix.h5: light weight gene expression matrix 188 genes hdf5 format filtered include spots tissue mousebrain/spatial/tissue_lowres_image.jpg:  H&E image (600x565) pixels mousebrain/spatial/tissue_hires_image.jpg:  H&E image (2000x1882) pixels mousebrain/spatial/tissue_positions_list.csv:  CSV file spot coordinates mousebrain/spatial/scalefactors_json.json:  JSON file scalefactors mousebrain/se_mbrain:  Seurat object stored .Rds file top 100 variable features","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/reference/mcolon_dataset.html","id":null,"dir":"Reference","previous_headings":"","what":"Visium mouse colon dataset — mcolon_dataset","title":"Visium mouse colon dataset — mcolon_dataset","text":"Visium dataset obtained \"swiss roll\" mouse colon mousecolon/filtered_feature_bc_matrix.h5: light weight gene expression matrix 188 genes hdf5 format filtered include spots tissue mousecolon/spatial/tissue_lowres_image.jpg:  H&E image (600x541) pixels mousecolon/spatial/tissue_hires_image.jpg:  H&E image (2000x1804) pixels mousecolon/spatial/tissue_positions_list.csv:  CSV file spot coordinates mousecolon/spatial/scalefactors_json.json:  JSON file scalefactors mousecolon/se_mcolon:  Seurat object stored .Rds file top 100 variable features mousecolon/galt_spots.csv:  CSV file GALT spot barcodes","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/reference/merge.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge 10x Visium data — MergeSTData","title":"Merge 10x Visium data — MergeSTData","text":"Merges two Seurat objects containing SRT data making sure spatial data (images spot coordinates) handled correctly.","code":""},{"path":"https://ludvigla.github.io/semla/reference/merge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge 10x Visium data — MergeSTData","text":"","code":"MergeSTData(   x,   y,   merge_data = TRUE,   merge_dr = NULL,   project = \"SeuratProject\" )"},{"path":"https://ludvigla.github.io/semla/reference/merge.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge 10x Visium data — MergeSTData","text":"x Seurat object y Seurat object list Seurat objects merge_data Merge data slots instead just merging counts (requires re-normalization); recommended normalization approach applied objects. See merge details. merge_dr Merge specified DimReducs present objects; merge embeddings slots first N dimensions shared across objects. See merge details. project Project name Seurat object","code":""},{"path":"https://ludvigla.github.io/semla/reference/merge.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merge 10x Visium data — MergeSTData","text":"merged Seurat object","code":""},{"path":"https://ludvigla.github.io/semla/reference/merge.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Merge 10x Visium data — MergeSTData","text":"NB: use generic merge function able use semla visualization methods output object Staffli object broken.","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/reference/merge.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Merge 10x Visium data — MergeSTData","text":"Ludvig Larsson","code":""},{"path":"https://ludvigla.github.io/semla/reference/merge.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Merge 10x Visium data — MergeSTData","text":"","code":"se_mbrain <- readRDS(system.file(\"extdata\",                                  \"mousebrain/se_mbrain\",                                  package = \"semla\")) se_mcolon <- readRDS(system.file(\"extdata\",                                  \"mousecolon/se_mcolon\",                                  package = \"semla\"))  se_mbrain #> An object of class Seurat  #> 188 features across 2560 samples within 1 assay  #> Active assay: Spatial (188 features, 170 variable features) se_mcolon #> An object of class Seurat  #> 188 features across 2604 samples within 1 assay  #> Active assay: Spatial (188 features, 182 variable features)  # Merge a mousebrain dataset with two mousecolon datasets se_merged <- MergeSTData(x = se_mbrain, y = se_mcolon) se_merged #> An object of class Seurat  #> 188 features across 5164 samples within 1 assay  #> Active assay: Spatial (188 features, 0 variable features)  # Plot H&E images ImagePlot(se_merged |> LoadImages(verbose = FALSE))"},{"path":"https://ludvigla.github.io/semla/reference/neighborhood-enrichment.html","id":null,"dir":"Reference","previous_headings":"","what":"Neighborhood Enrichment Analysis — RunNeighborhoodEnrichmentTest","title":"Neighborhood Enrichment Analysis — RunNeighborhoodEnrichmentTest","text":"Performs Neighborhood Enrichment Analysis spot labels, describing whether spots two categories lie next spatially often expected chance.","code":""},{"path":"https://ludvigla.github.io/semla/reference/neighborhood-enrichment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Neighborhood Enrichment Analysis — RunNeighborhoodEnrichmentTest","text":"","code":"RunNeighborhoodEnrichmentTest(   object,   column_name,   column_labels = NA,   n_permutations = 200,   nCores = parallel::detectCores() - 1,   seed = 123,   verbose = TRUE )"},{"path":"https://ludvigla.github.io/semla/reference/neighborhood-enrichment.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Neighborhood Enrichment Analysis — RunNeighborhoodEnrichmentTest","text":"object Seurat object column_name Column name metadata corresponding label ID spots. column_labels Optional. Provide vector label IDs subset analysis . Spots labels excluded. Must one. Default (NA). n_permutations Integer specifying number iterations labels randomized [default: 200]. Recommended increase number permutations >=200 robust results. lower number permutations result high standard deviations thus unreliable z-scores. nCores Number cores [default: parallel::detectCores() - 1] seed seed reproducibility [default: 123] verbose Print messages [default: TRUE]","code":""},{"path":"https://ludvigla.github.io/semla/reference/neighborhood-enrichment.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Neighborhood Enrichment Analysis — RunNeighborhoodEnrichmentTest","text":"tibble scores label pair.","code":""},{"path":"https://ludvigla.github.io/semla/reference/neighborhood-enrichment.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Neighborhood Enrichment Analysis — RunNeighborhoodEnrichmentTest","text":"analysis calculates enrichment score, z-score, based often spots different categorical labels (specified column_name) lies adjacent . observed number edges labels compared results set number permutations (chosen n_permutations), allowing calculation z-score. z-score indicate label pair overrepresented underrepresented compared expected see chance. output function tibble table label pair contains information observed number edges (edges), mean permuted results (perm_mean), standard deviation permuted results (perm_sd), z-score (z_score).","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/reference/neighborhood-enrichment.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Neighborhood Enrichment Analysis — RunNeighborhoodEnrichmentTest","text":"Lovisa Franzén","code":""},{"path":"https://ludvigla.github.io/semla/reference/neighborhood-enrichment.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Neighborhood Enrichment Analysis — RunNeighborhoodEnrichmentTest","text":"","code":"library(semla)  # Read data se <- readRDS(system.file(\"extdata/mousebrain\",                           \"se_mbrain\",                           package = \"semla\"))  # Generate clusters se <- se |>   NormalizeData() |>   ScaleData() |>   FindVariableFeatures() |>   RunPCA() |>   FindNeighbors(reduction = \"pca\", dims = 1:30) |>   FindClusters() #> Centering and scaling data matrix #> PC_ 1  #> Positive:  Nrgn, Olfm1, Cck, Nptxr, Rtn1, Snca, Nov, Tmsb4x, Lamp5, Egr1  #> \t   Crym, Cpne6, Coro1a, Arc, Hpca, Sst, Nr4a1, Npy, Chgb, Neurod6  #> \t   Snap25, Myh7, Uchl1, Eef1a2, Cort, Grp, Stmn2, Rprm, Spink8, Mfge8  #> Negative:  Mbp, Plp1, Apod, Mobp, Ptgds, Mog, Mal, Mag, Cnp, Aldh1a1  #> \t   Opalin, Tcf7l2, Ddc, Lhx1os, Slc6a3, Ret, Th, Slc18a2, Sncg, Drd2  #> \t   Chrna6, Slc10a4, Spp1, En1, Dlk1, Calb2, Hbb-bs, Pvalb, Col1a2, Tnnt1  #> PC_ 2  #> Positive:  Myoc, Gfap, Col1a2, Fmod, Slc13a4, Hba-a1, Hbb-bt, Slc6a20a, Hba-a2, Hbb-bs  #> \t   Acta2, Tagln, Mgp, Ogn, Vtn, H2-Aa, Lyz2, Cd74, Myl9, Dcn  #> \t   Myh11, Ptgds, Cytl1, H2-Eb1, Hmgcs2, Clu, Mfge8, Emp1, Npy, Cnn1  #> Negative:  Th, Uchl1, Slc18a2, En1, Slc10a4, Slc6a3, Chrna6, Stmn2, Ret, Snap25  #> \t   Drd2, Dlk1, Ddc, Scg2, Sncg, Eef1a2, Rtn1, Chga, Pcp4, Calb2  #> \t   Mobp, Mbp, Chgb, Fabp5, Plp1, Pvalb, Mog, Mal, Mag, Snca  #> PC_ 3  #> Positive:  Trbc2, Arc, Egr1, Myl4, Nr4a1, Mbp, Mobp, Pvalb, Plp1, Opalin  #> \t   Mog, Mal, Cnp, Mag, Snap25, Lamp5, Ighm, Tcf7l2, Cplx3, Tgm3  #> \t   Ighg2c, Pcp4, Hpca, Ly6d, Eef1a2, Tnnt1, Chga, Neurod6, Prph, Ctgf  #> Negative:  Nnat, Slc18a2, Dlk1, Slc6a3, Slc10a4, En1, Th, Chrna6, Dcn, Sncg  #> \t   Cpne7, Drd2, Ddc, Ret, Hpcal1, Ecel1, Cpne6, Col1a2, Trh, Calb2  #> \t   Cd24a, Fmod, Mgp, Snca, Lypd1, Slc13a4, Fibcd1, Crym, Spink8, Slc6a20a  #> PC_ 4  #> Positive:  Nr4a1, Arc, Lamp5, Egr1, Myl4, Trbc2, Chrna6, Tagln, En1, Snap25  #> \t   Th, Slc18a2, Acta2, Col1a2, Myh11, Fmod, Hba-a2, Slc10a4, Slc6a3, Slc13a4  #> \t   Ret, Tgm3, Hbb-bt, Slc6a20a, Ighm, Hbb-bs, Hba-a1, Vtn, Mgp, Drd2  #> Negative:  Spink8, Fibcd1, Tmsb4x, Nnat, Lefty1, Crym, Cpne7, Nos1, Dcn, Cpne6  #> \t   Grp, Homer3, Htr3a, Tac1, Fabp5, C1ql2, Trh, Opalin, Mog, Plp1  #> \t   Mag, Calb2, Ecel1, Gfap, Cnp, Tcf7l2, Lypd1, Vgll3, Hpcal1, Mal  #> PC_ 5  #> Positive:  En1, Chrna6, Th, Slc18a2, Slc10a4, Ddc, Lefty1, Arc, Slc6a3, Neurod6  #> \t   Grp, Nov, Lamp5, Fibcd1, Nr4a1, Drd2, Spink8, Vip, Myl4, Ret  #> \t   Egr1, Dlk1, Nrgn, Gfap, Trbc2, Tgm3, Myh7, Tac2, Sncg, Npy  #> Negative:  Pcp4, Tcf7l2, Snap25, Uchl1, Eef1a2, Chga, Stmn2, Lhx1os, Calb2, Scg2  #> \t   Fabp5, Bok, Prkcd, Pvalb, Cartpt, Chgb, Tnnt1, Gpx3, Slc20a1, Rtn1  #> \t   C1ql2, Spp1, Hpcal1, Ptgds, Pitx2, Lypd1, Aldh1a1, Ecel1, Vtn, Nme7  #> Computing nearest neighbor graph #> Computing SNN #> Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck #>  #> Number of nodes: 2560 #> Number of edges: 107827 #>  #> Running Louvain algorithm... #> Maximum modularity in 10 random starts: 0.8228 #> Number of communities: 12 #> Elapsed time: 0 seconds  # Run Neigborhood Enrichment Analysis res <- RunNeighborhoodEnrichmentTest(object = se,                                      column_name = \"seurat_clusters\",                                      n_permutations = 100,                                      nCores = 2) #>  #> ── Running Neighborhood Enrichment Analysis ── #>  #> ℹ Generating neighborhood adjacency data from observed labels in column 'seurat_clusters' #> ✔ Observed label adjacency calculations complete #> ℹ Generating neighborhood adjacency data from randomized labels #> ✔ Randomized label adjacency calculations complete from 100 iterations #> ✔ Scores calculated for each label pair and returned as output tibble  res |> arrange(desc(abs(z_score))) #> # A tibble: 132 × 7 #>    label_1 label_2 label_label     edges perm_mean perm_sd z_score #>    <fct>   <fct>   <chr>           <int>     <dbl>   <dbl>   <dbl> #>  1 Label_0 Label_1 Label_0-Label_1     1      403.    18.2   -22.0 #>  2 Label_1 Label_0 Label_1-Label_0     1      403.    18.2   -22.0 #>  3 Label_0 Label_4 Label_0-Label_4     4      292.    14.0   -20.6 #>  4 Label_4 Label_0 Label_4-Label_0     4      292.    14.0   -20.6 #>  5 Label_0 Label_2 Label_0-Label_2     2      367.    18.3   -20.0 #>  6 Label_2 Label_0 Label_2-Label_0     2      367.    18.3   -20.0 #>  7 Label_0 Label_3 Label_0-Label_3    13      344.    19.1   -17.4 #>  8 Label_3 Label_0 Label_3-Label_0    13      344.    19.1   -17.4 #>  9 Label_1 Label_3 Label_1-Label_3    41      294.    15.3   -16.5 #> 10 Label_3 Label_1 Label_3-Label_1    41      294.    15.3   -16.5 #> # … with 122 more rows"},{"path":"https://ludvigla.github.io/semla/reference/osddu-shiny.html","id":null,"dir":"Reference","previous_headings":"","what":"Shiny bindings for osddu — osddu-shiny","title":"Shiny bindings for osddu — osddu-shiny","text":"Output render functions using osddu within Shiny applications interactive Rmd documents.","code":""},{"path":"https://ludvigla.github.io/semla/reference/osddu-shiny.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shiny bindings for osddu — osddu-shiny","text":"","code":"osdduOutput(outputId, width = \"100%\", height = \"400px\")  renderOsddu(expr, env = parent.frame(), quoted = FALSE)"},{"path":"https://ludvigla.github.io/semla/reference/osddu-shiny.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shiny bindings for osddu — osddu-shiny","text":"outputId output variable read width, height Must valid CSS unit (like '100%', '400px', 'auto') number, coerced string 'px' appended. expr expression generates osddu env environment evaluate expr. quoted expr quoted expression (quote())? useful want save expression variable.","code":""},{"path":"https://ludvigla.github.io/semla/reference/osddu.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a react app for digital unrolling — osddu","title":"Create a react app for digital unrolling — osddu","text":"function used start interactive widget digital unrolling. requires static files server hosted order find load necessary files.","code":""},{"path":"https://ludvigla.github.io/semla/reference/osddu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a react app for digital unrolling — osddu","text":"","code":"osddu(   sampleID = 1,   host = \"127.0.0.1\",   port = \"8080\",   width = NULL,   height = NULL,   elementId = NULL,   quit = FALSE )"},{"path":"https://ludvigla.github.io/semla/reference/osddu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a react app for digital unrolling — osddu","text":"sampleID section ID host host address port valid port width, height Width height container elementId element id widget quit logical specifying app quit","code":""},{"path":"https://ludvigla.github.io/semla/reference/osddu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a react app for digital unrolling — osddu","text":"","code":"if (FALSE) { library(semla) library(magick)  se_mcolon <- readRDS(system.file(\"extdata/mousecolon\",                                   \"se_mcolon\",                                   package = \"semla\")) # Load images se_mcolon <- se_mcolon |>    LoadImages()  # fetch path for one H&E image im <- GetStaffli(se_mcolon)@imgs[1] |>    image_read()  # Tile image tilepath <- TileImage(im = im, outpath = \".\")  # Get spatial network spatnet <- GetSpatialNetwork(se_mcolon)[[1]]  # Export spatial network as JSON # Make sure that sampleID matches the ID of the H&E image export_graph(se_mcolon, sampleID = 1, outdir = tilepath$datapath)  # Host file server file_server(hostDir = tilepath$datapath)  # Run widget osddu(sampleID = 1,       host = \"127.0.0.1\",       port = 8080L,       width = '800px',       height = '800px',       quit = FALSE) }"},{"path":"https://ludvigla.github.io/semla/reference/paper-shiny.html","id":null,"dir":"Reference","previous_headings":"","what":"Shiny bindings for paper — paper-shiny","title":"Shiny bindings for paper — paper-shiny","text":"Output render functions using paper within Shiny applications interactive Rmd documents.","code":""},{"path":"https://ludvigla.github.io/semla/reference/paper-shiny.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shiny bindings for paper — paper-shiny","text":"","code":"paperOutput(outputId, width = \"100%\", height = \"400px\")  renderPaper(expr, env = parent.frame(), quoted = FALSE)"},{"path":"https://ludvigla.github.io/semla/reference/paper-shiny.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shiny bindings for paper — paper-shiny","text":"outputId output variable read width, height Must valid CSS unit (like '100%', '400px', 'auto') number, coerced string 'px' appended. expr expression generates paper env environment evaluate expr. quoted expr quoted expression (quote())? useful want save expression variable.","code":""},{"path":"https://ludvigla.github.io/semla/reference/paper.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a react app for paper JS in R — paper","title":"Create a react app for paper JS in R — paper","text":"Provided list images, function used open interactive app built react paper JS. application mean used shiny  application used RunAlignment function provided  semla.","code":""},{"path":"https://ludvigla.github.io/semla/reference/paper.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a react app for paper JS in R — paper","text":"","code":"paper(data, width = NULL, height = NULL, elementId = NULL)"},{"path":"https://ludvigla.github.io/semla/reference/paper.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a react app for paper JS in R — paper","text":"data list images prepared prep_image width Width component height height component elementId Component element ID","code":""},{"path":"https://ludvigla.github.io/semla/reference/paper.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a react app for paper JS in R — paper","text":"","code":"if (FALSE) { library(semla) library(magick)  im_mbrain <- system.file(\"extdata/mousebrain/spatial\",                          \"tissue_hires_image.jpg\",                          package = \"semla\")  img1 <- prep_image(im_mbrain |>                      image_read(),                    height = 512) img2 <- prep_image(im_mbrain |>                      image_read() |>                      image_flip(),                    height = 512)  paper(data = list(img1, img2), width = 600, height = 600) }"},{"path":"https://ludvigla.github.io/semla/reference/prep_image.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare images for paper JS react app — prep_image","title":"Prepare images for paper JS react app — prep_image","text":"Prepare images paper JS react app","code":""},{"path":"https://ludvigla.github.io/semla/reference/prep_image.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare images for paper JS react app — prep_image","text":"","code":"prep_image(input, height = 256)"},{"path":"https://ludvigla.github.io/semla/reference/prep_image.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare images for paper JS react app — prep_image","text":"input object class magick-image path image png jpeg format height Height image sent react app","code":""},{"path":"https://ludvigla.github.io/semla/reference/prep_image.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare images for paper JS react app — prep_image","text":"list array buffer, image dimensions length array buffer","code":""},{"path":"https://ludvigla.github.io/semla/reference/prep_image.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepare images for paper JS react app — prep_image","text":"","code":"library(semla) library(magick)  im <- system.file(\"extdata/mousebrain\", \"spatial/tissue_hires_image.jpg\", package = \"semla\")  # Prep image im_prepped <- prep_image(im)"},{"path":"https://ludvigla.github.io/semla/reference/radial-distance.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate radial distances from a region border — RadialDistance","title":"Calculate radial distances from a region border — RadialDistance","text":"Calculates radial distances spots borders selected defined region.","code":""},{"path":"https://ludvigla.github.io/semla/reference/radial-distance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate radial distances from a region border — RadialDistance","text":"","code":"RadialDistance(object, ...)  # S3 method for default RadialDistance(   object,   spots,   angles = NULL,   angles_nbreaks = NULL,   remove_singletons = TRUE,   convert_to_microns = FALSE,   verbose = TRUE,   ... )  # S3 method for Seurat RadialDistance(   object,   column_name,   selected_groups = NULL,   angles = NULL,   angles_nbreaks = NULL,   remove_singletons = TRUE,   convert_to_microns = FALSE,   verbose = TRUE,   ... )"},{"path":"https://ludvigla.github.io/semla/reference/radial-distance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate radial distances from a region border — RadialDistance","text":"object object ... Arguments passed methods spots character vector spot IDs present object. spots typically represent one particular tissue structure identified either data-driven clustering tissue histology. angles numeric vector length 2 specifying \"search interval\" angles compute radial distances . Values 0 360 accepted angles[1] < angles[2]. angles defined clockwise manner, right=0, =90, left=180 =270. angles calculated relative region center can therefore used single connected region present. multiple, spatially disconnected regions present, use DisconnectRegions split spatially disconnected regions first. angles_nbreaks integer specifying number intervals cut \"search interval\" . can useful want group radial distances different directions region center. remove_singletons Logical specifying 'singletons' excluded. Spatially disconnected regions allowed \"search interval\" defined, single spots without neighbors detected disconnected components. Single spots likely interfere calculating centroid region interest can therefore kept. convert_to_microns Logical specifying pixel distances converted microns.  requires dbscan R package installed. option sis set TRUE, method first attempt estimate center center distance adjacent spots  corresponds 100 microns Visium. center center distance used  convert radial distances. Note spots adjacent dataset data  type Visium used, distances correspond micrometers. verbose Print messages column_name character specifying name column meta data contains categorical data, e.g. clusters manual selections selected_groups character vector select specific groups column_name . groups selected default, common use case select region interest.","code":""},{"path":"https://ludvigla.github.io/semla/reference/radial-distance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate radial distances from a region border — RadialDistance","text":"object radial distances","code":""},{"path":"https://ludvigla.github.io/semla/reference/radial-distance.html","id":"scenario","dir":"Reference","previous_headings":"","what":"Scenario","title":"Calculate radial distances from a region border — RadialDistance","text":"region interest example isolated tumor tissue section surrounded stroma. interested expressional changes tumor core outwards, can use radial distances model changes. examples radial distances can used address certain question scenario: Identify genes vary inside tumor, e.g. tumor edge vs tumor core. Identify cell types located tumor edge Characterize surrounding tumor microenvironment just outside tumor edge Identify cell types whose abundances change distance tumor","code":""},{"path":"https://ludvigla.github.io/semla/reference/radial-distance.html","id":"algorithm","dir":"Reference","previous_headings":"","what":"Algorithm","title":"Calculate radial distances from a region border — RadialDistance","text":"First, border spots selected region identified based spatial network nearest neighbors identified GetSpatialNetwork. spot outside border, distance calculated nearest border spot. Spots located inside selected region negative distances spots located outside selected region positive distances.","code":""},{"path":"https://ludvigla.github.io/semla/reference/radial-distance.html","id":"search-interval","dir":"Reference","previous_headings":"","what":"Search interval","title":"Calculate radial distances from a region border — RadialDistance","text":"microenvironment region interest might extremely heterogeneous depending direction center. reason, can useful narrow search area defining smaller angle interval angles. Alternativley, can split radial distances even number slices angles_nbreaks. using predefined search interval, region interest (e.g. manual annotation) contain multiple spatially disconnected regions. Angles calculated center region interest makes sense investigate one region time. can use DisconnectRegions split categorical variable contains multiple spatially disconnected regions.","code":""},{"path":"https://ludvigla.github.io/semla/reference/radial-distance.html","id":"default-method","dir":"Reference","previous_headings":"","what":"default method","title":"Calculate radial distances from a region border — RadialDistance","text":"object tibble four columns: 'barcode' : character vector spot IDs 'x', 'y' : numeric vectors pixel coordinates 'sampleID' : numeric vector sample IDs angles /angles_nbreaks set, function return tibble spot IDS, sampleIDs, angle region center spots radial distances.  angles_nbreaks provided, fifth column provided groups spots even intervals based angles. Otherwise, default return numeric vector radial distances spots object.","code":""},{"path":"https://ludvigla.github.io/semla/reference/radial-distance.html","id":"seurat-method","dir":"Reference","previous_headings":"","what":"Seurat method","title":"Calculate radial distances from a region border — RadialDistance","text":"object Seurat object created semla, results returned meta.data slot.","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/reference/radial-distance.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate radial distances from a region border — RadialDistance","text":"Ludvig Larsson","code":""},{"path":"https://ludvigla.github.io/semla/reference/radial-distance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate radial distances from a region border — RadialDistance","text":"","code":"if (FALSE) { library(semla) library(ggplot2) library(patchwork) library(RColorBrewer)  # Get coordinates galt_spots_file <- \"~/semla/repo/semla/inst/extdata/mousecolon/galt_spots.csv\" galt_spots <- read.csv(galt_spots_file) |>   as_tibble()  # read coordinates coordfile <- system.file(\"extdata/mousecolon/spatial\",                          \"tissue_positions_list.csv\",                          package = \"semla\") coords <- read.csv(coordfile, header = FALSE) |>   filter(V2 == 1) |>   select(V1, V6, V5) |>   setNames(nm = c(\"barcode\", \"x\", \"y\")) |>   bind_cols(sampleID = 1) |>   as_tibble()  # Select spots spots <- galt_spots$barcode[galt_spots$selection == \"GALT\"] head(spots)  # Calculate radial distances radial_distances <- RadialDistance(coords, spots) gg <- bind_cols(coords, r_dist =  radial_distances) |>   left_join(y = galt_spots, by = \"barcode\")  # Convert to sqrt scale gg$r_dist_sqrt <- sign(gg$r_dist)*sqrt(abs(gg$r_dist))  # Make plot p1 <- ggplot(gg, aes(x, y, color = r_dist_sqrt)) +   geom_point() +   scale_y_reverse() +   scale_color_gradientn(colours = RColorBrewer::brewer.pal(n = 11, name = \"RdBu\")) p2 <- ggplot(gg, aes(x, y, color = selection)) +   geom_point() +   scale_y_reverse()  # Wrap plots wrap_plots(p2, p1, ncol = 2) &   coord_fixed() &   theme_void()  # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% # Calculate radial distances for fixed angle interval # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% # NB: This should only be run on a single region! In # this example, the disconnected regions have to be split first disconnected_regions <- DisconnectRegions(coords, spots) spots_keep <- names(disconnected_regions[disconnected_regions == \"S1_region1\"])  # Calculate radial distances between 200-300 degrees radial_distances <- RadialDistance(coords, spots_keep, angles = c(200, 300)) gg <- coords |>   select(-sampleID) |>   left_join(y = radial_distances, by = \"barcode\") gg$r_dist_sqrt <- sign(gg$r_dist)*sqrt(abs(gg$r_dist))  # Plot radial distances ggplot(gg, aes(x, y, color = r_dist_sqrt)) +   geom_point() +   scale_y_reverse() +   coord_fixed() +   theme_void() +   scale_color_gradientn(colours = viridis::magma(n = 9))  # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% # Calculate radial distances for multiple angle intervals # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% # NB: This should only be run on a single region! In # this example, the disconnected regions have to be split first disconnected_regions <- DisconnectRegions(coords, spots) spots_keep <- names(disconnected_regions[disconnected_regions == \"S1_region1\"])  # Calculate radial distances between 0-360 degrees and split # these into 8 slices radial_distances <- RadialDistance(coords, spots_keep,                                    angles = c(0, 360), angles_nbreaks = 8) gg <- coords |>   select(-sampleID) |>   left_join(y = radial_distances, by = \"barcode\") gg$r_dist_sqrt <- sign(gg$r_dist)*sqrt(abs(gg$r_dist))  # Color slices p1 <- ggplot(gg, aes(x, y, color = intervals)) +   geom_point() +   scale_y_reverse() +   coord_fixed() +   theme_void() +   scale_color_manual(values = RColorBrewer::brewer.pal(n = 8, name = \"Spectral\"))  # Plot distances p2 <- ggplot(gg, aes(intervals, r_dist)) +   geom_jitter()  # Now we can group our radial distances by slice p1 + p2 }   library(semla) library(ggplot2) library(patchwork) library(tidyr) library(RColorBrewer)  se_mcolon <- readRDS(system.file(\"extdata/mousecolon\", \"se_mcolon\", package = \"semla\")) se_mcolon <- RadialDistance(se_mcolon, column_name = \"selection\", selected_groups = \"GALT\") #> ℹ Running calculations for sample 1 #> ℹ Calculating radial distances for group 'GALT' #> ℹ Removing 23 spots with 0 neighbors. #> ℹ Extracting border spots from a region with 83 spots #> →   Detected 78 spots on borders #> →   Detected 83 spots inside borders #> →   Detected 2521 spots outside borders #> ✔ Returning radial distances  # Plot results p1 <- MapLabels(se_mcolon, column_name = \"selection\") p2 <- MapFeatures(se_mcolon, features = \"r_dist_GALT\", colors = c(\"lightgray\", \"black\")) p1 | p2   #  Plot expression as function of distance sel_genes <- c(\"Clu\", \"Tagln\") gg <- FetchData(se_mcolon, vars = c(sel_genes, \"r_dist_GALT\")) |>   pivot_longer(all_of(sel_genes), names_to = \"variable\", values_to = \"value\")  # Plot features p1 <- MapFeatures(se_mcolon, features = sel_genes)  # Plot expression as a function of distance p2 <- ggplot(gg, aes(r_dist_GALT, value, color = variable)) +   geom_smooth(method = \"loess\", span = 0.2, formula = y ~ x) +   geom_vline(xintercept = 0, linetype = \"dashed\") +   theme_minimal()  # Combine plots p1/p2   # It can also be useful to apply transformations to the distances se_mcolon$r_dist_GALT_sqrt <- sign(se_mcolon$r_dist_GALT)*sqrt(abs(se_mcolon$r_dist_GALT)) MapFeatures(se_mcolon, features = \"r_dist_GALT_sqrt\", pt_size = 2,             colors = RColorBrewer::brewer.pal(n = 11, name = \"RdBu\") |> rev())"},{"path":"https://ludvigla.github.io/semla/reference/region-neighbors.html","id":null,"dir":"Reference","previous_headings":"","what":"Find region neighbors — RegionNeighbors","title":"Find region neighbors — RegionNeighbors","text":"function allows automatically identify neighbors selected region.","code":""},{"path":"https://ludvigla.github.io/semla/reference/region-neighbors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find region neighbors — RegionNeighbors","text":"","code":"RegionNeighbors(object, ...)  # S3 method for default RegionNeighbors(   object,   spots,   mode = c(\"outer\", \"inner\", \"inner_outer\", \"all_inner_outer\"),   verbose = FALSE,   ... )  # S3 method for Seurat RegionNeighbors(   object,   column_name,   column_labels = NULL,   mode = c(\"outer\", \"inner\", \"inner_outer\", \"all_inner_outer\"),   column_key = NULL,   verbose = TRUE,   ... )"},{"path":"https://ludvigla.github.io/semla/reference/region-neighbors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find region neighbors — RegionNeighbors","text":"object object ... Arguments passed methods spots character vector spot IDs present `spatnet` mode Select mode (see details) verbose Print messages column_name string specifying column name meta data labels, e.g. clusters manual selections column_labels character vector labels find nearest neighbors . labels need present meta data columns specified column_name column_key prefix columns returned Seurat object","code":""},{"path":"https://ludvigla.github.io/semla/reference/region-neighbors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find region neighbors — RegionNeighbors","text":"object labeled region neighbors","code":""},{"path":"https://ludvigla.github.io/semla/reference/region-neighbors.html","id":"seurat","dir":"Reference","previous_headings":"","what":"Seurat","title":"Find region neighbors — RegionNeighbors","text":"Seurat object provided, RegionNeighbors takes meta data column (chosen column_name) categorical labels, finds nearest neighbors spots selected group columns (chosen column_labels) returns new meta data column labels nearest neighbors selected group. column_labels specified, method return column separate category column_name vector. Note prefix returned column names selected based mode. can overwrite behavior manually setting column_key. additional information behavior different modes: return outer border (default): mode=\"outer\" return inner border: mode=\"inner\" return inner outer borders: mode=\"inner_outer\" return selected spots outer border: mode=\"all_inner_outer\"","code":""},{"path":"https://ludvigla.github.io/semla/reference/region-neighbors.html","id":"default-method","dir":"Reference","previous_headings":"","what":"default method","title":"Find region neighbors — RegionNeighbors","text":"default method takes list spatial networks generated GetSpatialNetwork together vector spot IDs returns spot IDs border spots. behavior border spot selection determined mode.","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/reference/region-neighbors.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Find region neighbors — RegionNeighbors","text":"Ludvig Larsson","code":""},{"path":"https://ludvigla.github.io/semla/reference/region-neighbors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find region neighbors — RegionNeighbors","text":"","code":"library(semla) library(dplyr)  se_mbrain <-   readRDS(system.file(\"extdata\",   \"/mousebrain/se_mbrain\",   package = \"semla\"))  # Create Seurat object se_mbrain <- se_mbrain |>   ScaleData(verbose = FALSE) |>   RunPCA(verbose = FALSE) |>   FindNeighbors(verbose = FALSE) |>   FindClusters(verbose = FALSE)  # Find neighbors to cluster 10 se_mbrain <- RegionNeighbors(se_mbrain,                              column_name = \"seurat_clusters\",                              column_labels = \"10\") #> ℹ Finding neighboring spots for '10' #> →   Excluding neighbors from the same group #> →   74 neighbors left #> →   Returning neighbors  # Plot cluster 10 and its neighbors se_mbrain$selected_clusters <- se_mbrain[[]] |>   mutate(across(where(is.factor), as.character)) |>   mutate(cl = case_when(seurat_clusters %in% \"10\" ~ seurat_clusters,                         TRUE ~ NA_character_)) |>   pull(cl)  MapLabels(se_mbrain, column_name = \"selected_clusters\") |   MapLabels(se_mbrain, column_name = \"nb_to_10\")   # Find neighbors to clusters 8 and 10 se_mbrain$selected_clusters <- se_mbrain[[]] |>   mutate(across(where(is.factor), as.character)) |>   mutate(cl = case_when(seurat_clusters %in% c(\"8\", \"10\") ~ seurat_clusters,                         TRUE ~ NA_character_)) |>   pull(cl) se_mbrain <- RegionNeighbors(se_mbrain,                              column_name = \"seurat_clusters\",                              column_labels = c(\"8\", \"10\")) #> ℹ Finding neighboring spots for '8' #> →   Excluding neighbors from the same group #> →   112 neighbors left #> →   Returning neighbors #> ℹ Finding neighboring spots for '10' #> →   Excluding neighbors from the same group #> →   74 neighbors left #> →   Returning neighbors  # Plot cluster 8, 10 and its neighbors library(patchwork) MapLabels(se_mbrain, column_name = \"selected_clusters\") +   MapLabels(se_mbrain, column_name = \"nb_to_8\") +   MapLabels(se_mbrain, column_name = \"nb_to_10\") +   plot_layout(design = c(area(1, 1, 1, 1),                          area(1, 2, 1, 2),                          area(1, 3, 1, 3)))   # it is also possible to pass additional parameters to GetSpatialNetwork # to make it find more neighbors at a larger distances se_mbrain <- RegionNeighbors(se_mbrain,                              column_name = \"seurat_clusters\",                              column_labels = \"10\",                              nNeighbors = 40,                              maxDist = Inf) #> ℹ Finding neighboring spots for '10' #> →   Excluding neighbors from the same group #> →   860 neighbors left #> →   Returning neighbors MapLabels(se_mbrain, column_name = \"nb_to_10\")"},{"path":"https://ludvigla.github.io/semla/reference/scalebar.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a scale bar to use for plots — scalebar","title":"Create a scale bar to use for plots — scalebar","text":"Create scale bar use plots","code":""},{"path":"https://ludvigla.github.io/semla/reference/scalebar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a scale bar to use for plots — scalebar","text":"","code":"scalebar(   x = 500,   breaks = 6,   highlight_breaks = c(1, 6),   title_position = c(\"top\", \"bottom\"),   flip_bar = FALSE,   text_height = 2,   ... )"},{"path":"https://ludvigla.github.io/semla/reference/scalebar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a scale bar to use for plots — scalebar","text":"x Width scale bar microns. width higher 1,000 microns, units converted millimeters scale bar title. breaks Number breaks cut scale bar . example, 6 breaks create 6 vertical lines 5 even intervals. highlight_breaks Highlight specific breaks increasing height. title_position One \"top\" \"bottom\" title placement flip_bar scale bar flipped vertical orientation? text_height Height scale bar title ... Parameters passed geom_segment","code":""},{"path":"https://ludvigla.github.io/semla/reference/scalebar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a scale bar to use for plots — scalebar","text":"ggplot object scalebar","code":""},{"path":"https://ludvigla.github.io/semla/reference/scalebar.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a scale bar to use for plots — scalebar","text":"Ludvig Larsson","code":""},{"path":"https://ludvigla.github.io/semla/reference/scalebar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a scale bar to use for plots — scalebar","text":"","code":"# Draw a scale bar for a 500 micron distance with 6 breaks where # the ends are highlighted scalebar() #> Loading required namespace: ggfittext   # Draw a scale bar for a 1mm mm distance with 1 breaks where the # ends and the mid point are highlighted scalebar(breaks = 11, highlight_breaks = c(1, 6, 11))"},{"path":"https://ludvigla.github.io/semla/reference/semla-package.html","id":null,"dir":"Reference","previous_headings":"","what":"semla: Process, analyze and visualize Spatially Resolved Transcriptomics data — semla-package","title":"semla: Process, analyze and visualize Spatially Resolved Transcriptomics data — semla-package","text":"semla collects useful tools Spatially Resolved Transcriptomics data analysis visualization.","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/reference/semla-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"semla: Process, analyze and visualize Spatially Resolved Transcriptomics data — semla-package","text":"Maintainer: Ludvig Larsson ludvig.larsson@scilifelab.se (ORCID) Authors: Lovisa Franzen lovisa.franzen@scilifelab.se (ORCID) contributors: Spatial Research [funder]","code":""},{"path":"https://ludvigla.github.io/semla/reference/show.html","id":null,"dir":"Reference","previous_headings":"","what":"Show method for Staffli objects — show,Staffli-method","title":"Show method for Staffli objects — show,Staffli-method","text":"Show method Staffli objects","code":""},{"path":"https://ludvigla.github.io/semla/reference/show.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Show method for Staffli objects — show,Staffli-method","text":"","code":"# S4 method for Staffli show(object)"},{"path":"https://ludvigla.github.io/semla/reference/show.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Show method for Staffli objects — show,Staffli-method","text":"object object print pre-selected attributes ","code":""},{"path":"https://ludvigla.github.io/semla/reference/subset.html","id":null,"dir":"Reference","previous_headings":"","what":"Subset 10x Visium data — SubsetSTData","title":"Subset 10x Visium data — SubsetSTData","text":"Subset Seurat object making sure spatial data (images spot coordinates) handled correctly.","code":""},{"path":"https://ludvigla.github.io/semla/reference/subset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subset 10x Visium data — SubsetSTData","text":"","code":"SubsetSTData(object, expression, spots = NULL, features = NULL, idents = NULL)"},{"path":"https://ludvigla.github.io/semla/reference/subset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subset 10x Visium data — SubsetSTData","text":"object Seurat object expression Logical expression indicating features/variables keep spots vector spots keep features vector features keep idents vector identity classes keep","code":""},{"path":"https://ludvigla.github.io/semla/reference/subset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Subset 10x Visium data — SubsetSTData","text":"filtered Seurat object","code":""},{"path":"https://ludvigla.github.io/semla/reference/subset.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Subset 10x Visium data — SubsetSTData","text":"use default subset function likely able use semla visualization methods output object Staffli object broken. exception filtering done feature level.","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/reference/subset.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Subset 10x Visium data — SubsetSTData","text":"Ludvig Larsson","code":""},{"path":"https://ludvigla.github.io/semla/reference/subset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Subset 10x Visium data — SubsetSTData","text":"","code":"se_mbrain <- readRDS(system.file(\"extdata\", \"mousebrain/se_mbrain\", package = \"semla\"))  # Create Seurat object se_mbrain <- se_mbrain |> LoadImages() #>  #> ── Loading H&E images ── #>  #> ℹ Loading image from /private/var/folders/zb/1fj07x_5343fvs_k28gnm1z80002xs/T/RtmpFJGwBj/temp_libpath502354c29e9d/semla/extdata/mousebrain/spatial/tissue_hires_image.jpg #> ℹ Scaled image from 2000x1882 to 400x376 pixels #> ℹ Saving loaded H&E images as 'rasters' in Seurat object se_mbrain #> An object of class Seurat  #> 188 features across 2560 samples within 1 assay  #> Active assay: Spatial (188 features, 170 variable features)  # Subset by spot IDs (first 100) se_fewspots <- SubsetSTData(se_mbrain, spots = colnames(se_mbrain)[1:1000]) se_fewspots #> An object of class Seurat  #> 188 features across 1000 samples within 1 assay  #> Active assay: Spatial (188 features, 170 variable features)  # Subset by feature IDs (first 50) se_fewgenes <- SubsetSTData(se_mbrain, features = rownames(se_mbrain)[1:50]) se_fewgenes #> An object of class Seurat  #> 50 features across 2560 samples within 1 assay  #> Active assay: Spatial (50 features, 38 variable features)  # Subset using an expression se_filtered <- SubsetSTData(se_mbrain, expression = nFeature_Spatial > 20) se_filtered #> An object of class Seurat  #> 188 features across 2550 samples within 1 assay  #> Active assay: Spatial (188 features, 170 variable features)"},{"path":"https://ludvigla.github.io/semla/reference/transform-images.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply rigid transformations to images — RigidTransformImages","title":"Apply rigid transformations to images — RigidTransformImages","text":"Apply rigid transformations images","code":""},{"path":"https://ludvigla.github.io/semla/reference/transform-images.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply rigid transformations to images — RigidTransformImages","text":"","code":"RigidTransformImages(object, ...)  # S3 method for default RigidTransformImages(object, image, xy_coords, verbose = TRUE, ...)  # S3 method for Seurat RigidTransformImages(object, transforms, verbose = TRUE, ...)"},{"path":"https://ludvigla.github.io/semla/reference/transform-images.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply rigid transformations to images — RigidTransformImages","text":"object object ... Arguments passed methods image image class magick-image, raster, StoredSpatialImage path image PNG JPEG format xy_coords Spot coordinates can mapped image verbose Print messages transforms tibble containing information transformations apply images (see Seurat section)","code":""},{"path":"https://ludvigla.github.io/semla/reference/transform-images.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply rigid transformations to images — RigidTransformImages","text":"list two elements: \"im_transf\": object class magick-image representing transformed image \"xy_transf\": object class tbl representing transformed coordinates","code":""},{"path":"https://ludvigla.github.io/semla/reference/transform-images.html","id":"default-method","dir":"Reference","previous_headings":"","what":"default method","title":"Apply rigid transformations to images — RigidTransformImages","text":"Object tibble containing information image dimensions matched xy_coords. coordinates xy_coords match input image long image dimensions object matched. ensure coordinates can transformed correctly regardless dimensions image. example, coordinates provided spaceranger \"tissue_positions.csv\" can mapped original H&E image therefore original H&E image dimensions required correctly specify dimensions using coordinates plotting. , can map coordinates correctly H&E image regardless size. required columns : full_width, full_height: dimensions image xy_coords map sampleID: integer specifying sample ID mirror_x, mirror_y: TRUE/FALSE specifying image mirrored along      x- /y-axis angle: numeric specifying angle rotate image degrees tr_x, tr_y: numeric values specifying translations along x- /y-axis.      tr_x, tr_y values -1 1 0 means translation      1 equal image width height. Negative values shift image along axis      opposite direction. example, setting tr_x = 0.5 move image 50      right setting tr_x = -0.5 move image 50","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/reference/transform-images.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Apply rigid transformations to images — RigidTransformImages","text":"Ludvig Larsson","code":""},{"path":"https://ludvigla.github.io/semla/reference/transform-images.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply rigid transformations to images — RigidTransformImages","text":"","code":"library(semla) library(tibble) library(dplyr) library(magick) library(patchwork) library(ggplot2)  transforms <- generate_rigid_transform(mirror_x = TRUE, angle = 30, tr_x = 0.2, tr_y = -0.2)  # Combine image dimensions with transforms. # These are the dimensions of the H&E image used as input for # spaceranger count. transforms <- tibble(full_width = 18107, full_height = 19242) |>   bind_cols(transforms) transforms #> # A tibble: 1 × 9 #>   full_width full_height sampleID mirror_x mirror_y angle  tr_x  tr_y scalefac…¹ #>        <dbl>       <dbl>    <dbl> <lgl>    <lgl>    <dbl> <dbl> <dbl>      <dbl> #> 1      18107       19242        1 TRUE     FALSE       30   0.2  -0.2          1 #> # … with abbreviated variable name ¹​scalefactor # get example coordinate file coordinatefile <- system.file(\"extdata/mousebrain/spatial\",                               \"tissue_positions_list.csv\",                               package = \"semla\")  # Load coordinates # These coordinates are defined on the H&E image used as input for # spaceranger count. xy <- LoadSpatialCoordinates(coordinatefiles = coordinatefile) #> ℹ Loading coordinates: #> →   Finished loading coordinates for sample 1 #> ℹ Collected coordinates for 2560 spots. xy #> # A tibble: 2,560 × 7 #>    barcode            selected     y     x pxl_row_in_fullres pxl_col_…¹ sampl…² #>    <chr>                 <int> <int> <int>              <int>      <int>   <int> #>  1 CATACAAAGCCGAACC-1        1    13    35               4117       6086       1 #>  2 CTGAGCAAGTAACAAG-1        1    15    25               4472       5062       1 #>  3 GGGTACCCACGGTCCT-1        1    14    26               4294       5164       1 #>  4 ACGGAATTTAGCAAAT-1        1    15    27               4472       5266       1 #>  5 GGGCGGTCCTATTGTC-1        1    14    28               4294       5369       1 #>  6 ATGTTACGAGCAATAC-1        1    15    29               4472       5471       1 #>  7 AACCATGGGATCGCTA-1        1    14    30               4294       5574       1 #>  8 TCGCATCCCTAAGTGT-1        1    15    31               4473       5676       1 #>  9 ACTTAGTACGACAAGA-1        1    14    32               4295       5778       1 #> 10 GAGCTCTCGGACCTAA-1        1    15    33               4473       5881       1 #> # … with 2,550 more rows, and abbreviated variable names ¹​pxl_col_in_fullres, #> #   ²​sampleID  # Load image lowresimagefile <- system.file(\"extdata/mousebrain/spatial\",                                \"tissue_lowres_image.jpg\",                                package = \"semla\") im <- image_read(lowresimagefile)  # Transform image and coordinates transf_res <- RigidTransformImages(transforms, image = im, xy_coords = xy) #> ℹ Fetched spot coordinates #> ℹ Supplied transformations are valid #> →   Mirror along x-axis: TRUE #> →   Mirror along y-axis: FALSE #> →   Rotation angle: 30 #> →   Translation along x axis: 20% #> →   Translation along y axis: -20% #> →   Scaling factor: 1 #> ✔ Returning transformed image  ggplot(transf_res$xy_transf, aes(tr_x, tr_y)) +   geom_point(color = \"red\", alpha = 0.5) +   geom_segment(aes(x = 0, y = 0.5*19242, xend = 0.2*18107, yend = 0.5*19242),                arrow = arrow(length = unit(0.5, \"cm\"))) +   geom_vline(xintercept = 0.2*18107, linetype = \"dashed\") +   geom_segment(aes(x = 0.5*18107, y = 19242, xend = 0.5*18107, yend = 0.8*19242),                arrow = arrow(length = unit(0.5, \"cm\"))) +   geom_hline(yintercept = 0.8*19242, linetype = \"dashed\") +   scale_x_continuous(limits = c(0, 18107), expand = c(0, 0)) +   scale_y_reverse(limits = c(19242, 0), expand = c(0, 0)) +   labs(x = expression(\"x\"[\"transformed\"]),        y = expression(\"y\"[\"transformed\"]),        title = \"20% right, 20% up, 30 deg rotation\") +   theme_void() +   theme(axis.text = element_text(),         axis.title.x = element_text(),         axis.title.y = element_text(angle = 90)) +   coord_fixed() +   # Insert H&E image   inset_element(p = as.raster(transf_res$im_transf),                 left = 0, bottom = 0,                 right = 1, top = 1,                 on_top = FALSE) #> Warning: Removed 27 rows containing missing values (`geom_point()`).   library(semla) library(dplyr)  se_mbrain <- readRDS(system.file(\"extdata/mousebrain\", \"se_mbrain\", package = \"semla\")) se_mcolon <- readRDS(system.file(\"extdata/mousecolon\", \"se_mcolon\", package = \"semla\")) se_merged <- MergeSTData(se_mbrain, se_mcolon) |>   LoadImages() #>  #> ── Loading H&E images ── #>  #> ℹ Loading image from /private/var/folders/zb/1fj07x_5343fvs_k28gnm1z80002xs/T/RtmpFJGwBj/temp_libpath502354c29e9d/semla/extdata/mousebrain/spatial/tissue_hires_image.jpg #> ℹ Scaled image from 2000x1882 to 400x376 pixels #> ℹ Loading image from /private/var/folders/zb/1fj07x_5343fvs_k28gnm1z80002xs/T/RtmpFJGwBj/temp_libpath502354c29e9d/semla/extdata/mousecolon/spatial/tissue_hires_image.jpg #> ℹ Scaled image from 1804x2000 to 400x443 pixels #> ℹ Saving loaded H&E images as 'rasters' in Seurat object  # Define rigid transformations for section 2 transforms <- generate_rigid_transform(sampleID = 2, angle = 30, mirror_x = TRUE)  # Apply transformations se_merged <- RigidTransformImages(se_merged, transforms = transforms) #>  #> ── Transforming images ── #>  #> ℹ Found transformations for sample(s): 2 #> ℹ Transforming image 2 #> ℹ Fetched spot coordinates #> ℹ Supplied transformations are valid #> →   Mirror along x-axis: TRUE #> →   Mirror along y-axis: FALSE #> →   Rotation angle: 30 #> →   Translation along x axis: 0% #> →   Translation along y axis: 0% #> →   Scaling factor: 1 #> ✔ Returning transformed image #> ℹ Image transformation complete.  # Plot transformed image MapFeatures(se_merged, features = \"Th\", image_use = \"transformed\")   # Define rigid tranformations for all sections transforms <- bind_rows(generate_rigid_transform(sampleID = 1, angle = 30, mirror_x = TRUE),                         generate_rigid_transform(sampleID = 2, angle = 60)) # Apply transformations se_merged <- RigidTransformImages(se_merged, transforms = transforms) #>  #> ── Transforming images ── #>  #> ℹ Found transformations for sample(s): 1, 2 #> ℹ Transforming image 1 #> ℹ Fetched spot coordinates #> ℹ Supplied transformations are valid #> →   Mirror along x-axis: TRUE #> →   Mirror along y-axis: FALSE #> →   Rotation angle: 30 #> →   Translation along x axis: 0% #> →   Translation along y axis: 0% #> →   Scaling factor: 1 #> ✔ Returning transformed image #> ℹ Transforming image 2 #> ℹ Fetched spot coordinates #> ℹ Supplied transformations are valid #> →   Mirror along x-axis: FALSE #> →   Mirror along y-axis: FALSE #> →   Rotation angle: 60 #> →   Translation along x axis: 0% #> →   Translation along y axis: 0% #> →   Scaling factor: 1 #> ✔ Returning transformed image #> ℹ Image transformation complete.  # Plot transformed image MapFeatures(se_merged, features = \"Th\", image_use = \"transformed\")"},{"path":"https://ludvigla.github.io/semla/reference/visualize-features.html","id":null,"dir":"Reference","previous_headings":"","what":"Map numeric features — MapFeatures","title":"Map numeric features — MapFeatures","text":"MapFeatures can used map numeric features spots values encoded colors. multiple features samples provided, plotted individually arranged grid subplots.","code":""},{"path":"https://ludvigla.github.io/semla/reference/visualize-features.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map numeric features — MapFeatures","text":"","code":"MapFeatures(object, ...)  # S3 method for default MapFeatures(   object,   crop_area = NULL,   pt_size = 1,   pt_alpha = 1,   pt_stroke = 0,   scale_alpha = FALSE,   section_number = NULL,   label_by = NULL,   ncol = NULL,   colors = RColorBrewer::brewer.pal(n = 9, name = \"Reds\"),   center_zero = FALSE,   scale = c(\"shared\", \"free\"),   arrange_features = c(\"col\", \"row\"),   dims = NULL,   coords_columns = c(\"pxl_col_in_fullres\", \"pxl_row_in_fullres\"),   return_plot_list = FALSE,   drop_na = FALSE,   blend = FALSE,   blend_order = 1:3,   add_scalebar = FALSE,   scalebar_gg = NULL,   scalebar_height = 0.05,   scalebar_position = c(0.8, 0.8),   ... )  # S3 method for Seurat MapFeatures(   object,   features,   slot = \"data\",   image_use = NULL,   coords_use = \"raw\",   crop_area = NULL,   pt_size = 1,   pt_alpha = 1,   pt_stroke = 0,   scale_alpha = FALSE,   section_number = NULL,   label_by = NULL,   ncol = NULL,   colors = RColorBrewer::brewer.pal(n = 9, name = \"Reds\"),   center_zero = FALSE,   scale = c(\"shared\", \"free\"),   arrange_features = c(\"col\", \"row\"),   drop_na = FALSE,   blend = FALSE,   blend_order = 1:3,   override_plot_dims = FALSE,   max_cutoff = NULL,   min_cutoff = NULL,   return_plot_list = FALSE,   add_scalebar = FALSE,   scalebar_height = 0.05,   scalebar_gg = scalebar(x = 500, text_height = 5),   scalebar_position = c(0.8, 0.7),   ... )"},{"path":"https://ludvigla.github.io/semla/reference/visualize-features.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Map numeric features — MapFeatures","text":"object object ... Arguments passed methods crop_area numeric vector length 4 specifying rectangular area crop plots . numbers within 0-1. x-axis goes left=0 right=1 y axis goes top=0 bottom=1. order values specified follows: crop_area = c(left, top, right, bottom). crop area used tissue sections set section individually. using crop areas different sizes different sections can lead unwanted side effects point sizes remain constant. case better generate separate plots different tissue sections. pt_size numeric value specifying point size passed geom_point pt_alpha numeric value 0 1 specifying point opacity passed geom_point. value 0 make points completely transparent value 1 make points completely opaque. pt_stroke numeric specifying point stroke width scale_alpha Logical specifying spot colors scaled together feature values. can useful want highlight regions higher feature values making background tissue visible. section_number integer select tissue section number subset data label_by Character length 1 providing column name object labels can used provide title subplot. column 1 label per tissue section. can useful need provide detailed information tissue sections. ncol Integer value specifying number columns output patchwork. parameter effect number features provided 1. Otherwise, patchwork arranged based arrange_features parameter. colors character vector colors use color scale. colors preferably consist set colors scientific color palette designed sequential data. useful palettes available RColorBrewer, viridis scico R packages. center_zero logical specifying whether color scale centered 0 scale character vector length 1 specifying one \"shared\" \"free\" determine color bars structured. scale set \"shared\", color bars feature values shared across samples. scale set \"free\", color bars independent. arrange_features One \"row\" \"col\". \"col\" put features columns samples rows \"row\" transpose arrangement dims tibble information tissue sections. information used determine limits plot area. dims provided, limits computed directly spatial coordinates provided object. coords_columns character vector length 2 specifying names columns object holding spatial coordinates return_plot_list logical specifying `patchwork` list `ggplot` objects returned. default, `patchwork` returned, can sometimes useful obtain list `ggplot` objects want manipulate sub plot independently. drop_na logical specifying NA values dropped blend logical specifying whether blending used. See section color  blending information. blend_order integer vector length 2-3 specifying order blend features . active blend = TRUE. See color blending information. add_scalebar logical specifying scale bar added plots scalebar_gg 'ggplot' object generated scalebar. appearance scale bar styled passing parameters scalebar. scalebar_height numeric value specifying height scale bar relative height full plot area. value 0 1. title scale bar scaled plot might disappear -scaled text size small. Increasing height scale bar can sometimes useful increase text size make visible small plots. scalebar_position numeric vector length 2 specifying position scale bar relative plot area. Default place top right corner. features character vector features plot. features need fetchable link{FetchData} slot Slot pull features values image_use character specifying image type use coords_use character specifying coordinate type use override_plot_dims logical specifying whether image dimensions used define plot area. Setting override_plot_dims can useful situations tissue section covers small fraction capture area, create lot white space plots. min_cutoff, max_cutoff numeric value 0-1 specifying either lower (min_cutoff) upper (max_cutoff) limit data using quantile. arguments can useful make sure color map get dominated outliers.","code":""},{"path":"https://ludvigla.github.io/semla/reference/visualize-features.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Map numeric features — MapFeatures","text":"patchwork object","code":""},{"path":"https://ludvigla.github.io/semla/reference/visualize-features.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Map numeric features — MapFeatures","text":"Note can plot numeric features MapFeatures, example: gene expression, QC metrics dimensionality reduction vectors. want plot categorical features, use MapLabels instead.","code":""},{"path":"https://ludvigla.github.io/semla/reference/visualize-features.html","id":"color-blending","dir":"Reference","previous_headings":"","what":"color blending","title":"Map numeric features — MapFeatures","text":"Color blending can used 2 three features. blending activated, feature values rescaled encoded RGB colors. RGB allows three channels included, hence reason can use 2-3 features. blending feature values get 1 plot per tissue section. Colors can mixed produce new colors; example, two features similar values one spot encoded blue red, mixed color purple. blend_order allows flip order features feature provided color choice. default, order 1, 2, 3 means first feature \"red\", second \"green\" last feature \"blue\".","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/reference/visualize-features.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Map numeric features — MapFeatures","text":"Ludvig Larsson","code":""},{"path":"https://ludvigla.github.io/semla/reference/visualize-features.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Map numeric features — MapFeatures","text":"","code":"library(semla) if (!requireNamespace(\"viridis\"))   install.packages(\"viridis\") library(viridis) library(ggplot2)  # Load example Visium data se_mbrain <- readRDS(system.file(\"extdata/mousebrain\", \"se_mbrain\", package = \"semla\")) se_mcolon <- readRDS(system.file(\"extdata/mousecolon\", \"se_mcolon\", package = \"semla\")) se_merged <- MergeSTData(se_mbrain, se_mcolon)  if (FALSE) {  # Select features selected_features <- c(\"Clu\", \"Slc6a3\", \"Vip\")  # Plot selected features with custom colors MapFeatures(se_merged, features = selected_features, colors = magma(n = 11, direction = -1))  # Plot selected features with color bars scaled individually for each feature and sample MapFeatures(se_merged, features = selected_features, scale = \"free\")  # Plot selected features and add custom labels for subplots se_merged$sample_id <- ifelse(GetStaffli(se_merged)@meta_data$sampleID == \"1\",                               \"mouse brain\",                               \"mouse colon\") MapFeatures(se_merged, features = selected_features, label_by = \"sample_id\")  # Plot selected features arranged by rows instead of columns MapFeatures(se_merged, features = selected_features, arrange_features = \"row\")  # Blend features MapFeatures(se_merged, features = selected_features, blend = TRUE)  }  # The output is a patchwork object which is easy to manipulate selected_feature <- \"Th\"  # Move legend to right side of plot MapFeatures(se_mbrain, features = selected_feature, pt_size = 2) &   theme(legend.position = \"right\",         legend.text = element_text(angle = 0, hjust = 0))   # Remove titles MapFeatures(se_mbrain, features = selected_feature, pt_size = 2) &   theme(plot.title = element_blank(),         plot.subtitle = element_blank())   # Create a dark theme MapFeatures(se_mbrain, features = selected_feature, pt_size = 2,             colors = viridis(n = 11)) &   theme(plot.background = element_rect(fill = \"black\"),         panel.background = element_rect(fill = \"black\"),         plot.title = element_text(colour = \"white\"),         plot.subtitle = element_text(colour = \"white\"),         legend.text = element_text(colour = \"white\"),         legend.title = element_text(colour = \"white\"))   # Add a background and axes to the plot MapFeatures(se_mbrain, features = selected_feature, pt_size = 2) &   theme(panel.background = element_rect(fill = \"lightgray\"),         axis.text = element_text())   # Move legend MapFeatures(se_mbrain, features = selected_feature, pt_size = 2) &   theme(panel.background = element_rect(fill = \"lightgray\"),         legend.justification = 1)   # Change title of fill aesthetic MapFeatures(se_mbrain, features = selected_feature, pt_size = 2) &   labs(title = \"Gene expression\")"},{"path":"https://ludvigla.github.io/semla/reference/visualize-labels.html","id":null,"dir":"Reference","previous_headings":"","what":"Map categorical features — MapLabels","title":"Map categorical features — MapLabels","text":"MapLabels colors spots based values categorical feature.","code":""},{"path":"https://ludvigla.github.io/semla/reference/visualize-labels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map categorical features — MapLabels","text":"","code":"MapLabels(object, ...)  # S3 method for default MapLabels(   object,   crop_area = NULL,   pt_size = 1,   pt_alpha = 1,   pt_stroke = 0,   section_number = NULL,   label_by = NULL,   split_labels = FALSE,   ncol = NULL,   colors = NULL,   dims = NULL,   coords_columns = c(\"pxl_col_in_fullres\", \"pxl_row_in_fullres\"),   return_plot_list = FALSE,   drop_na = FALSE,   add_scalebar = FALSE,   scalebar_gg = NULL,   scalebar_height = 0.05,   scalebar_position = c(0.8, 0.8),   ... )  # S3 method for Seurat MapLabels(   object,   column_name,   image_use = NULL,   coords_use = \"raw\",   crop_area = NULL,   pt_size = 1,   pt_alpha = 1,   pt_stroke = 0,   section_number = NULL,   label_by = NULL,   split_labels = FALSE,   ncol = NULL,   colors = NULL,   override_plot_dims = FALSE,   return_plot_list = FALSE,   drop_na = FALSE,   add_scalebar = FALSE,   scalebar_height = 0.05,   scalebar_gg = scalebar(x = 500, text_height = 5),   scalebar_position = c(0.8, 0.7),   ... )"},{"path":"https://ludvigla.github.io/semla/reference/visualize-labels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Map categorical features — MapLabels","text":"object object ... Arguments passed methods crop_area numeric vector length 4 specifying rectangular area crop plots . numbers within 0-1. x-axis goes left=0 right=1 y axis goes top=0 bottom=1. order values specified follows: crop_area = c(left, top, right, bottom). crop area used tissue sections set section individually. using crop areas different sizes different sections can lead unwanted side effects point sizes remain constant. case better generate separate plots different tissue sections. pt_size numeric value specifying point size passed geom_point pt_alpha numeric value 0 1 specifying point opacity passed geom_point. value 0 make points completely transparent value 1 make points completely opaque. pt_stroke numeric specifying point stroke width section_number integer select tissue section number subset data label_by character specifying column name object labels can used provide title subplot. column 1 label per tissue section. can useful need provide detailed information tissue sections. split_labels logical specifying labels split. ncol integer value specifying number columns output patchwork. colors character vector colors use color scale. number colors match number labels present. dims tibble information tissue sections. information used determine limits plot area. dims provided, limits computed directly spatial coordinates provided object. coords_columns character vector length 2 specifying names columns object holding spatial coordinates return_plot_list logical specifying whether plots return list `ggplot` objects. return_plot_list = FALSE (default), plots arranged `patchwork` drop_na logical specifying NA values dropped add_scalebar logical specifying scale bar added plots scalebar_gg 'ggplot' object generated scalebar. appearance scale bar styled passing parameters scalebar. scalebar_height numeric value specifying height scale bar relative height full plot area. value 0 1. title scale bar scaled plot might disappear -scaled text size small. Increasing height scale bar can sometimes useful increase text size make visible small plots. scalebar_position numeric vector length 2 specifying position scale bar relative plot area. Default place top right corner. column_name character specifying meta data column holding categorical feature vector. image_use character specifying image type use. coords_use character specifying coordinate type use. override_plot_dims logical specifying whether image dimensions used define plot area. Setting override_plot_dims can useful situations tissue section covers small fraction capture area, create lot white space plots. effect can achieved crop_area crop area instead determined directly data.","code":""},{"path":"https://ludvigla.github.io/semla/reference/visualize-labels.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Map categorical features — MapLabels","text":"`patchwork` object list `ggplot` objects","code":""},{"path":"https://ludvigla.github.io/semla/reference/visualize-labels.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Map categorical features — MapLabels","text":"can plot categorical features MapLabels, example: spot annotations clusters. want plot numerical features, use MapFeatures instead. 1 categorical feature can provided.","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/reference/visualize-labels.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Map categorical features — MapLabels","text":"Ludvig Larsson","code":""},{"path":"https://ludvigla.github.io/semla/reference/visualize-labels.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Map categorical features — MapLabels","text":"","code":"library(semla) library(ggplot2)  # Load Seurat object se_mbrain <- readRDS(system.file(\"extdata/mousebrain\", \"se_mbrain\", package = \"semla\"))  # Run PCA and data-driven clustering se_mbrain <- se_mbrain |>   ScaleData() |>   RunPCA() |>   FindNeighbors(reduction = \"pca\", dims = 1:10) |>   FindClusters(resolution = 0.2) |>   FindClusters(resolution = 0.3) #> Centering and scaling data matrix #> PC_ 1  #> Positive:  Nrgn, Olfm1, Cck, Nptxr, Rtn1, Snca, Nov, Tmsb4x, Lamp5, Egr1  #> \t   Crym, Cpne6, Coro1a, Arc, Hpca, Sst, Nr4a1, Npy, Chgb, Neurod6  #> \t   Snap25, Myh7, Uchl1, Eef1a2, Cort, Grp, Stmn2, Rprm, Spink8, Mfge8  #> Negative:  Mbp, Plp1, Apod, Mobp, Ptgds, Mog, Mal, Mag, Cnp, Aldh1a1  #> \t   Opalin, Tcf7l2, Ddc, Lhx1os, Slc6a3, Ret, Th, Slc18a2, Sncg, Drd2  #> \t   Chrna6, Slc10a4, Spp1, En1, Dlk1, Calb2, Hbb-bs, Pvalb, Col1a2, Tnnt1  #> PC_ 2  #> Positive:  Myoc, Gfap, Col1a2, Fmod, Slc13a4, Hba-a1, Hbb-bt, Slc6a20a, Hba-a2, Hbb-bs  #> \t   Acta2, Tagln, Mgp, Ogn, Vtn, H2-Aa, Lyz2, Cd74, Myl9, Dcn  #> \t   Myh11, Ptgds, Cytl1, H2-Eb1, Hmgcs2, Clu, Mfge8, Emp1, Npy, Cnn1  #> Negative:  Th, Uchl1, Slc18a2, En1, Slc10a4, Slc6a3, Chrna6, Stmn2, Ret, Snap25  #> \t   Drd2, Dlk1, Ddc, Scg2, Sncg, Eef1a2, Rtn1, Chga, Pcp4, Calb2  #> \t   Mobp, Mbp, Chgb, Fabp5, Plp1, Pvalb, Mog, Mal, Mag, Snca  #> PC_ 3  #> Positive:  Trbc2, Arc, Egr1, Myl4, Nr4a1, Mbp, Mobp, Pvalb, Plp1, Opalin  #> \t   Mog, Mal, Cnp, Mag, Snap25, Lamp5, Ighm, Tcf7l2, Cplx3, Tgm3  #> \t   Ighg2c, Pcp4, Hpca, Ly6d, Eef1a2, Tnnt1, Chga, Neurod6, Prph, Ctgf  #> Negative:  Nnat, Slc18a2, Dlk1, Slc6a3, Slc10a4, En1, Th, Chrna6, Dcn, Sncg  #> \t   Cpne7, Drd2, Ddc, Ret, Hpcal1, Ecel1, Cpne6, Col1a2, Trh, Calb2  #> \t   Cd24a, Fmod, Mgp, Snca, Lypd1, Slc13a4, Fibcd1, Crym, Spink8, Slc6a20a  #> PC_ 4  #> Positive:  Nr4a1, Arc, Lamp5, Egr1, Myl4, Trbc2, Chrna6, Tagln, En1, Snap25  #> \t   Th, Slc18a2, Acta2, Col1a2, Myh11, Fmod, Hba-a2, Slc10a4, Slc6a3, Slc13a4  #> \t   Ret, Tgm3, Hbb-bt, Slc6a20a, Ighm, Hbb-bs, Hba-a1, Vtn, Mgp, Drd2  #> Negative:  Spink8, Fibcd1, Tmsb4x, Nnat, Lefty1, Crym, Cpne7, Nos1, Dcn, Cpne6  #> \t   Grp, Homer3, Htr3a, Tac1, Fabp5, C1ql2, Trh, Opalin, Mog, Plp1  #> \t   Mag, Calb2, Ecel1, Gfap, Cnp, Tcf7l2, Lypd1, Vgll3, Hpcal1, Mal  #> PC_ 5  #> Positive:  En1, Chrna6, Th, Slc18a2, Slc10a4, Ddc, Lefty1, Arc, Slc6a3, Neurod6  #> \t   Grp, Nov, Lamp5, Fibcd1, Nr4a1, Drd2, Spink8, Vip, Myl4, Ret  #> \t   Egr1, Dlk1, Nrgn, Gfap, Trbc2, Tgm3, Myh7, Tac2, Sncg, Npy  #> Negative:  Pcp4, Tcf7l2, Snap25, Uchl1, Eef1a2, Chga, Stmn2, Lhx1os, Calb2, Scg2  #> \t   Fabp5, Bok, Prkcd, Pvalb, Cartpt, Chgb, Tnnt1, Gpx3, Slc20a1, Rtn1  #> \t   C1ql2, Spp1, Hpcal1, Ptgds, Pitx2, Lypd1, Aldh1a1, Ecel1, Vtn, Nme7  #> Computing nearest neighbor graph #> Computing SNN #> Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck #>  #> Number of nodes: 2560 #> Number of edges: 85218 #>  #> Running Louvain algorithm... #> Maximum modularity in 10 random starts: 0.9096 #> Number of communities: 6 #> Elapsed time: 0 seconds #> Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck #>  #> Number of nodes: 2560 #> Number of edges: 85218 #>  #> Running Louvain algorithm... #> Maximum modularity in 10 random starts: 0.8881 #> Number of communities: 8 #> Elapsed time: 0 seconds  # Plot clusters MapLabels(se_mbrain, column_name = \"Spatial_snn_res.0.2\", pt_size = 2)   # Plot clusters in split view MapLabels(se_mbrain, column_name = \"Spatial_snn_res.0.2\", pt_size = 0.5,           section_number = 1, split_labels = TRUE, ncol = 4)   # Combine plots with different labels MapLabels(se_mbrain, column_name = \"Spatial_snn_res.0.2\") |   MapLabels(se_mbrain, column_name = \"Spatial_snn_res.0.3\")   # Move legend to the right side of the plot MapLabels(se_mbrain, column_name = \"Spatial_snn_res.0.2\", pt_size = 2) &   theme(legend.position = \"right\")   # Override fill aesthetic to increase point sixe in legend MapLabels(se_mbrain, column_name = \"Spatial_snn_res.0.2\", pt_size = 2) &   guides(fill = guide_legend(override.aes = list(size = 4)))   # Use custom colors cols <- c(\"#332288\", \"#88CCEE\", \"#117733\", \"#DDCC77\", \"#CC6677\",\"#AA4499\") MapLabels(se_mbrain, column_name = \"Spatial_snn_res.0.2\", pt_size = 2, colors = cols)   # Factor are to used to determine the color order. If you change the # levels of your label of interest, the labels and colors will change order se_mbrain$Spatial_snn_res.0.2 <- factor(se_mbrain$Spatial_snn_res.0.2,                                         levels = sample(paste0(0:7), size = 8)) MapLabels(se_mbrain, column_name = \"Spatial_snn_res.0.2\", pt_size = 2, colors = cols)   # Control what group label colors by naming the color vector # this way you can make sure that each group gets a desired color # regardless of the factor levels cols <- setNames(cols, nm = paste0(0:5)) cols #>         0         1         2         3         4         5  #> \"#332288\" \"#88CCEE\" \"#117733\" \"#DDCC77\" \"#CC6677\" \"#AA4499\"  MapLabels(se_mbrain, column_name = \"Spatial_snn_res.0.2\", pt_size = 2, colors = cols)"},{"path":"https://ludvigla.github.io/semla/reference/visualize-multiple-features.html","id":null,"dir":"Reference","previous_headings":"","what":"Map numeric features or categorical labels — MapMultipleFeatures","title":"Map numeric features or categorical labels — MapMultipleFeatures","text":"MapMultipleFeatures can used map multiple numeric feature tissue section(s). MapFeatures provides option map 2 3 features using RGB color blending, whereas MapMultipleFeatures can handle 3 features. See details information.","code":""},{"path":"https://ludvigla.github.io/semla/reference/visualize-multiple-features.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map numeric features or categorical labels — MapMultipleFeatures","text":"","code":"MapMultipleFeatures(object, ...)  # S3 method for default MapMultipleFeatures(   object,   scale = c(\"shared\", \"free\"),   crop_area = NULL,   pt_size = 1,   pt_stroke = 0,   section_number = NULL,   label_by = NULL,   ncol = NULL,   colors = NULL,   dims = NULL,   coords_columns = c(\"pxl_col_in_fullres\", \"pxl_row_in_fullres\"),   return_plot_list = FALSE,   drop_na = FALSE,   add_colorscale_text = FALSE,   ... )  # S3 method for Seurat MapMultipleFeatures(   object,   features,   scale = c(\"free\", \"shared\"),   slot = \"data\",   image_use = NULL,   coords_use = \"raw\",   crop_area = NULL,   pt_size = 1,   pt_stroke = 0,   section_number = NULL,   label_by = NULL,   ncol = NULL,   colors = NULL,   override_plot_dims = FALSE,   max_cutoff = NULL,   min_cutoff = NULL,   return_plot_list = FALSE,   add_colorscale_text = FALSE,   ... )"},{"path":"https://ludvigla.github.io/semla/reference/visualize-multiple-features.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Map numeric features or categorical labels — MapMultipleFeatures","text":"object object ... Arguments passed methods scale string specifying scaling mode. See details crop_area numeric vector length 4 specifying rectangular area crop plots . numbers within 0-1. x-axis goes left=0 right=1 y axis goes top=0 bottom=1. order values specified follows: crop_area = c(left, top, right, bottom). crop area used tissue sections set section individually. using crop areas different sizes different sections can lead unwanted side effects point sizes remain constant. case better generate separate plots different tissue sections. pt_size numeric value specifying point size passed geom_point pt_stroke numeric specifying point stroke width section_number integer select tissue section number subset data label_by Character length 1 providing column name object labels can used provide title subplot. column 1 label per tissue section. can useful need provide detailed information tissue sections. ncol Integer value specifying number columns output patchwork. parameter effect number features provided 1. Otherwise, patchwork arranged based arrange_features parameter. colors character vector colors use color scale. colors preferably consist set colors scientific color palette designed sequential data. useful palettes available RColorBrewer, viridis scico R packages. dims tibble information tissue sections. information used determine limits plot area. dims provided, limits computed directly spatial coordinates provided object. coords_columns character vector length 2 specifying names columns object holding spatial coordinates return_plot_list logical specifying `patchwork` list `ggplot` objects returned. default, `patchwork` returned, can sometimes useful obtain list `ggplot` objects want manipulate sub plot independently. drop_na logical specifying NA values dropped add_colorscale_text Logical specifying labels added color scales. labels values 0 1 (\"low\" \"high\") meaning values depend choice scale features character vector features plot. features need fetchable link{FetchData} slot Slot pull features values image_use character specifying image type use coords_use character specifying coordinate type use override_plot_dims logical specifying whether image dimensions used define plot area. Setting override_plot_dims can useful situations tissue section covers small fraction capture area, create lot white space plots. min_cutoff, max_cutoff numeric value 0-1 specifying either lower (min_cutoff) upper (max_cutoff) limit data using quantile. arguments can useful make sure color map get dominated outliers.","code":""},{"path":"https://ludvigla.github.io/semla/reference/visualize-multiple-features.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Map numeric features or categorical labels — MapMultipleFeatures","text":"patchwork object","code":""},{"path":"https://ludvigla.github.io/semla/reference/visualize-multiple-features.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Map numeric features or categorical labels — MapMultipleFeatures","text":"RGB color blending possible 2 3 features. visualize 3 colors plot, can instead assign specific color spot depending feature highest value. means \"dominant\" feature shown spot. using MapMultipleFeatures, aware type visualization bias shown. Preferably, selected features selecting way mutually exclusive, .e. expressed different spatial locations. values selected features rescaled visualization depending choice scale. scale=\"free\", numeric feature scaled independently across entire dataset values 0 1. useful selected features different scales want avoid features dominating. want keep relative differences different feature, can set scale=\"shared\". case, feature values scaled values 0 1 0 1 corresponds minimum maximum value across feature values. example useful visualizing cell type proportions case color intensity reflect relative differences. type visualization used caution. 1 color selected spot, biased focus dominant features. makes less meaningful focus exact values makes interpretation qualitative. can however useful way summarize spatial distribution features expressed different regions. best map features MapFeatures first, attempting summarize one plot.","code":""},{"path":[]},{"path":"https://ludvigla.github.io/semla/reference/visualize-multiple-features.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Map numeric features or categorical labels — MapMultipleFeatures","text":"Ludvig Larsson","code":""},{"path":"https://ludvigla.github.io/semla/reference/visualize-multiple-features.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Map numeric features or categorical labels — MapMultipleFeatures","text":"","code":"library(semla)  # Load example Visium data se_mbrain <- readRDS(system.file(\"extdata/mousebrain\",                                  \"se_mbrain\",                                  package = \"semla\"))  # Select features to plot sel_features = c(\"Th\", \"Trh\", \"Calb2\", \"Prkcd\")  # Map selected features MapFeatures(se_mbrain, features = sel_features)   # Summarize in one plot MapMultipleFeatures(se_mbrain,                     features = sel_features,                     pt_size = 2) #> Loading required namespace: ggnewscale   # Plot with H&E image se_mbrain <- se_mbrain |> LoadImages() #>  #> ── Loading H&E images ── #>  #> ℹ Loading image from /private/var/folders/zb/1fj07x_5343fvs_k28gnm1z80002xs/T/RtmpFJGwBj/temp_libpath502354c29e9d/semla/extdata/mousebrain/spatial/tissue_hires_image.jpg #> ℹ Scaled image from 2000x1882 to 400x376 pixels #> ℹ Saving loaded H&E images as 'rasters' in Seurat object MapMultipleFeatures(se_mbrain, image_use = \"raw\",                     features = sel_features,                     pt_size = 2)"},{"path":"https://ludvigla.github.io/semla/news/index.html","id":"semla-100","dir":"Changelog","previous_headings":"","what":"semla 1.0.0","title":"semla 1.0.0","text":"excited announce first release R package, semla. package designed process, analyze visualize Spatially Resolved Transcriptomics (SRT) data. Key features release include: Interactive data visualization annotation FeatureViewer web app Spatially aware analysis methods: RegionNeighbors, RadialDistance, CorSpatialFeatures, RunLocalG, RunLabelAssortativityTest, RunNeighborhoodEnrichmentTest, CutSpatialNetwork Visualization methods: MapFeatures, MapLabels Image processing: MaskImages, RigidTransformImages, RunAlignment Cell type mapping: RunNNLS like express gratitude Javier Morlanes Marcos Machado contributed release. appreciate feedback, suggestions, bug reports. invite users download install development version package GitHub repo explore features functionality. Please feel free provide feedback suggestions future improvements. Thank support look forward continuing enhance improve package. Sincerely, Ludvig Larsson Lovisa Franzén","code":""}]
