% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R, R/visualization_spatial.R
\name{MapLabels}
\alias{MapLabels}
\alias{MapLabels.default}
\alias{MapLabels.Seurat}
\title{Map categorical features}
\usage{
MapLabels(object, ...)

\method{MapLabels}{default}(
  object,
  spot_side = NULL,
  crop_area = NULL,
  pt_size = 1,
  pt_alpha = 1,
  pt_stroke = 0,
  shape = "point",
  section_number = NULL,
  label_by = NULL,
  split_labels = FALSE,
  ncol = NULL,
  colors = NULL,
  dims = NULL,
  coords_columns = c("pxl_col_in_fullres", "pxl_row_in_fullres"),
  return_plot_list = FALSE,
  drop_na = FALSE,
  add_scalebar = FALSE,
  scalebar_gg = NULL,
  scalebar_height = 0.05,
  scalebar_position = c(0.8, 0.8),
  ...
)

\method{MapLabels}{Seurat}(
  object,
  column_name,
  image_use = NULL,
  coords_use = "raw",
  crop_area = NULL,
  pt_size = 1,
  pt_alpha = 1,
  pt_stroke = 0,
  shape = "point",
  spot_side = NULL,
  section_number = NULL,
  label_by = NULL,
  split_labels = FALSE,
  ncol = NULL,
  colors = NULL,
  override_plot_dims = FALSE,
  return_plot_list = FALSE,
  drop_na = FALSE,
  add_scalebar = FALSE,
  scalebar_height = 0.05,
  scalebar_gg = scalebar(x = 500, text_height = 5),
  scalebar_position = c(0.8, 0.7),
  ...
)
}
\arguments{
\item{object}{An object}

\item{...}{Arguments passed to other methods}

\item{spot_side}{A numeric value or vector of values specifying the size of the spots in pixels
in the fullres image. Relevant for tile shape. Will default to each section's value  
retrieved via GetScaleFactors: \code{GetScaleFactors()$spot_diameter_fullres)}.}

\item{crop_area}{A numeric vector of length 4 specifying a rectangular area to crop
the plots by. These numbers should be within 0-1. The x-axis is goes from left=0 to
right=1 and the y axis is goes from top=0 to bottom=1. The order of the values are
specified as follows: \code{crop_area = c(left, top, right, bottom)}. The crop area
will be used on all tissue sections and cannot be set for each section individually.
using crop areas of different sizes on different sections can lead to unwanted side
effects as the point sizes will remain constant. In this case it is better to generate
separate plots for different tissue sections.}

\item{pt_size}{A numeric value specifying the point size passed to \code{geom_point}}

\item{pt_alpha}{A numeric value between 0 and 1 specifying the point opacity passed
to \code{geom_point}. A value of 0 will make the points completely transparent
and a value of 1 will make the points completely opaque.}

\item{pt_stroke}{A numeric specifying the point stroke width}

\item{shape}{A string specifying the shape to plot. Options are: 
\code{c("point", "raster", "tile")}.}

\item{section_number}{An integer select a tissue section number to subset data by}

\item{label_by}{A character specifying a column name in \code{object} with
labels that can be used to provide a title for each subplot. This column should have
1 label per tissue section. This can be useful when you need to provide more detailed
information about your tissue sections.}

\item{split_labels}{A logical specifying if labels should be split.}

\item{ncol}{An integer value specifying the number of columns in the output patchwork.}

\item{colors}{A character vector of colors to use for the color scale. The number of
colors should match the number of labels present.}

\item{dims}{A tibble with information about the tissue sections. This information is used to
determine the limits of the plot area. If \code{dims} is not provided, the limits will be
computed directly from the spatial coordinates provided in \code{object}.}

\item{coords_columns}{A character vector of length 2 specifying the names of the columns in
\code{object} holding the spatial coordinates}

\item{return_plot_list}{logical specifying whether the plots should be return as a list of
\code{ggplot} objects. If \code{return_plot_list = FALSE} (default), the plots will be arranged
into a \code{patchwork}}

\item{drop_na}{A logical specifying if NA values should be dropped}

\item{add_scalebar}{A logical specifying if a scale bar should be added to the plots}

\item{scalebar_gg}{A 'ggplot' object generated with \code{\link{scalebar}}. The appearance of the scale
bar is styled by passing parameters to \code{\link{scalebar}}.}

\item{scalebar_height}{A numeric value specifying the height of the scale bar relative to the
height of the full plot area. Has to be a value between 0 and 1. The title of the scale bar is
scaled with the plot and might disappear if the down-scaled text size is too small. Increasing
the height of the scale bar can sometimes be useful to increase the text size to make it more
visible in small plots.}

\item{scalebar_position}{A numeric vector of length 2 specifying the position of the scale bar
relative to the plot area. Default is to place it in the top right corner.}

\item{column_name}{A character specifying a meta data column holding the categorical
feature vector.}

\item{image_use}{A character specifying image type to use.}

\item{coords_use}{A character specifying coordinate type to use.}

\item{override_plot_dims}{A logical specifying whether the image dimensions should
be used to define the plot area. Setting \code{override_plot_dims} can be useful
in situations where the tissue section only covers a small fraction of the capture
area, which will create a lot of white space in the plots. The same effect can be
achieved with the \code{crop_area} but the crop area is instead determined directly
from the data.}
}
\value{
A \code{patchwork} object or a list of \code{ggplot} objects
}
\description{
\code{MapLabels} colors spots based on the values of a categorical feature.
}
\details{
You can only plot categorical features with \code{MapLabels},
for example: spot annotations or clusters.
If you want to plot numerical features, use \code{\link{MapFeatures}} instead.
Only 1 categorical feature can be provided.
}
\examples{

library(semla)

# Load Seurat object
se_mbrain <- readRDS(system.file("extdata/mousebrain", "se_mbrain", package = "semla"))

# Run PCA and data-driven clustering
se_mbrain <- se_mbrain |>
  ScaleData() |>
  RunPCA() |>
  FindNeighbors(reduction = "pca", dims = 1:10) |>
  FindClusters(resolution = 0.2) |>
  FindClusters(resolution = 0.3)

# Plot clusters
MapLabels(se_mbrain, column_name = "Spatial_snn_res.0.2", pt_size = 2)

# Plot clusters in split view
MapLabels(se_mbrain, column_name = "Spatial_snn_res.0.2", pt_size = 0.5,
          section_number = 1, split_labels = TRUE, ncol = 4)
          
\donttest{

# Combine plots with different labels
MapLabels(se_mbrain, column_name = "Spatial_snn_res.0.2") |
  MapLabels(se_mbrain, column_name = "Spatial_snn_res.0.3")

# Move legend to the right side of the plot
MapLabels(se_mbrain, column_name = "Spatial_snn_res.0.2", pt_size = 2) &
  theme(legend.position = "right")

# Override fill aesthetic to increase point sixe in legend
MapLabels(se_mbrain, column_name = "Spatial_snn_res.0.2", pt_size = 2) &
  guides(fill = guide_legend(override.aes = list(size = 4)))

# Use custom colors
cols <- c("#332288", "#88CCEE", "#117733", "#DDCC77", "#CC6677","#AA4499")
MapLabels(se_mbrain, column_name = "Spatial_snn_res.0.2", pt_size = 2, colors = cols)

# Factor are to used to determine the color order. If you change the
# levels of your label of interest, the labels and colors will change order
se_mbrain$Spatial_snn_res.0.2 <- factor(se_mbrain$Spatial_snn_res.0.2,
                                        levels = sample(paste0(0:7), size = 8))
MapLabels(se_mbrain, column_name = "Spatial_snn_res.0.2", pt_size = 2, colors = cols)

# Control what group label colors by naming the color vector
# this way you can make sure that each group gets a desired color
# regardless of the factor levels
cols <- setNames(cols, nm = paste0(0:5))
cols
MapLabels(se_mbrain, column_name = "Spatial_snn_res.0.2", pt_size = 2, colors = cols)
}

}
\seealso{
Other spatial-visualization-methods: 
\code{\link{AnglePlot}()},
\code{\link{FeatureViewer}()},
\code{\link{ImagePlot}()},
\code{\link{MapFeatures}()},
\code{\link{MapFeaturesSummary}()},
\code{\link{MapLabelsSummary}()},
\code{\link{MapMultipleFeatures}()}
}
\author{
Ludvig Larsson
}
\concept{spatial-visualization-methods}
\concept{visualization-visualization-methods}
